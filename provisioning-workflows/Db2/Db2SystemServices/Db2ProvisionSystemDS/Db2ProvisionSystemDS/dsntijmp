//*********************************************************************
//* JOB NAME = DSNTIJMP
//*
//* DESCRIPTIVE NAME = INSTALLATION JOB STREAM
//*
//*    Licensed Materials - Property of IBM
//*    5650-DB2
//*    (C) COPYRIGHT 1982, 2018 IBM Corp.  All Rights Reserved.
//*
//*    STATUS = Version 12
//*
//* FUNCTION = Adds the DB2 program preparation and utilities
//*            invocation JCL procs to the system proclib
//*
//* PSEUDOCODE =
//*   DSNTIPM  STEP      Add DB2 prog prep & util procs to SYS1.PROCLIB
//*
//* NOTES =
//*   Please check this job carefully to ensure that the system
//*   library names are the correct library names for your site.
//*
//*
//* CHANGE LOG:
//*   05/07/2017 Split up DSNTIJMV                               s74993
//*               - DSNTIJMV: Defines DB2 and IRLM to z/OS
//*               - DSNTIJMA: Adds the DB2 and IRLM startup procs to
//*                           the system proclib
//*               - DSNTIJMP: Adds the DB2 language procs to the
//*                           system proclib
//*               - DSNTIJMW: Adds the startup procs for the DB2-
//*                           supplied WLM environments to the system
//*                           proclib
//*               - DSNTIJMJ: Creates the environment files for the
//*                           DB2-supplied Java WLM environment
//*********************************************************************
//*
//DSNTIPM EXEC PGM=IEBUPDTE,PARM=NEW,COND=(4,LT)
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSUT2   DD DISP=SHR,DSN=${PPROCLIB}
//SYSIN    DD DATA
./  ADD NAME=DSNHASM
//**********************************************************************
//*
//*       DSNHASM - ASSEMBLE AND LINKEDIT A HIGH LEVEL ASM PROGRAM
//*
//DSNHASM PROC WSPC=500,MEM=TEMPNAME,USER=USER
//*
//*            PRE-COMPILE THE ASSEMBLER PROGRAM
//**********************************************************************
//PC      EXEC PGM=DSNHPC,PARM='HOST(ASM)'
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSCIN   DD  DSN=&&DSNHOUT,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//*
//*            ASSEMBLE IF THE PRECOMPILE RETURN CODE
//*            IS 4 OR LESS
//*
//ASM     EXEC PGM=ASMA90,PARM='OBJECT,NODECK',COND=(4,LT,PC)
#if ( ${ASMLIB} != "" )
//STEPLIB  DD DISP=SHR,DSN=${ASMLIB}
#end
//SYSIN    DD  DSN=&&DSNHOUT,DISP=(OLD,DELETE)
//SYSLIB   DD DISP=SHR,DSN=${MACLIB}
//#getDD("${GDDMMACS}","GDDM.SADMSAM")${B}
//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC)),DCB=(BLKSIZE=800)
//SYSPRINT DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//*
//*            LINKEDIT IF THE PRECOMPILER AND ASSEMBLER
//*            RETURN CODES ARE 4 OR LESS
//*
//LKED    EXEC PGM=IEWL,PARM='XREF',
//             COND=((4,LT,ASM),(4,LT,PC))
//SYSLIB   DD  DISP=SHR,
//             DSN=${DSNLOAD}
//#getDD("${RESLIB}","IMSVS.RESLIB")${B}
//#getDD("${CICSMOD}","CICSTS.SDFHLOAD")${B}
//#getDD("${ISPLOAD}","ISP.V3R5M0.ISPLOAD")${B}
//#getDD("${GDDMLOAD}","GDDM.SADMMOD")${B}
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DISP=SHR,
//         DSN=&USER..RUNLIB.LOAD(&MEM)
//SYSPRINT DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(1024,(50,50))#unitl("${TVOLDEVT}",",")${B}
//*DSNHASM PEND         REMOVE * FOR USE AS INSTREAM PROCEDURE
./  ADD NAME=DSNHC
//**********************************************************************
//*       DSNHC - COMPILE AND LINKEDIT A C LANGUAGE PROGRAM
//*
//DSNHC  PROC WSPC=500,MEM=TEMPNAME,USER=USER
//*
//*            PRECOMPILE THE C PROGRAM
//**********************************************************************
//PC      EXEC PGM=DSNHPC,PARM='HOST(C)'
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSCIN   DD  DSN=&&DSNHOUT,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//*
//*            COMPILE THE C PROGRAM IF THE PRECOMPILE
//*            RETURN CODE IS 4 OR LESS
//*
//C       EXEC PGM=#getCprog("${CPROG}")${B},COND=(4,LT,PC),
//             PARM='RENT OPTFILE(DD:CCOPTS)'
#if (${CCOMP}!="")
//STEPLIB  DD DISP=SHR,DSN=${CCOMP}
#end
//CCOPTS   DD  DISP=SHR,
//         DSN=${PPROCLIB}(DSNHCS)
//SYSLIB   DD DISP=SHR,DSN=#getChdrs("${CHDRS}")${B}
//         DD DISP=SHR,DSN=#getDsnchdrs("${DSNCHDRS}")${B}
//#getDD("${GDDMMACS}","GDDM.SADMSAM")${B}
//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSPRINT DD  SYSOUT=*
//SYSCPRT  DD  SYSOUT=*
//SYSTERM  DD  DUMMY
//SYSIN    DD  DSN=&&DSNHOUT,DISP=(OLD,DELETE)
//SYSUT1   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT2   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT3   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT4   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT5   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT6   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT7   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT8   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT9   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)
//SYSUT10  DD  SYSOUT=*
//SYSUT14  DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
#if ( ${CPRLK} == "YES" )
//*
//*            PRE-LINKEDIT
//*
//PLKED   EXEC PGM=EDCPRLK,COND=((4,LT,PC),(4,LT,C))
#if (${LERUN}!="")
//STEPLIB  DD DISP=SHR,DSN=${LERUN}
#end
//SYSMSGS  DD DISP=SHR,
//         DSN=#getLeplmsgl("${LEPLMSGL}")${B}(EDCPMSGE)
//SYSLIB   DD  DUMMY
//SYSIN    DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//SYSMOD   DD  DSN=&&PLKSET#unitl("${TVOLDEVT}",",")${B},DISP=(MOD,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSDEFSD DD  DUMMY
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
#end
//*
#if ( ${CPRLK} == "YES" )
//*            LINKEDIT IF THE PRECOMPILE, COMPILE AND PRELINK
#else
//*            LINKEDIT IF THE PRECOMPILE AND COMPILE
#end
//*            RETURN CODES ARE 4 OR LESS
//*
//LKED    EXEC PGM=IEWL,PARM='MAP',
//             #getLkedCondC("${CPRLK}")${B}
//SYSLIB   DD DISP=SHR,DSN=#getLelked("${LELKED}")${B}
//         DD DISP=SHR,DSN=${DSNLOAD}
//#getDD("${RESLIB}","IMSVS.RESLIB")${B}
//#getDD("${CICSMOD}","CICSTS.SDFHLOAD")${B}
//#getDD("${ISPLOAD}","ISP.V3R5M0.ISPLOAD")${B}
//#getDD("${GDDMLOAD}","GDDM.SADMMOD")${B}
//SYSLIN   DD  #getLkedSetC("${CPRLK}")${B},DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DISP=SHR,
//         DSN=&USER..RUNLIB.LOAD(&MEM)
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  SPACE=(32000,(30,30))#unitl("${TVOLDEVT}",",")${B}
//*DSNHC   PEND         REMOVE * FOR USE AS INSTREAM PROCEDURE
./  ADD NAME=DSNHCS
 SEARCH('#getCeeHPre("${CHDRS}").+',
#if (${GDDMMACS}!="")
        '${GDDMMACS}',
#end
        '#getDsnCHPre("${DSNCHDRS}")')
./  ADD NAME=DSNHCPP
//**********************************************************************
//*       DSNHCPP - COMPILE AND LINKEDIT A C++ LANGUAGE PROGRAM
//*
//DSNHCPP  PROC WSPC=500,MEM=TEMPNAME,USER=USER
//*
//*            PRECOMPILE THE C PROGRAM
//**********************************************************************
//PC      EXEC PGM=DSNHPC,PARM='HOST(CPP)'
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSCIN   DD  DSN=&&DSNHOUT,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//*
//*            COMPILE THE C++ PROGRAM IF THE PRECOMPILE
//*            RETURN CODE IS 4 OR LESS
//*
//CP      EXEC PGM=#getCprog("${CPROG}")${B},COND=(4,LT,PC),
//             PARM='/CXX OPTFILE(DD:CCOPTS)'
#if (${CCOMP}!="")
//STEPLIB  DD DISP=SHR,DSN=${CCOMP}
#end
//CCOPTS   DD  DISP=SHR,
//         DSN=${PPROCLIB}(DSNHCPPS)
//USERLIB  DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSPRINT DD  SYSOUT=*
//SYSCPRT  DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//SYSIN    DD  DSN=&&DSNHOUT,DISP=(OLD,DELETE)
//SYSUT1   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT4   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT5   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT6   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT7   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT8   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT9   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)
//SYSUT10  DD  SYSOUT=*
//SYSUT14  DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT15  DD  SYSOUT=*
#if ( ${CPPPRLK} == "YES" )
//*
//*            PRE-LINKEDIT
//*
//PLKED   EXEC PGM=EDCPRLK,COND=((4,LT,PC),(4,LT,CP))
#if (${LERUN}!="")
//STEPLIB  DD DISP=SHR,DSN=${LERUN}
#end
//SYSMSGS  DD DISP=SHR,
//         DSN=#getLeplmsgl("${LEPLMSGL}")${B}(EDCPMSGE)
//SYSLIB   DD DISP=SHR,DSN=#getCppautcl("${CPPAUTCL}")${B}
//         DD DISP=SHR,DSN=#getCppclass("${CPPCLASS}")${B}
//SYSIN    DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//SYSMOD   DD  DSN=&&PLKSET#unitl("${TVOLDEVT}",",")${B},DISP=(MOD,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSDEFSD DD  DUMMY
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
#end
//*
#if ( ${CPPPRLK} == "YES" )
//*            LINKEDIT IF THE PRECOMPILE, COMPILE AND PRELINK
#else
//*            LINKEDIT IF THE PRECOMPILE AND COMPILE
#end
//*            RETURN CODES ARE 4 OR LESS
//*
//LKED    EXEC PGM=HEWL,PARM='MAP',
//             #getLkedCondCpp("${CPPPRLK}")${B}
//SYSLIB   DD DSN=#getLelked("${LELKED}")${B},DISP=SHR
#if ( ${CPPPRLK} == "NO" )
//         DD DISP=SHR,DSN=#getCppautcl("${CPPAUTCL}")${B}
//         DD DISP=SHR,DSN=#getCppclass("${CPPCLASS}")${B}
#end
//         DD DISP=SHR,DSN=${DSNLOAD}
//#getDD("${RESLIB}","IMSVS.RESLIB")${B}
//#getDD("${CICSMOD}","CICSTS.SDFHLOAD")${B}
//#getDD("${ISPLOAD}","ISP.V3R5M0.ISPLOAD")${B}
//SYSLIN   DD  #getLkedSetCpp("${CPPPRLK}"),DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DISP=SHR,
//         DSN=&USER..RUNLIB.LOAD(&MEM)
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  SPACE=(32000,(30,30))#unitl("${TVOLDEVT}",",")${B}
//*DSNHCPP PEND         REMOVE * FOR USE AS INSTREAM PROCEDURE
./  ADD NAME=DSNHCPPS
 SEARCH('#getCeeHPre("${CHDRS}").+',
        '#getClbHPre("${CPPHDRS}")',
#if (${GDDMMACS}!="")
        '${GDDMMACS}',
#end
        '#getDsnCHPre("${DSNCHDRS}")')
 NOTEMPINC
./  ADD NAME=DSNHCPP2
//********************************************************************
#if ( ${CPPPRLK} == "YES" )
//* DSNHCPP2  -  PRECOMPILE, COMPILE, PRELINK, AND LINK A C++        *
#else
//* DSNHCPP2  -  PRECOMPILE, COMPILE, AND LINK A C++                 *
#end
//*              CLIENT AND CLASS.                                   *
//********************************************************************
//DSNHCPP2  PROC WSPC=500,MEM=TEMPN,USER=USER
//********************************************************************
//*        PRECOMPILE THE C++ CLIENT PROGRAM.                        *
//********************************************************************
//PC1     EXEC PGM=DSNHPC,PARM='HOST(CPP)'
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSCIN   DD  DSN=&&DSNHOT1,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//********************************************************************
//*        COMPILE THE C++ CLIENT PROGRAM IF THE                     *
//*        RETURN CODE FOR THE PRECOMPILE IS 4 OR LESS.              *
//********************************************************************
//CP1     EXEC PGM=#getCprog("${CPROG}")${B},
//             COND=(4,LT,PC1),PARM='/CXX OPTFILE(DD:CCOPTS)'
#if (${CCOMP}!="")
//STEPLIB  DD DISP=SHR,DSN=${CCOMP}
#end
//CCOPTS   DD  DISP=SHR,
//         DSN=${PPROCLIB}(DSNHCPPS)
//USERLIB  DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSLIN   DD  DSN=&&LOADSET1,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSPRINT DD  SYSOUT=*
//SYSCPRT  DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//SYSIN    DD  DSN=&&DSNHOT1,DISP=(OLD,DELETE)
//SYSUT1   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT4   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT5   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT6   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT7   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT8   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT9   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)
//SYSUT10  DD  SYSOUT=*
//SYSUT14  DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT15  DD  SYSOUT=*
//********************************************************************
//*        PRECOMPILE THE C++ CLASS DEFINITION.                      *
//********************************************************************
//PC2     EXEC PGM=DSNHPC,PARM='HOST(CPP)'
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSCIN   DD  DSN=&&DSNHOT2,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//********************************************************************
//*        COMPILE THE C++ CLASS IF THE                              *
//*        RETURN CODE FOR THE PRECOMPILE IS 4 OR LESS.              *
//********************************************************************
//CP2     EXEC PGM=#getCprog("${CPROG}")${B},
//             COND=(4,LT,PC2),PARM='/CXX OPTFILE(DD:CCOPTS)'
#if (${CCOMP}!="")
//STEPLIB  DD DISP=SHR,DSN=${CCOMP}
#end
//CCOPTS   DD  DISP=SHR,
//         DSN=${PPROCLIB}(DSNHCPPS)
//USERLIB  DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSLIN   DD  DSN=&&LOADSET2,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSPRINT DD  SYSOUT=*
//SYSCPRT  DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//SYSIN    DD  DSN=&&DSNHOT2,DISP=(OLD,DELETE)
//SYSUT1   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT4   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT5   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT6   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT7   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT8   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT9   DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)
//SYSUT10  DD  SYSOUT=*
//SYSUT14  DD #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT15  DD  SYSOUT=*
#if ( ${CPPPRLK} == "YES" )
//********************************************************************
//*        PRELINK IF THE RETURN CODES FROM THE COMPILE STEPS        *
//*        ARE 4 OR LESS.                                            *
//********************************************************************
//PLKED   EXEC PGM=EDCPRLK,COND=((4,LT,CP1),(4,LT,CP2))
#if (${LERUN}!="")
//STEPLIB  DD DISP=SHR,DSN=${LERUN}
#end
//SYSMSGS  DD DISP=SHR,
//         DSN=#getLeplmsgl("${LEPLMSGL}")${B}(EDCPMSGE)
//SYSLIB   DD DISP=SHR,DSN=#getCppautcl("${CPPAUTCL}")${B}
//         DD DISP=SHR,DSN=#getCppclass("${CPPCLASS}")${B}
//SYSIN    DD  DSN=&&LOADSET1,DISP=(OLD,DELETE)
//         DD  DSN=&&LOADSET2,DISP=(OLD,DELETE)
//SYSMOD   DD  DSN=&&PLKSET#unitl("${TVOLDEVT}",",")${B},DISP=(MOD,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSDEFSD DD  DUMMY
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
#end
//********************************************************************
#if ( ${CPPPRLK} == "YES" )
//*        LINKEDIT IF THE RETURN CODE FOR THE PRELINK               *
#else
//*        LINKEDIT IF THE RETURN CODE FOR THE COMPILE               *
#end
//*        STEP IS 4 OR LESS.                                        *
//********************************************************************
//LKED    EXEC PGM=HEWL,PARM='MAP',
//             #getLkedCondCpp2("${CPPPRLK}")${B}
//SYSLIB   DD DISP=SHR,DSN=#getLelked("${LELKED}")${B}
#if ( ${CPPPRLK} == "NO" )
//         DD DISP=SHR,DSN=#getCppautcl("${CPPAUTCL}")${B}
//         DD DISP=SHR,DSN=#getCppclass("${CPPCLASS}")${B}
#end
//         DD DISP=SHR,DSN=${DSNLOAD}
//#getDD("${RESLIB}","IMSVS.RESLIB")${B}
//#getDD("${CICSMOD}","CICSTS.SDFHLOAD")${B}
//#getDD("${ISPLOAD}","ISP.V3R5M0.ISPLOAD")${B}
#getLkedSetCpp2("${CPPPRLK}")${B}
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DISP=SHR,
//         DSN=&USER..RUNLIB.LOAD(&MEM)
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  SPACE=(32000,(30,30))#unitl("${TVOLDEVT}",",")${B}
//*DSNHCPP2 PEND         REMOVE * FOR USE AS INSTREAM PROCEDURE
./  ADD NAME=DSNHICOB
//********************************************************************
//*        DSNHICOB  - DB2 precompile, IBM COBOL compile, pre-link,  *
//*                    and link edit a DB2 SQL program.              *
//********************************************************************
//DSNHICOB PROC WSPC=500,MEM=TEMPNAME,USER=USER
//********************************************************************
//*        Precompile the IBM COBOL program                          *
//********************************************************************
//PC       EXEC PGM=DSNHPC,PARM='HOST(IBMCOB)'
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSCIN   DD  DSN=&&DSNHOUT,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//********************************************************************
//*        Compile the IBM COBOL program if the precompile           *
//*        return code is 4 or less.                                 *
//********************************************************************
//COB      EXEC PGM=IGYCRCTL,
//             PARM=(NOSEQUENCE,QUOTE,RENT,'PGMNAME(LONGUPPER)'),
//             COND=(4,LT,PC)
#if ( ${ICOBCOMP} != "" )
//STEPLIB DD DSN=${ICOBCOMP},DISP=SHR
#end
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSIN    DD  DSN=&&DSNHOUT,DISP=(OLD,DELETE)
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT3   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT4   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT5   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT6   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT7   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
#if ( ${ICOBPRLK} == "NO" )
//SYSUT8   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT9   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT10  DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT11  DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT12  DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT13  DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT14  DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT15  DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSMDECK DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
#end
#if ( ${ICOBPRLK} == "YES" )
//********************************************************************
//*  PRELINK STEP.                                                   *
//********************************************************************
//PLKED   EXEC PGM=EDCPRLK,COND=((4,LT,PC),(4,LT,COB))
//STEPLIB  DD DISP=SHR,DSN=${LERUN}
//SYSMSGS  DD DISP=SHR,
//         DSN=${LEPLMSGL}(EDCPMSGE)
//SYSIN    DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//SYSMOD   DD  DSN=&&PLKSET#unitl("${TVOLDEVT}",",")${B},DISP=(MOD,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSDEFSD DD  DUMMY
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
#end
//********************************************************************
//*        Linkedit if the precompile and compile                    *
//*        return codes are 4 or less.                               *
//********************************************************************
//LKED     EXEC PGM=IEWL,PARM='MAP',
//         #getPlkCond("${ICOBPRLK}")${B}
//SYSLIB   DD DISP=SHR,DSN=${LELKED}
//         DD DISP=SHR,DSN=${DSNLOAD}
//#getDD("${RESLIB}","IMSVS.RESLIB")${B}
//#getDD("${CICSMOD}","CICSTS.SDFHLOAD")${B}
//#getDD("${ISPLOAD}","ISP.V3R5M0.ISPLOAD")${B}
//#getDD("${GDDMLOAD}","GDDM.SADMMOD")${B}
//SYSLIN   DD  #getPlkset("${ICOBPRLK}"),DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DISP=SHR,
//         DSN=&USER..RUNLIB.LOAD(&MEM)
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  SPACE=(1024,(50,50))#unitl("${TVOLDEVT}",",")${B}
//*DSNHICOB PEND        Remove * for use as an instream procedure
./  ADD NAME=DSNHPLI
//**********************************************************************
//*       DSNHPLI - COMPILE AND LINKEDIT A PL/I PROGRAM
//*
//DSNHPLI PROC WSPC=500,MEM=TEMPNAME,USER=USER
//*
//*            PROCESS PL/I MACROS
//**********************************************************************
//PPLI    EXEC PGM=IBMZPLI,PARM='MACRO,NOSYNTAX,MDECK,NOINSOURCE'
#if ( ${PLICOMP} != "" )
//STEPLIB  DD DISP=SHR,DSN=${PLICOMP}
#end
//SYSLIN   DD  DUMMY
//SYSPRINT DD  SYSOUT=*,
//             DCB=(RECFM=VBA,LRECL=125,BLKSIZE=629)
//SYSPUNCH DD  DSN=&&DSNHIN,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(CYL,(5,2),RLSE)
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(1024,(60,60),,CONTIG)#unitl("${TVOLDEVT}",",")${B},
//             DCB=BLKSIZE=1024
//*
//*            PRECOMPILE THE PL/I PROGRAM
//*
//PC      EXEC PGM=DSNHPC,COND=(8,LT,PPLI),
//             PARM='HOST(PLI)'
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSCIN   DD  DSN=&&DSNHOUT,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSIN    DD  DSN=&&DSNHIN,DISP=(OLD,DELETE)
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//*
//*            COMPILE THE PL/I PROGRAM IF THE PRECOMPILE
//*            RETURN CODE IS 4 OR LESS
//*
//PLI     EXEC PGM=IBMZPLI,COND=((4,LT,PC),(8,LT,PPLI)),
//             PARM='OBJ,SOURCE,OP,LIMITS(EXTNAME(7))'
#if ( ${PLICOMP} != "" )
//STEPLIB  DD DISP=SHR,DSN=${PLICOMP}
#end
//SYSIN    DD  DSN=&&DSNHOUT,DISP=(OLD,DELETE)
#if ( ${CICSMOD}!="" &&
      ${CICSPLI}!="" )
//SYSLIB   DD DISP=SHR,DSN=${CICSPLI}
//#getDD("${GDDMMACS}","GDDM.SADMSAM")${B}
#else
//*SYSLIB  DD DISP=SHR,DSN=CICSTS.SDFHPL1
#getDDSyslib("${GDDMMACS}","GDDM.SADMSAM")${B}
#end
//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSPRINT DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT3   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT4   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
#if ( ${PLIPRLK} == "YES" )
//*
//*            PRE-LINKEDIT
//*
//PLKED   EXEC PGM=EDCPRLK,COND=((8,LT,PPLI),(4,LT,PC),(4,LT,PLI))
#if (${LERUN}!="")
//STEPLIB  DD DISP=SHR,DSN=${LERUN}
#end
//SYSMSGS  DD DISP=SHR,
//         DSN=#getLeplmsgl("${LEPLMSGL}")${B}(EDCPMSGE)
//SYSLIB   DD  DUMMY
//SYSDEFSD DD  DUMMY
//SYSIN    DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//SYSMOD   DD  DSN=&&PLKSET,DISP=(MOD,PASS),
//            #unitl("${TVOLDEVT}"," ")${B},SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSDEFSD DD  DUMMY
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
#end
//*
//*            LINKEDIT IF THE COMPILE RETURN CODE IS 8 OR
//*            LESS AND PRECOMPILE RETURN CODE IS 4 OR LESS
#if ( ${PLIPRLK} == "YES" )
//*            AND PRELINKER RETURN CODE IS 4 OR LESS
#end
//*
//LKED     EXEC PGM=IEWL,PARM='XREF',
//             #getLkedCondPli("${PLIPRLK}")${B}
//SYSLIB   DD DISP=SHR,DSN=#getLelked("${LELKED}")${B}
//         DD DISP=SHR,DSN=${DSNLOAD}
//#getDD("${RESLIB}","IMSVS.RESLIB")${B}
//#getDD("${CICSMOD}","CICSTS.SDFHLOAD")${B}
//#getDD("${ISPLOAD}","ISP.V3R5M0.ISPLOAD")${B}
//#getDD("${GDDMLOAD}","GDDM.SADMMOD")${B}
//SYSLIN   DD  #getLkedSetPli("${PLIPRLK}"),DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DISP=SHR,
//         DSN=&USER..RUNLIB.LOAD(&MEM)
//SYSPRINT DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(1024,(50,50))#unitl("${TVOLDEVT}",",")${B}
//*DSNHPLI PEND         REMOVE * FOR USE AS INSTREAM PROCEDURE
./  ADD NAME=DSNHFOR
//**********************************************************************
//*       DSNHFOR - COMPILE AND LINKEDIT A VS FORTRAN PROGRAM
//*
//DSNHFOR PROC WSPC=500,MEM=TEMPNAME,USER=USER
//*
//*            PRECOMPILE THE VS FORTRAN PROGRAM
//**********************************************************************
//PC      EXEC PGM=DSNHPC,PARM='HOST(FORTRAN)'
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSCIN   DD  DSN=&&DSNHOUT,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//*
//*            COMPILE THE VS FORTRAN PROGRAM IF THE PRECOMPILE
//*            RETURN CODE IS 4 OR LESS
//*
//FORT    EXEC PGM=FORTVS2,COND=(4,LT,PC),
//             PARM='NODECK,NOLIST,OPT(0)'
#if ( ${FORTCOMP} != "" )
//STEPLIB  DD  DSN=${FORTCOMP},DISP=SHR
#end
//SYSIN    DD  DSN=&&DSNHOUT,DISP=(OLD,DELETE)
//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=3429
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSUT1   DD  SPACE=(3465,(3,3)),DCB=BLKSIZE=3465#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(5048,(10,10))#unitl("${TVOLDEVT}",",")${B}
//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(3200,(25,6)),DCB=BLKSIZE=3200
//*
//*            LINKEDIT IF THE PRECOMPILE AND COMPILE
//*            RETURN CODES ARE 4 OR LESS
//*
//LKED    EXEC PGM=IEWL,PARM='XREF',
//             COND=((4,LT,FORT),(4,LT,PC))
//SYSPRINT DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSLIB   DD DISP=SHR,DSN=${FORTLINK}
//         DD  DISP=SHR,
//             DSN=${DSNLOAD}
//#getDD("${ISPLOAD}","ISP.V3R5M0.ISPLOAD")${B}
//SYSUT1   DD  SPACE=(1024,(50,50))#unitl("${TVOLDEVT}",",")${B}
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DISP=SHR,
//         DSN=&USER..RUNLIB.LOAD(&MEM)
//*DSNHFOR PEND         REMOVE * FOR USE AS INSTREAM PROCEDURE
./  ADD NAME=DSNHSQL
//**********************************************************************
//*       DSNHSQL - COMPILE AND LINKEDIT A DB2 SQL PROCEDURE
//*
//DSNHSQL PROC WSPC=500,MEM=TEMPNAME,USER=USER,ECCSID=${DEFCCSID}
//*
//*  Note: Steps PC and PCC must use the same CCSID setting
//*
//*  Note: The DD statements for SYSCIN in step PCC and SYSIN in step C
//*        currently specify temporary data sets.  If you want to use
//*        the Debug Tool, you need to override those DD statements to
//*        specify the name of a permanent data set.  That data set
//*        must have a record format of FB and logical record length of
//*        80 bytes.  When you execute the Debug Tool, you use that
//*        data set as the input.
//*
//*        Example of overriding PCC.SYSCIN and C.SYSIN:
//*
//*        //PH063S02 EXEC DSNHSQL,MEM=SQLP
//*        //PC.SYSIN   DD DISP=SHR,DSN=APPLDEV.SQLSRC(SQLP)
//*        //PCC.SYSCIN DD DISP=SHR,DSN=APPLDEV.DEBUG.TOOL.INPUT(SQLP)
//*        //C.SYSIN    DD DISP=SHR,DSN=APPLDEV.DEBUG.TOOL.INPUT(SQLP)
//*
//*********************************************************************
//* PC: Precompile the SQL Procedure source
//*********************************************************************
//PC      EXEC PGM=DSNHPC,
//             PARM='HOST(SQL),CCSID(&ECCSID)'
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSCIN   DD  DSN=&&DSNHSQL,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSUT1   DD  DUMMY  <-- simplified DDL to register SQL SP
//SYSUT2   DD  DUMMY  <-- DDL to register PSM SP (V6.1 and subsequent)
//*
//*********************************************************************
//* PCC: Precompile C source generated by the previous step
//*********************************************************************
//PCC     EXEC PGM=DSNHPC,
//             COND=(4,LT,PC),
//             PARM='HOST(C),MAR(1,80),CCSID(&ECCSID),TWOPASS'
//STEPLIB  DD DISP=SHR,DSN=${DSNEXIT}
//         DD DISP=SHR,DSN=${DSNLOAD}
//DBRMLIB  DD DISP=SHR,
//         DSN=&USER..DBRMLIB.DATA(&MEM)
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSIN    DD  DSN=&&DSNHSQL,DISP=(OLD,DELETE)
//SYSCIN   DD  DSN=&&DSNHOUT,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD DISP=SHR,DSN=&USER..SRCLIB.DATA
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND)#unitl("${TVOLDEVT}",",")${B}
//*
//*********************************************************************
//* C: Compile the output from the precompiler
//*********************************************************************
//C       EXEC PGM=#getCprog("${CPROG}")${B},
//             COND=((4,LT,PC),(4,LT,PCC)),
//             PARM='MAR(1,80) NOSEQ LO RENT LOCALE("SAA")
//             OPTFILE(DD:CCOPTS)'
#if (${CCOMP} != "")
//STEPLIB  DD DISP=SHR,DSN=${CCOMP}
#end
//CCOPTS   DD  DISP=SHR,
//         DSN=${PPROCLIB}(DSNHCS)
//SYSLIB   DD DISP=SHR,DSN=#getChdrs("${CHDRS}")${B}
//         DD DISP=SHR,DSN=#getDsnchdrs("${DSNCHDRS}")${B}
//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS)#unitl("${TVOLDEVT}",",")${B},
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSPRINT DD  SYSOUT=*
//SYSCPRT  DD  SYSOUT=*
//SYSTERM  DD  DUMMY
//SYSIN    DD  DSN=&&DSNHOUT,DISP=(OLD,DELETE)
//SYSUT1   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT2   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT3   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT4   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT5   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT6   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT7   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT8   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT9   DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)
//SYSUT10  DD  SYSOUT=*
//SYSUT14  DD #unitl("${TVOLDEVT}"," ")${B},DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//*
#if ( ${CPRLK} == "YES" )
//*********************************************************************
//* PLKED: Pre-linkedit the object module from the C compiler
//*********************************************************************
//PLKED   EXEC PGM=EDCPRLK,COND=((4,LT,PC),(4,LT,PCC),(4,LT,C))
#if (${LERUN}!="")
//STEPLIB  DD DISP=SHR,DSN=${LERUN}
#end
//SYSMSGS  DD DISP=SHR,
//         DSN=#getLeplmsgl("${LEPLMSGL}")${B}(EDCPMSGE)
//SYSLIB   DD  DUMMY
//SYSIN    DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//SYSMOD   DD  DSN=&&PLKSET#unitl("${TVOLDEVT}",",")${B},DISP=(MOD,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSDEFSD DD  DUMMY
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//*
#end
//*********************************************************************
#if ( ${CPRLK} == "YES" )
//* LKED: Linkedit the output from the pre-linkeditor
#else
//* LKED: Linkedit the output from the compiler
#end
//*********************************************************************
//LKED    EXEC PGM=IEWL,
//             #getLkedCondSql("${CPRLK}")${B},
//             PARM='MAP'
//SYSLIB   DD DISP=SHR,DSN=#getLelked("${LELKED}")${B}
//         DD DISP=SHR,DSN=${DSNLOAD}
//SYSLIN   DD  #getLkedSetSql("${CPRLK}")${B},DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DISP=SHR,
//         DSN=&USER..RUNLIB.LOAD(&MEM)
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  SPACE=(32000,(30,30))#unitl("${TVOLDEVT}",",")${B}
//*DSNHSQL PEND         REMOVE * FOR USE AS INSTREAM PROCEDURE
./  ADD NAME=DSNUPROC
//DSNUPROC PROC LIB='${DSNLOAD}',
//         SYSTEM=${MVSSNAME},
//         SIZE=0K,UID='',UTPROC=''
//*
//**********************************************************************
//*                                                                    *
//* PROCEDURE-NAME:      DSNUPROC                                      *
//*                                                                    *
//* DESCRIPTIVE-NAME:    UTILITY PROCEDURE                             *
//*                                                                    *
//* FUNCTION:  THIS PROCEDURE INVOKES THE ADMF UTILITIES IN THE        *
//*             BATCH ENVIRONMENT                                      *
//*                                                                    *
//* PROCEDURE-OWNER:     UTILITY COMPONENT                             *
//*                                                                    *
//* COMPONENT-INVOKED:   ADMF UTILITIES (ENTRY POINT DSNUTILB).        *
//*                                                                    *
//* ENVIRONMENT:         BATCH                                         *
//*                                                                    *
//* INPUT:                                                             *
//*      PARAMETERS:                                                   *
//*           LIB    = THE DATA SET NAME OF THE DB2  PROGRAM LIBRARY.  *
//*                    THE DEFAULT LIBRARY NAME IS PREFIX.SDSNLOAD,    *
//*                    WITH PREFIX SET DURING INSTALLATION.            *
//*           SIZE   = THE REGION SIZE OF THE UTILITIES EXECUTION AREA.*
//*                    THE DEFAULT REGION SIZE IS 2048K.               *
//*           SYSTEM = THE SUBSYSTEM NAME USED TO IDENTIFY THIS JOB    *
//*                    TO DB2 .  THE DEFAULT IS "DSN".                 *
//*           UID    = THE IDENTIFIER WHICH WILL DEFINE THIS UTILITY   *
//*                    JOB TO DB2.  IF THE PARAMETER IS DEFAULTED OR   *
//*                    SET TO A NULL STRING, THE UTILITY FUNCTION WILL *
//*                    USE ITS DEFAULT, USERID.JOBNAME.  EACH UTILITY  *
//*                    WHICH HAS STARTED AND IS NOT YET TERMINATED     *
//*                    (MAY NOT BE RUNNING) MUST HAVE A UNIQUE UID.    *
//*           UTPROC = AN OPTIONAL INDICATOR USED TO DETERMINE WHETHER *
//*                    THE USER WISHES TO INITIALLY START THE REQUESTED*
//*                    UTILITY OR TO RESTART A PREVIOUS EXECUTION OF   *
//*                    THE UTILITY.  IF OMITTED, THE UTILITY WILL      *
//*                    BE INITIALLY STARTED.  OTHERWISE, THE UTILITY   *
//*                    WILL BE RESTARTED BY ENTERING THE FOLLOWING     *
//*                    VALUES:                                         *
//*                       RESTART(PHASE)  = RESTART THE UTILITY AT THE *
//*                               BEGINNING OF THE PHASE EXECUTED      *
//*                               LAST.                                *
//*                        RESTART = RESTART THE UTILITY AT THE LAST   *
//*                               OR CURRENT COMMIT POINT.             *
//*                                                                    *
//* OUTPUT: NONE.                                                      *
//*                                                                    *
//* EXTERNAL-REFERENCES: NONE.                                         *
//*                                                                    *
//* CHANGE-ACTIVITY:                                                   *
//*                                                                    *
//*                                                                    *
//**********************************************************************
//*
//DSNUPROC EXEC PGM=DSNUTILB,REGION=&SIZE,
//         PARM='&SYSTEM,&UID,&UTPROC'
//STEPLIB  DD   DSN=&LIB,DISP=SHR
//*
//**********************************************************************
//*                                                                    *
//*  THE FOLLOWING DEFINE THE UTILITIES' PRINT DATA SETS               *
//*                                                                    *
//**********************************************************************
//*
//SYSPRINT DD   SYSOUT=*
//UTPRINT  DD   SYSOUT=*
//SYSUDUMP DD   SYSOUT=*
//*DSNUPROC PEND        REMOVE * FOR USE AS INSTREAM PROCEDURE
./  ENDUP
/*
## Macro to get the prefix of C/CPP header library
## $dsn is the C/CPP header library
#macro(getCeeHPre $dsn)
#set ($len = $dsn.length() - 2)
#if ($dsn.endsWith(".H"))
$dsn.substring(0,$len)#else
CEE.SCEEH#end#end
## Macro to get the prefix of the include library
## $dsn is the include library
#macro(getDsnCHPre $dsn)
#set ($len = $dsn.length() - 2)
#if ($dsn.endsWith(".H"))
$dsn.substring(0,$len).+#else
DSN.SDSNC.+#end#end
## Macro to get the prefix of the CPP class library
## $dsn is the CPP class library
#macro(getClbHPre $dsn)
#set ($len1 = $dsn.length() - 4)
#set ($len2 = $dsn.length() - 2)
#if ($dsn.endsWith(".HPP"))
$dsn.substring(0,$len1).+#else
#if ($dsn.endsWith(".H"))
$dsn.substring(0,$len2).+#else
CBC.SCLBH.+#end#end#end
## Macro to get C C++ compiler name
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getCprog $lib)
#getLib($lib, "CCNDRVR")#end
## Macro to get LE prelink message library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getLeplmsgl $lib)
#getLib($lib, "CEE.V!R!M!.SCEEMSGP")#end
## Macro to get LE link edit library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getLelked $lib)
#getLib($lib, "CEE.V!R!M!.SCEELKED")#end
## Macro to get CPP auto call library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getCppautcl $lib)
#getLib($lib, "CEE.V!R!M!.SCEECPP")#end
## Macro to get CPP class library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getCppclass $lib)
#getLib($lib, "CBC.V!R!M!.SCLBCPP")#end
## Macro to get system procedure library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getProclib $lib)
#getLib($lib, "SYS1.PROCLIB")#end
## Macro to get C/CPP header library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getChdrs $lib)
#getLib($lib, "CEE.V!R!M!.SCEEH.H")#end
## Macro to get DB2 include library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getDsnchdrs $lib)
#getLib($lib, "DSN!!0.SDSNC.H")#end
## Macro to get library name
## $lib is the user specified library name
## $dflt is the default library name
## return $lib if it is not blank, return default otherwise
#macro (getLib $lib $dflt)
#if ($lib == "")
$dflt#else$lib#end#end
## Macro to get the DSNHC LKED COND CARD
## $ic is the C LE prelinker phase
#macro(getLkedCondC $ic)
#if ($ic.equals("YES"))
COND=((4,LT,PC),(4,LT,C),(4,LT,PLKED))#else
COND=((4,LT,PC),(4,LT,C))#end#end
## Macro to get the DSNHC LKED sysin dataset
## $ic is the C LE prelinker phase
#macro(getLkedSetC $ic)
#if ($ic.equals("NO"))
DSN=&&LOADSET#else
DSN=&&PLKSET#end#end
## Macro to get the DSNHCPP LKED COND CARD
## $icpp is the CPP LE prelinker phase
#macro(getLkedCondCpp $icpp)
#if ($icpp.equals("YES"))
COND=((4,LT,PC),(4,LT,CP),(4,LT,PLKED))#else
COND=((4,LT,PC),(4,LT,CP))#end#end
## Macro to get the DSNHCPP LKED sysin dataset
## $icpp is the CPP LE prelinker phase
#macro(getLkedSetCpp $icpp)
#if ($icpp.equals("NO"))
DSN=&&LOADSET#else
DSN=&&PLKSET#end#end
## Macro to get the DSNHCPP2 LKED COND CARD
## $icpp2 is the CPP LE prelinker phase
#macro(getLkedCondCpp2 $icpp2)
#if ($icpp2.equals("YES"))
COND=(4,LT,PLKED)#else
COND=((4,LT,CP1),(4,LT,CP2))#end#end
## Macro to get the DSNHCPP2 LKED sysin dataset
## $icpp2 is the CPP LE prelinker phase
#macro(getLkedSetCpp2 $icpp2)
#if ($icpp2.equals("NO"))
//SYSLIN   DD  DSN=&&LOADSET1,DISP=(OLD,DELETE)
//         DD  DSN=&&LOADSET2,DISP=(OLD,DELETE)#else
//SYSLIN   DD  DSN=&&PLKSET,DISP=(OLD,DELETE)#end#end
## Macro to get the COBOL LE prelinker library
## $icob is the COBOL LE prelinker library
#macro(getPlked $icob)
#if ($icob.equals("NO"))
#else
,(4,LT,PLKED)#end#end
## Macro to get the DSNHICOB COND CARD
## $icob is the COBOL LE prelinker library
#macro(getPlkCond $icob)
#if ($icob.equals("YES"))
COND=((4,LT,PC),(4,LT,COB),(4,LT,PLKED))#else
COND=((4,LT,PC),(4,LT,COB))#end#end
## Macro to get the COBOL LE prelinker dataset
## $icob is the COBOL LE prelinker library
#macro(getPlkset $icob)
#if ($icob.equals("NO"))
DSN=&&LOADSET#else
DSN=&&PLKSET#end#end
## Macro to get the DSNHPLI LKED COND CARD
## $ipli is the PL/I LE prelinker phase
#macro(getLkedCondPli $ipli)
#if ($ipli.equals("YES"))
COND=((8,LT,PPLI),(4,LT,PC),(8,LT,PLI),(4,LT,PLKED))#else
COND=((8,LT,PPLI),(4,LT,PC),(8,LT,PLI))#end#end
## Macro to get the DSNHPLI LKED sysin dataset
## $ipli is the PL/I LE prelinker phase
#macro(getLkedSetPli $ipli)
#if ($ipli.equals("NO"))
DSN=&&LOADSET#else
DSN=&&PLKSET#end#end
## Macro to get the DSNHSQL LKED COND CARD
## $ic is the C LE prelinker phase
#macro(getLkedCondSql $ic)
#if ($ic.equals("YES"))
COND=((4,LT,PC),(4,LT,PCC),(4,LT,C),(4,LT,PLKED))#else
COND=((4,LT,PC),(4,LT,PCC),(4,LT,C))#end#end
## Macro to get the DSNHSQL LKED sysin dataset
## $ic is the C LE prelinker phase
#macro(getLkedSetSql $ic)
#if ($ic.equals("NO"))
DSN=&&LOADSET#else
DSN=&&PLKSET#end#end
## Macro to get the DD statement for IMS reslib
## $lib is the input IMS reslib
## $default is the default reslib if the input is blank
#macro(getDD $lib $default)
#if ($lib != "")
         DD DISP=SHR,DSN=${lib}#else
*        DD DISP=SHR,DSN=${default}#end#end
## Macro to get the SYSLIB DD statement
## $lib is the input library
## $default is the default syslib if the input is blank
#macro(getDDSyslib $lib $default)
#if ($lib != "")
//SYSLIB   DD DISP=SHR,DSN=${lib}#else
//*        DD DISP=SHR,DSN=${default}#end#end
## Macro to get the UNIT parameter of a DD statement.
## $device is the device type.
## $pad is the string to be padded on the left.
#macro(unitl $devtype $pad)
#if($devtype != "")${pad}UNIT=${devtype}#else#end
#end
## Macro to append suffix for data sets
## $suffix is the data set suffix
## return the suffix with the right period
#macro (libs $suffix)
#if ($suffix !=  "")
.$suffix#else#end#end
