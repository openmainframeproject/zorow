//*********************************************************************/
//* JOB NAME = DSNTIJVC                                               */
//*                                                                   */
//* DESCRIPTIVE NAME = INSTALLATION JOB STREAM                        */
//*                                                                   */
//*    Licensed Materials - Property of IBM                           */
//*    5605-DB2                                                       */
//*    (C) COPYRIGHT 1982, 2010 IBM Corp.  All Rights Reserved.       */
//*                                                                   */
//*    STATUS = Version 10                                            */
//*                                                                   */
//* FUNCTION =                                                        */
//*   MERGES EDITED CLISTS WITH ALL OTHER CLISTS INTO ONE LIBRARY     */
//*   CONVERTS CLISTS TO VARIABLE BLOCK FORMAT                        */
//*                                                                   */
//* NOTES =                                                           */
//*   FOR FIXED BLOCK OUTPUT, DO THE FOLLOWING:                       */
//*   1.  CHANGE THE SYSIN DD STATEMENT TO //SYSIN DD DUMMY           */
//*   2.  CHANGE THE DCB ON THE DSNTIVB.SYSUT2 DD STATEMENT           */
//*                                                                   */
//* PSEUDOCODE =                                                      */
//*   DSNTIVB  PROC      INVOKE IEBGENER TO COPY/CONVERT CLIST        */
//*   DSNTIV.  STEPS     COPY OR CONVERT CLISTS                       */
//*                                                                   */
//*********************************************************************/
//DSNTIVB PROC CLIST=
//* ***************************************************************** */
//* CONVERT CLISTS TO VARIABLE RECORD FORMAT                          */
//* ***************************************************************** */
//DSNTIVB EXEC PGM=IEBGENER
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSUT1 DD DISP=SHR,
//       DSN=${DSNCLIST}(&CLIST)
//SYSUT2 DD DISP=SHR,
//       DSN=${OUTCL}(&CLIST)
//SYSIN  DD DISP=SHR,
//       DSN=${DSNSAMP}(DSNTIDVB)
//*  CONTENTS OF ${DSNSAMP}(DSNTIDVB)
//*    GENERATE MAXFLDS=2
//*    RECORD   FIELD=(8,73,,1),FIELD=(72,1,,9)
//DSNTIVB PEND
//DSNTIV1 EXEC DSNTIVB,CLIST=DSNH     PRECOMPILE
//DSNTIVB.SYSUT1 DD DATA,DLM='++'
  PROC 0  +
     ACQUIRE(USE) +
     ACTION(REPLACE) +
     ASMLIB('''${MACLIB}''') +
     ASMLOAD('''#getLib("${ASMLIB}","SYS1.LINKLIB")(ASMA90)''') +
     BDBRMLIB(DEFAULT) +
     BIND(YES) +
     BLIB(NONE) +
     BMEM(NONE) +
     BDMEM(DEFAULT) +
     B2LIB(NONE) +
     B3LIB(NONE) +
     B4LIB(NONE) +
     B5LIB(NONE) +
     B6LIB(NONE) +
     B7LIB(NONE) +
     B8LIB(NONE) +
     CACHESIZE(NONE) +
     CCSID(DEFAULT) +
     CICS(NONE) +
     CICSOPT(NONE) +
     CICSPRE() +
     CICSLLIB('#getLib("${CICSMOD}","CICSTS.SDFHLOAD")') +
     CICSPLIB('''#getLib("${CICSPLI}","CICSTS.SDFHPL1")''') +
     CICSCLIB('''#getLib("${CICSCOB}","CICSTS.SDFHCOB")''') +
     CICSVER(53) +
     CICSXLAT(YES) +
     CLIB(NONE) +
     CCOLIB(NONE) +
     CCLLIB('''#getLib("${LELKED}","CEE.V!R!M!.SCEELKED")''') +
     CCLINK('''#getLerun("${LERUN}")(EDCPRLK)''') +
     CCLOAD('''#getCcload("${CCOMP}","${CPROG}")''') +
     CCMSGS('''#getLib("${CMSGS}","EDC.V!R!M!.SEDCDMSG")(EDCMSGE)''') +
     CCPLIB(NONE) +
     CCPMSGS('''#getLeplmsgl("${LEPLMSGL}")(EDCPMSGE)''') +
     CCSLIB('''#getLib("${CHDRS}","CEE.V!R!M!.SCEEH.H")''') +
     COBICOMP('''#getIcobcomp("${ICOBCOMP}")(IGYCRCTL)''') +
     COBILINK('''#getLib("${LELKED}","CEE.V!R!M!.SCEELKED")''') +
     COBIPLNK('''#getLerun("${LERUN}")(EDCPRLK)''') +
     COBIPMSG('''#getLeplmsgl("${LEPLMSGL}")(EDCPMSGE)''') +
     COBLIB('''SYS1.COBLIB''') +
     COBLOAD('''SYS1.LINKLIB(IKFCBL00)''') +
     COB2CICS('''SYS1.COB2CICS''') +
     COB2LIB('''SYS1.V1R3.COB2LIB''') +
     COB2LOAD('''SYS1.V1R3.COB2COMP(IGYCRCTL)''') +
     COMPILE(YES) +
     CONNECT() +
     CONTROL(NONE) +
     COPTION(NONE) +
     COPY(NONE) +
     COPYOPTS(NONE)                                        /* PQ03427*/+
     COPYVER()     +
     CPPCLASS('''#getLib("${CPPCLASS}","CBC.SCLBCPP")''') +
     CPPCLINK('''#getLerun("${LERUN}")(EDCPRLK)''') +
     CPPCLLIB('''#getLib("${LELKED}","CEE.V!R!M!.SCEELKED")''') +
     CPPUTIL('''#getLib("${CPPPROC}","CBC.SCCNUTL")(CXX)''') +
     CPPCSLIB('''#getLib("${CHDRS}","CEE.V!R!M!.SCEEH.H")''') +
     CPPLLIB('''#getLeplmsgl("${CPPAUTCL}")''') +
     CPPPMSGS('''#getLeplmsgl("${LEPLMSGL}")(EDCPMSGE)''') +
     CPPSLIB('''#getLib("${CPPHDRS}","CBC.SCLBH.H")''') +
     C2LIB(NONE) +
     C3LIB(NONE) +
     C4LIB(NONE) +
     CURRENTDATA(NO) +
     CURRENTSERVER(NONE) +
     DATE(NONE) +
     DBPROTOCOL(NONE)                                       /*  LI350*/+
     DBRMLIB(DEFAULT) +
     DECARTH(DEFAULT) +
     DECIMAL(${DECPOINT}) +
     DEFER(NONE) +
     DEGREE(1) +
     DISCONNECT(EXPLICIT) +
     DLIBATCH(NONE) +
     DYNAMICRULES(RUN) +
     NODEFER(NONE) +
     DELIMIT(#getLib("${DEFSTRNG}","DEFAULT")) +
     DISABLE(NONE) +
     ENABLE(NONE) +
     ENTRY(DEFAULT) +
     EXPLAIN(NO) +
     FLAG(I) +
     FLOAT(S390)                                                /*@06*/+
     FORTLIB('''#getLib("${FORTLINK}","SYS1.VSF2FORT")''') +
     FORTLOAD('''#getLib("${FORTCOMP}","SYS1.VSF2COMP")(FORTVS2)''') +
     GRAPHIC(NONE) +
     HOST(${DEFLANG}) +
     INPUT(NONE) +
     IMSBMP(NONE) +
     IMSMPP(NONE) +
     IMSPRE(#getImsPre(${RESLIB})) +
     ISOLATION(CS) +
     KEEPDYNAMIC(NO)                                        /*  D9028*/+
     LINECOUNT(60) +
     LINK(YES) +
     LLIB(NONE) +
     LOAD(RUNLIB.LOAD) +
     LOPTION(NONE) +
     L2LIB(NONE) +
     L3LIB(NONE) +
     L4LIB(NONE) +
     MACRO(YES) +
     NEWFUN(DEFAULT) +
     NOFOR(NO) +
     OPTIONS(NO) +
     OUTNAME(TEMP) +
     OWNER(NONE) +
     PACKAGE(DEFAULT) +
     PACTION(REPLACE) +
     PARMS(NONE) +
     PASS(DEFAULT) +
     PATH(NONE)                                             /*  LI333*/+
     PBIND(NO) +
     PCICS(NONE) +
     PCLOAD('*(DSNHPC)')                                      /*DG374*/+
     PCURRENTDATA(NONE) +
     PDBPROTOCOL(NONE)                                      /*  LI350*/+
     PDBRMLIB(DEFAULT) +
     PDEFER(NONE)                                          /* KFD0005*/+
     PDEGREE(NONE) +
     PDISABLE(NONE) +
     PDLIBATCH(NONE) +
     PDMEM(DEFAULT) +
     PKEEPDYNAMIC(NONE)                                     /*PQ20086*/+
     PDYNAMICRULES(NONE) +
     PENABLE(NONE) +
     PEXPLAIN(NONE) +
     PFLAG(I) +
     PISOLATION(NONE) +
     PIMSBMP(NONE) +
     PIMSMPP(NONE) +
     PKLIST(NONE) +
     PLAN(DEFAULT) +
     PLIB(NONE) +
     PLILIB('''#getLib("${LELKED}","SYS1.PLIBASE")''') +
     PLI2LIB(NONE) +
     PLILOAD('''#getLib("${PLICOMP}","SYS1.LINKLIB")(IBMZPLI)''') +
     PLIPLNK('''#getLib("${LERUN}","CEE.V!R!M!.SCEERUN")(EDCPRLK)''') +
     PLIPMSG('''#getLeplmsgl("${LEPLMSGL}")(EDCPMSGE)''') +
     PNODEFER(NONE)                                        /* KFD0005*/+
     POPTION(NONE) +
     POWNER(NONE) +
     PPATH(NONE)                                            /*  LI333*/+
     PQUALIFIER(NONE) +
     POPTHINT()                                             /*  LI375*/+
     PENCODING(NONE)                                            /*@10*/+
     PIMMEDWRITE(NONE)                                          /*@10*/+
     PAPREUSE(NONE)                                             /*@10*/+
     PAPCOMPARE(NONE)                                           /*@10*/+
     PSYSTIMESENSITIVE()                                        /*@10*/+
     PBUSTIMESENSITIVE()                                        /*@10*/+
     PARCHIVESENSITIVE()                                        /*@10*/+
     PAPPLCOMPAT()                                              /*@10*/+
     PRECOMP(YES) +
     PRELEASE(NONE) +
     PRELINK(YES) +
     PRINT(NONE) +
     PREOPT(NONE)                                          /* KFD0005*/+
     PSECSPAC(20) +
     PSPACE(20) +
     P2LIB(NONE) +
     P3LIB(NONE) +
     P4LIB(NONE) +
     PVALIDATE(NONE) +
     QUALIFIER(NONE) +
     OPTHINT()                                              /*  LI375*/+
     ENCODING(NONE)                                             /*@10*/+
     IMMEDWRITE(NONE)                                           /*@10*/+
     PROGAUTH(NONE)                                             /*@09*/+
     RCTERM(8) +
     RELEASE(COMMIT) +
     REPLVER() +
     RETAIN(NO) +
     RUN(YES) +
     RUNIN(TERM) +
     RUNOUT(TERM) +
     REMOTE(NONE) +
     REOPT(NONE)                                           /* KFD0005*/+
     SOMDLLI() +
     SOURCE(NO) +
     SPACEUN(TRACK) +
     SQLDELIM(${DEFSQSTR}) +
     SQL(DEFAULT) +
     SQLERROR(NONE) +
     SQLRULES(DB2) +
     STDSQL(${DEFSQLVL}) +
     SUFFIX(YES) +
     SYSTEM(${GRPATTNM}) +
     TERM(TERM) +
     TIME(NONE) +
     VALIDATE(RUN) +
     VERSION()     +
     WORKUNIT(DEFAULT) +
     WSECSPAC(20) +
     WSPACE(20) +
     XREF(NO) +
     XLIB('''${DSNLOAD}''')
  /*******************************************************************/
  /* MODULE NAME = DSNH                                              */
  /* DESCRIPTIVE NAME = PRECOMPILER INVOCATION                       */
  /*   Licensed Materials - Property of IBM                          */
  /*   5650-DB2                                                      */
  /*   (C) COPYRIGHT 1982, 2016 IBM Corp.  All Rights Reserved.      */
  /*                                                                 */
  /*   STATUS = Version 12                                           */
  /* FUNCTION     = THE DSNH CLIST PERFORMS                          */
  /*                A PRECOMPILE, COMPILE, LINKEDIT, BIND,           */
  /*                AND RUN WITH A SINGLE LINE OF INPUT.             */
  /* NOTES =                                                         */
  /* DEPENDENCIES = DSNHC CLIST FOR COMPILATION                      */
  /* RESTRICTIONS = 1) THE OUTNAME PARAMETER IS USED TO              */
  /*                   GENERATE SEVERAL DATA SET NAMES,              */
  /*                   SO IT MUST NOT CONTAIN SPECIAL                */
  /*                   CHARACTERS.                                   */
  /*                2) THE OUTNAME PARAMETER CANNOT BE               */
  /*                   THE SAME AS THE INPUT NAME, SINCE             */
  /*                   THE PRECOMPILER OUTPUT HAS THE                */
  /*                   SAME SUFFIX AS ITS INPUT.                     */
  /*                   THE OUTNAME IS NOT ALLOWED TO                 */
  /*                   MATCH THE INPUT PARAMETER.                    */
  /*                3) NONE IS A RESERVED NAME FOR INPUT,            */
  /*                   CLIB, LLIB, AND PLIB PARAMETERS,              */
  /*                   INCLUDING C2LIB, C3LIB, C4LIB,                */
  /*                   L2LIB, L3LIB, L4LIB, P2LIB, P3LIB,            */
  /*                   AND P4LIB EXTENSIONS.                         */
  /*                   NONE IS A RESERVED NAME FOR PARMS.            */
  /*                   DEFAULT IS RESERVED FOR PLAN AND              */
  /*                   DBRMLIB.                                      */
  /*                4) THE BUF AND SIZE PARAMETERS                   */
  /*                   PASSED TO THE COBOL COMPILER,                 */
  /*                   MAY NEED TO BE CHANGED.                       */
  /*                5) THE PRINT PARAMETER IS USED TO                */
  /*                   GENERATE SEVERAL DATA SET NAMES,              */
  /*                   SO IT MUST NOT CONTAIN SPECIAL                */
  /*                   CHARACTERS.                                   */
  /*                                                                 */
  /* MODULE TYPE = CLIST OR TSO COMMAND PROCEDURE                    */
  /*                                                                 */
  /* ENTRY POINT = DSNH                                              */
  /*    PURPOSE      = THE DSNH CLIST ALLOWS ONE TO REQUEST          */
  /*                   A PRECOMPILE, COMPILE, PRE-LINKEDIT,          */
  /*                   LINKEDIT, BIND, AND RUN.                      */
  /*    LINKAGE      = INVOCATION FROM TSO OR BATCH TMP              */
  /*    INPUT        = PARAMETERS PASSED ON STATEMENT                */
  /*                      DEFINED IN PROC STATEMENT                  */
  /*                   INPUT SOURCE DATA SET                         */
  /*                   OPTIONAL INPUT LIBRARIES                      */
  /*    OUTPUT       = HOST LANGUAGE WITH GENERATED STMTS            */
  /*                   DBRM DATA SET                                 */
  /*                   PRINT ON TERMINAL/DATA SET                    */
  /*                   OBJECT, LOAD MODULES                          */
  /*                   PLAN SET BY BIND                              */
  /*                                                                 */
  /*-----------------------------------------------------------------*/
  /*                                                                 */
  /*   EXIT                                                          */
  /* EXIT-NORMAL = REQUESTED FUNCTIONS PERFORMED                     */
  /* EXIT-ERROR  = RETURN CODES PASSED FROM PROCESSORS               */
  /*                                                                 */
  /*    RETURN CODE  = SEE PRECOMPILER, COMPILER, LINKEDIT,          */
  /*                   DSN, BIND, AND RUN RETURN CODES.              */
  /*    ABEND CODES  = THIS CLIST ISSUES NO ABENDS, BUT              */
  /*                   INVOKED FUNCTIONS MAY ABEND, CAUSING          */
  /*                   ABEND MESSAGES.                               */
  /*                                                                 */
  /*-----------------------------------------------------------------*/
  /*                                                                 */
  /*    MESSAGES                                                     */
  /*    ERROR MESSAGES =                                             */
  /*                 = DSNH740I ==== PHASE FINISHED, RC =            */
  /*                            RETCODE ==== LISTING IN DSN          */
  /*                 = DSNH741I &PROCESS1(NO) IMPLIES THAT           */
  /*                            &PROCESS2 CANNOT BE RUN              */
  /*                 = DSNH750I INVALID DATA SET NAME &INPUT         */
  /*                 = DSNH751I DSNH ERROR IN &KEYWORD               */
  /*                            VALUE &VAL                           */
  /*                 = DSNH752I INPUT DATA SET NAME IS               */
  /*                            MISSING OR NONE                      */
  /*                 = DSNH753I ENTER INPUT DATA SET NAME            */
  /*                 = DSNH754I DSNH OUTNAME PARAMETER               */
  /*                            &OUTNAME MUST NOT                    */
  /*                            CONTAIN SPECIAL CHARACTERS           */
  /*                 = DSNH755I OUTNAME PARAMETER                    */
  /*                            &OUTNAME MUST NOT                    */
  /*                            = INPUT &INPUT                       */
  /*                 = DSNH756I DSNH PRINT PARAMETER                 */
  /*                            &PRINT MUST NOT CONTAIN              */
  /*                            SPECIAL CHARACTERS                   */
  /*                 = DSNH757I ERROR IN PLAN NAME LENGTH            */
  /*                            &PLAN                                */
  /*                 = DSNH758I HOST(&HOST) IS NOT                   */
  /*                            PERMITTED WITH RUN(IMS)              */
  /*                            OR RUN(CICS)                         */
  /*                 = DSNH759I DSNH TERMINATING, &PROCESS           */
  /*                            RC = &ERROR                          */
  /*                 = DSNH760I PRELINK OPTION INVALID WITH          */
  /*                            HOST(&HOST)                          */
  /*    ATTENTION HANDLING = NONE, TO ALLOW INVOKED FUNC-            */
  /*                         TIONS TO HANDLE ATTENTIONS.             */
  /*                                                                 */
  /*-----------------------------------------------------------------*/
  /*                                                                 */
  /* EXTERNAL REFERENCES =                                           */
  /*    ROUTINES/SERVICES =                                          */
  /*       ALLOCATE  = TSO ALLOCATION COMMAND                        */
  /*       ATTRIB    = TSO ALLOCATION COMMAND                        */
  /*       BIND      = DB2 BIND COMMAND                              */
  /*       CALL      = TSO PROGRAM INVOCATION                        */
  /*       DELETE    = TSO DATA SET DELETION                         */
  /*       DSN       = DB2 TSO/BATCH SERVICES                        */
  /*       DSNHC     = DB2 COMPILE CLIST                             */
  /*       DSNHPC    = DB2 PRECOMPILER                               */
  /*       FREE      = TSO UNALLOCATION COMMAND                      */
  /*       PRELINK   = PRE-LINKEDIT PROMPTER  (C COMPILER)           */
  /*       LINK      = LINKEDIT PROMPTER                             */
  /*       RUN       = DB2 PROGRAM INVOCATION                        */
  /*                                                                 */
  /*-----------------------------------------------------------------*/
  /*                                                                 */
  /*    DDNAMES AND ATTRIBUTES                                       */
  /*                                                                 */
  /*       OPTIONAL  = DBRMLIB  FOR PRECOMPILER OUTPUT               */
  /*                 = DSNHFBA  ATTRIBUTE FOR OUTPUT PRINT           */
  /*                 = DSNHFB   ATTRIBUTE FOR OUTPUT PRINT           */
  /*                 = DSNHVBA  ATTRIBUTE FOR OUTPUT PRINT           */
  /*                 = DSNHF133 ATTRIBUTE FOR OUTPUT PRINT           */
  /*                 = DSNHF80  ATTRIBUTE FOR OUTPUT                 */
  /*                 = DSNHOBJ  FOR LKED INPUT, INCLUDED             */
  /*                 = DSNHINCL FOR LKED INCLUDE FILE                */
  /*                 = INCLIB   FOR LKED INCLUDES                    */
  /*                 = SYSCIN   FOR PRECOMPILER OUTPUT               */
  /*                 = SYSIN    FOR PRECOMPILER INPUT                */
  /*                 =          FOR RUN TIME INPUT                   */
  /*                 =          FOR PRE-LINKEDIT INPUT               */
  /*                 = SYSMOD   FOR PRE-LINKEDIT OUTPUT              */
  /*                 = SYSLIB   FOR PRECOMPILER INCLUDES             */
  /*                 =          C COMPILER HEADERS                   */
  /*                 =          C++ COMPILER HEADER CLASS       LI319*/
  /*                 =          C PRE-LINKEDIT INCLUDES              */
  /*                 = SYSMSGS  C++ COMPILER MESSAGES           LI319*/
  /*                 = SYSXMSGS C++ COMPILER MESSAGES           LI319*/
  /*                 = SYSLIN   FOR COMPILER OUTPUT                  */
  /*                 = SYSOUT   C/C++ PRE-LINKEDIT WORK FILE    LI319*/
  /*                 =          C++ COMPILER SYSOUT             LI319*/
  /*                 = SYSPRINT FOR PRECOMPILER LISTINGS             */
  /*                 =          FOR RUN TIME PRINT OUTPUT            */
  /*                 = SYSTERM  FOR PRECOMPILER ERROR MSGS           */
  /*                 = SYSUT1   FOR PRECOMPILER WORK FILE            */
  /*                 = SYSUT2   FOR PRECOMPILER WORK FILE            */
  /*                 = ALLOCATED BY INVOKED PROCESSES                */
  /*                                                                 */
  /*-----------------------------------------------------------------*/
  /*                                                                 */
  /*    DATA SETS                                                    */
  /*                                                                 */
  /*       REQUIRED  = INPUT, USER SPECIFIED NAME, SOURCE            */
  /*                       HOST AND SQL LANGUAGE INPUT TO            */
  /*                       PRECOMPILER/COMPILER, SHR.                */
  /*       OPTIONAL  = ASMLIB, ASSEMBLY LIBRARY FOR HIGH LEVEL ASM   */
  /*                 = ASMLOAD, ASSEMBLER PROGRAM LOAD               */
  /*                       MODULE.                                   */
  /*                 = BLIB, USER SPECIFIED NAME, BIND               */
  /*                       LIBRARY FOR DBRMS, SHR.                   */
  /*                       ALSO B2LIB, B3LIB, B4LIB, B5LIB           */
  /*                       B6LIB, B7LIB, B8LIB.                      */
  /*                 = CLIB, USER SPECIFIED NAME, COMPILER           */
  /*                       SOURCE LIBRARY FOR INCLUDES, SHR.         */
  /*                       ALSO C2LIB, C3LIB, C4LIB.                 */
  /*                 = CICSPRE.LOADLIB, CICSPRE.SDFHLOAD (3.2 AND UP)*/
  /*                       CICS/OS/VS COMMAND                        */
  /*                       TRANSLATOR PROGRAM LOAD MODULE            */
  /*                       AND LINK EDIT INCLUDE LIBRARY.            */
  /*                 = CICSPRE.PL1LIB, CICSPRE.SDFHPL1 (3.2 AND UP)  */
  /*                       CICS/OS/VS COMPILER SOURCE                */
  /*                       INCLUDE LIBRARY FOR PL/I PROGS.           */
  /*                 = CICSPRE.COBLIB, CICSPRE.SDFHCOB (3.2 AND UP)  */
  /*                       CICS/OS/VS COMPILER SOURCE                */
  /*                       INCLUDE LIBRARY FOR COBOL PROGS.          */
  /*                 = CCOLIB, C PRELINK INCLUDE LIB       (SYSLIB)  */
  /*                 = CCLLIB, C PROGRAM LINKAGE EDITOR    (SYSLIB)  */
  /*                       LIBRARY FOR INCLUDES    SHR               */
  /*                 = CCPLIB, C PROGRAM LINKAGE EDITOR    (SYSLIB)  */
  /*                       LIBRARY FOR INCLUDES    SHR               */
  /*                       ONLY FOR C/370 VERSION 2 AND EARLIER LI319*/
  /*                 = CCLINK, COMPILER PRELINK UTILITY    (EXECUTE) */
  /*                       PRE-LINKEDIT LOAD MODULE NAME             */
  /*                 = CCLOAD, C COMPILER PROGRAM          (EXECUTE) */
  /*                       LOAD MODULE NAME.    SHR.                 */
  /*                 = CCMSGS, C/C++ COMPILER MESSAGES (SYSMSGS)     */
  /*                           C PRE-LINKEDIT FOR IBM C              */
  /*                 = CCPMSGS,C COMPILER PRELINK MSGS SHR (SYSMSG)  */
  /*                 = CCSLIB, C COMPILER HEADERS   SHR.   (SYSLIB)  */
  /*                 = COBICOMP, OOCOBOL COMPILER     (EXECUTE) LI319*/
  /*                       LOAD MODULE NAME.    SHR.            LI319*/
  /*                 = COBILINK, OOCOBOL LINKEDIT     (SYSLIB)  LI319*/
  /*                 = COBIPLNK, OOCOBOL PRE-LINKEDIT (EXECUTE) LI319*/
  /*                       LOAD MODULE NAME.    SHR.            LI319*/
  /*                 = COBICOMP, OOCOBOL COMPILER     (EXECUTE) LI319*/
  /*                       LOAD MODULE NAME.    SHR.            LI319*/
  /*                 = COBIPMSG, OOCOBOL PRE-LINKEDIT (SYSMSGS) LI319*/
  /*                 = COBLIB, LINK EDIT INCLUDE LIBRARY             */
  /*                       FOR VS COBOL PROGRAMS.                    */
  /*                 = COBLOAD, VS COBOL COMPILER PROGRAM            */
  /*                       LOAD MODULE.                              */
  /*                 = COB2LIB, LINK EDIT INCLUDE LIBRARY            */
  /*                       FOR VS COBOL II PROGRAMS.                 */
  /*                 = COB2LOAD, VS COBOL II COMPILER                */
  /*                       PROGRAM LOAD MODULE.                      */
  /*                 = CPPCLASS, C++ PRE-LINKEDIT     (SYSLIB)  LI319*/
  /*                 = CPPCLINK, C++ PRE-LINKEDIT     (EXECUTE) LI319*/
  /*                       LOAD MODULE NAME.    SHR.            LI319*/
  /*                 = CPPCLLIB, C++ LINKEDIT         (SYSLIB)  LI319*/
  /*                 = CPPUTIL, C++ COMPILER REXX    (SYSPROC)  LI319*/
  /*                 = CPPCSLIB, C++ COMPILER HEADERS (SYSLIB)  LI319*/
  /*                 = CPPLLIB, C++ PRE-LINKEDIT      (SYSLIB)  LI319*/
  /*                       LOAD MODULE NAME.    SHR.            LI319*/
  /*                 = CPPPMSGS, C++ PRE-LINKEDIT     (SYSMSGS) LI319*/
  /*                 = CPPSLIB, C++ COMPILER HEADER   (SYSLIB)  LI319*/
  /*                 = DBRMLIB, DEFAULT IS OUTNAME.DBRM,             */
  /*                       OUTPUT FROM PRECOMPILER CONTAINS          */
  /*                       SQL STATEMENTS, INPUT TO BIND,            */
  /*                       OLD IF SUPPLIED, NEW IF DEFAULT.          */
  /*                 = PDBRMLIB, DEFAULT IS OUTNAME.DBRM,            */
  /*                       OUTPUT FROM PRECOMPILER CONTAINS          */
  /*                       SQL STATEMENTS, INPUT TO BIND,            */
  /*                       OLD IF SUPPLIED, NEW IF DEFAULT.          */
  /*                 = FORTLIB, LINK EDIT INCLUDE LIBRARY            */
  /*                       FOR VS FORTRAN PROGRAMS.                  */
  /*                 = FORTLOAD, VS FORTRAN COMPILER                 */
  /*                       PROGRAM LOAD MODULE.                      */
  /*                 = IMSPRE.RESLIB, IMS/VS LINK EDIT               */
  /*                       INCLUDE LIBRARY.                          */
  /*                 = LLIB, USER SPECIFIED NAME, LINKEDIT           */
  /*                       LIBRARY INPUT, SHR.                       */
  /*                       ALSO L2LIB, L3LIB, L4LIB.                 */
  /*                 = LOAD, DEFAULT IS RUNLIB.LOAD, MODULE          */
  /*                       OUTPUT FROM LINKAGE EDITOR,               */
  /*                       PROGRAM LIBRARY FOR RUN, OLD/NEW.         */
  /*                       DATA SET IS REQUIRED IF LINKEDIT          */
  /*                       IS EXECUTED.                              */
  /*                 = OUTNAME.CICSIN, OUTPUT FROM PRECOMP-          */
  /*                       ILER AND INPUT TO CICS TRANSLATOR         */
  /*                 = OUTNAME.DATA, INPUT TO LINKEDIT,              */
  /*                       GENERATED IN THIS CLIST. NEW.             */
  /*                       INCLUDE STATEMENT.                        */
  /*                 = OUTNAME.DECK, OUTPUT FROM COMPILER            */
  /*                       MACRO PASS AND INPUT TO                   */
  /*                       PRECOMPILER (PLI ONLY).                   */
  /*                 = OUTNAME.SUFFIX, DEFAULT IS TEMP.COBOL         */
  /*                       HOST LANGUAGE OUTPUT FROM PRECOMPILER     */
  /*                       OR CICS COMMAND TRANSLATOR.               */
  /*                       INPUT TO COMPILER. NEW                    */
  /*                       SUFFIX IS ASM FOR HIGH LEVEL ASSEMBLER.   */
  /*                       SUFFIX IS PLI FOR PLI.                    */
  /*                       SUFFIX IS COBOL FOR COB2, COBOL.          */
  /*                       SUFFIX IS FORTRAN FOR FORTRAN.            */
  /*                 = OUTNAME.OBJ, OUTPUT FROM COMPILER,            */
  /*                       INPUT TO LINKAGE EDITOR.   OLD/NEW        */
  /*                       INPUT TO 'C' PRE-LINKEDIT. OLD/NEW        */
  /*                 = OUTNAME.PLK, OUTPUT FROM 'C' PRE-LINKEDIT     */
  /*                       INPUT TO LINKAGE EDITOR. OLD/NEW          */
  /*                 = PCLOAD, DEFAULT '*(DSNHPC)'             @DG374*/
  /*                       LOAD MODULE FOR PRECOMPILER, SHR.         */
  /*                 = PLIB, USER SPECIFIED NAME, PRECOMPILE         */
  /*                       LIBRARY INPUT, SHR.                       */
  /*                       ALSO P2LIB, P3LIB, P4LIB.                 */
  /*                 = PLILIB, LINK EDIT INCLUDE LIBRARY             */
  /*                       FOR PL/I OPTIMIZER PROGRAMS.              */
  /*                 = PLILOAD, PL/I OPTIMIZING COMPILER             */
  /*                       PROGRAM LOAD MODULE.                      */
  /*                 = PLIPLNK, PL/I PRE-LINKEDIT (EXECUTE)       @02*/
  /*                       LOAD MODULE NAME.                      @02*/
  /*                 = PLIPMSG, PL/I PRE-LINKEDIT (SYSMSGS)       @02*/
  /*                 = PRINT.CXLIST, SYSPRINT OF CICS XLATE          */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       LEAVE (PREALLOCATED) OR                   */
  /*                       DATA SET NAME ABOVE. NEW.                 */
  /*                 = PRINT.PRELLIST, SYSPRINT OF PRE-LINKEDIT      */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       DATA SET NAME ABOVE. OLD/NEW              */
  /*                 = PRINT.SYSOUT.PRELLIST, 'C' PRE-LINKEDIT       */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       DATA SET NAME ABOVE. OLD/NEW              */
  /*                 = PRINT.LINKLIST, SYSPRINT OF LINKEDIT          */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       DATA SET NAME ABOVE. OLD/NEW              */
  /*                 = PRINT.LIST, SYSPRINT OF COMPILERS.            */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       DATA SET NAME ABOVE, OLD/NEW              */
  /*                 = PRINT.SYSCPRT.LIST, 'C/C++' COMPLIER     LI319*/
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       DATA SET NAME ABOVE. OLD/NEW              */
  /*                 = PRINT.PCLIST, SYSPRINT OF PRECOMPILE          */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       LEAVE (PREALLOCATED) OR                   */
  /*                       DATA SET NAME ABOVE, OLD/NEW              */
  /*                 = PRINT.CEEDUMP.RUN, 'C' RUN OUTPUT             */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       DATA SET NAME ABOVE. OLD/NEW              */
  /*                 = RUNIN, FT05F001 OR SYSIN OF RUN PHASE         */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       DATA SET NAME ABOVE, SHR                  */
  /*                 = RUNOUT, FT06F001 OR SYSPRINT OF RUN           */
  /*                       PHASE. DEFAULT IS NONE (NO PRINT)         */
  /*                       MAY BE TERM (TERMINAL) OR                 */
  /*                       LEAVE (PREALLOCATED) OR                   */
  /*                       DATA SET NAME ABOVE, OLD/NEW              */
  /*                 = SOMDLLI, SOM DLL IMPORT LIBRARY               */
  /*                 = TERM.PCTERM, SYSTERM, ERROR, SUMMARY          */
  /*                       OF PRECOMPILE.  DEFAULT IS TERM           */
  /*                       (TERMINAL OUTPUT), MAY ALSO BE            */
  /*                        LEAVE OR NONE.    OLD/NEW                */
  /*                 = TERM.LIST,   SYSTERM, ERROR, SUMMARY          */
  /*                       OF COMPILE.  DEFAULT IS TERM              */
  /*                       (TERMINAL OUTPUT), MAY ALSO BE            */
  /*                        LEAVE OR NONE.    OLD/NEW                */
  /*                 = XLIB, LINK EDIT INCLUDE LIBRARY               */
  /*                       FOR DB2 MODULES.                          */
  /*                                                                 */
  /*-----------------------------------------------------------------*/
  /*                                                                 */
  /* CHANGE ACTIVITY                                                 */
  /*                                                                 */
  /* - PERMIT AMODE=31 IN LOPTION                             KEZ0192*/
  /* - PLICALLA->PLISTART, PARM PASSING                       KCF0087*/
  /* - PLICALLA FOR IMS-PLI APPLICATIONS                     @BA00008*/
  /* - NEW RELEASE LEVELS                                     R3TU113*/
  /* - COB2 OPTION TO PRECOMPILER                             R3LI107*/
  /* - ADD ELSE FOR CONTROL INIT                     KCF0283/@BA02917*/
  /* - ADD DATE AND TIME PARMS                       KCF1044/KBW0045 */
  /* - ADD CICSOPT PRIMING FOR COB2                  KBF0026/KBF1091 */
  /* - ADD &WORKU FOR ALL TEMP DS           @BA04731/KBF0038/KCF1141 */
  /* - DROP ENTRY PLISTART FOR CICS/PLI.  FIX &DBRMLIB               */
  /*   TRUNCATION                           @BA04716/KBW0119/KCF1178 */
  /* - &DBRMLIB, &LOADIT REPAIR                      KBT0008/KCF1209 */
  /* - DB2 V2R1, APAR @BA08652                               R3TU103 */
  /* - FIX RETCODE LOGIC ON BIND AND RUN             PL11443/KCF1702 */
  /* - ADD OWNER PARAMETER FOR BIND SUPPORT OF LI117 PL11443/KCF1702 */
  /* - C LANGUAGE SUPPORT - INVOKE C COMPILER, ADD 'GRAPHIC' PARM,   */
  /*     ACCEPT HOST(C), ADD PARMS: CLOAD, CCLIB, CLLIB      R3TU157H*/
  /* 10/19/87 - PRINT.LINKLIST NOT ALLOCATED        R3TU157H/@BA18169*/
  /* 12/15/87 - ADD PARM CMSGS                               KCL2013 */
  /* 12/28/87 - CHANGE RELEASE LEVEL TO DSN220                KZL0014*/
  /* 05/14/88 - LINKEDIT LIBRARY NOT FREED AFTER USE KZF0840/@BA25449*/
  /* 06/02/88 - ADD SUPPORT FOR COB2CICS             KZF0917/@BA26814*/
  /* 08/11/88 - ERRORS WHEN INPUT IS SAME AS OUTPUT  KZF1023/@BA30168*/
  /* 10/25/88 - CHANGES TO C LANGUAGE SUPPORT                 KZF0283*/
  /*            ADD PRELINK KEYWORD                                  */
  /*            ADD DSNH760I MESSAGE                                 */
  /* 10/27/88 - SYSCPRT AND SYSOUT WALL MESSAGES AND DCBS     KZW0290*/
  /* 11/01/88 - FREE DDNAMES FOR ALLOCATION                   KZW0295*/
  /* 11/22/88 - REMOVE DUPLICATE DSNE758 MSGS                 KZW0324*/
  /*            CHANGE PL1DUMP TO CEEDUMP DD STATEMENT               */
  /* 01/11/89 - ADD DEFER/NODEFER PREPARE                   RZTU21207*/
  /* 02/11/89 - ADD SUPPORT FOR PACKAGE                     RZTU18901*/
  /* 02/22/89 - ADD STDSQL OPTION (J. LAWRENCE)               KZW2082*/
  /* 02/22/89 - ADD NOFOR OPTION (J. LAWRENCE)                KZW2082*/
  /* 03/23/89 - BIND CALLED AFTER DSNE940E ERROR              KYF0386*/
  /* 03/27/89 - ADD DECARTH KEYWORD DEC(15/31)          D6064/KYD0030*/
  /* 04/12/89 - XOPTION NOT USED BY CLIST            KYF0488/@BA41758*/
  /*            INCLUDES FIPS APAR: PL40711 (STDSQL)                 */
  /* 06/20/89 - ADD SUPPORT FOR CURRENTSERVER (BIND PLAN)   RZTU16301*/
  /*          - ADD SUPPORT FOR VERSION FOR THE PRECOMPILER RZTU19801*/
  /* 06/29/89 - CHANGE RELEASE LEVEL TO DSN220                KYL0416*/
  /*            FIX LI189 ERRORS                                     */
  /* 06/30/89 - SAVE USERS SYSPRINT, SYSIN, SYSTERM  KYL0416/@BA44366*/
  /* 07/12/89 - FIX LI189 ERRORS                              KYL0479*/
  /* 08/01/89 - FIX GRAPHIC KEYWORD SYNTAX                    KYW0181*/
  /*            ADD SQL(DB2,ALL)                                     */
  /* 08/21/89 - ADD PDEFER/PNODEFER TO BIND/REBIND PACKAGE    KYW0180*/
  /* 09/01/89 - ADD SQLERROR (NOPACKAGE/CONTINUE)       D6135/KYF0893*/
  /* 10/10/89 - CLIST ERROR DURING DSNH755I TESTING  KYF0893/@BA49303*/
  /* 10/11/89 - ADD DSNH750I FOR INVALID DSNAME      KYF0893/@BA49887*/
  /* 11/16/89 - FIX DOWNLEVEL (KYD0030 AND KYF0488)           KYW0636*/
  /* 12/04/89 - USE &NRSTR WITH VERSION KEYWORD               KYW0647*/
  /*            BLANK ;.() ARE INVALID WITH VERSION                  */
  /* 04/24/90 - USE &NRSTR WITH CURRENTSERVER, OWNER, PLAN,   KYW0858*/
  /*            DBRM MEMBER NAME                                     */
  /*          - REMOVE PCACHESIZE KEYWORD, VALID ONLY WITH PLAN      */
  /*          - PDMEM SETS MEMBER(DEFAULT) ON PDMEM(DEFAULT)         */
  /*            BDMEM SETS MEMBER(DEFAULT) WHEN DBRMLIB(NONE)        */
  /* 05/11/90 - REMOVE WRITES FROM FUNCTIONS                  KYP0013*/
  /* 10/11/90 - SUPPORT CAF/APPC HLL                    LI239/TU2390A*/
  /* 10/16/90 - REMOVE (SAME) FROM REPLVER              D6328/KYD0288*/
  /* 10/30/90 - CICS NOW SUPPORTS C/370 LANGUAGE        D6197/TU2390A*/
  /* 01/24/91 - UPDATE FORTLIB, FORTLOAD TO V2R5 LEVEL  D6385/KYD0319*/
  /* 03/05/91 - FIX &RUN PARM. REMOVE ATTACH FROM DSNHC.      KYL1174*/
  /*            UPDATE FORTLIB, FORTLOAD TO V2R5 LEVEL        KYD0339*/
  /* 03/07/91 - REMOVE PRETAIN FROM BIND PACKAGE        D6395/KYD0337*/
  /* 03/12/91 - ENABLE/DISABLE MUTUALLY EXCLUSIVE       D6342/KYD0324*/
  /*            ADD IMS CONNECT TYPE, SERVER->REMOTE    D6169/KYD0324*/
  /* 04/17/91 - REMOVE PDEFER/PNODEFER FROM             D6397/KYD0340*/
  /*            BIND/REBIND PACKAGE SUBCOMMANDS                      */
  /* 04/23/91 - DBRM MEMBER ALWAYS PASSED ON BIND PLAN        KYE0017*/
  /* 06/20/91 - RUN(CICS) EXECUTES RUN(CAF)                   KYS0587*/
  /* 06/10/91 - ADD CURRENTDATA TO PLAN AND PACKAGE     D6406/KDF0499*/
  /* 10/22/91 - ADD SQLFLAG PRECOMPILER OPTION               TU2300X8*/
  /* 12/16/91 - ENTRY POINT PLISTART FOR PL/I IMS APPS.       KYW2226*/
  /* 03/13/92 - ADD CONNECT(1/2) PRECOMPILER OPTION        RDTU2570H2*/
  /* 04/30/92 - ADD I/O DEGREE TO PLAN AND PACKAGE          RDTU2280H*/
  /* 06/25/92 - ADD 2ND PL/I LIBRARY PLI2LIB                    D7053*/
  /* 09/12/92 - CHANGE DSNLOAD TO SDSNLOAD           KDD0035    D7096*/
  /* 09/29/92 - SUPPORT CICS 3.2 AND UP DS NAMES     KDD0046    D7109*/
  /* 11/01/92 - SUPPORT SAA C/370                    KDD0047    D7110*/
  /* 11/05/92 - ADD SQLRULES AND DISCONNECT TO PLAN           KDP0202*/
  /* 05/11/93 - DOUBLE APOSTS W/IN COMPILER OPTIONS  KEF0171  KDB2036*/
  /* 11/11/93 - DON'T PUT FLAG(I), LINECOUNT(60) IN                  */
  /*            PRECOMPILER PARAMETER LIST       KEF0863/PN46427/@27 */
  /* 11/11/93 - MAKE COPTION PARAMETER IN SYSINDEX                   */
  /*            FUNCTION A STRING                KEF0870/PN46539/@39 */
  /* 03/07/94 - REMOVE SUPPORT FOR ASMH. MAKE ASM STAND FOR          */
  /*            HIGH LEVEL ASSEMBLER                   LI263/TU2632HL*/
  /* 03/16/94 - ADD ISOLATION(UR), PISOLATION(RS,UR,NC)      TU2800PC*/
  /*            FIX ERROR IN KEI0239                                 */
  /* 06/27/94 - MOVE CICS COBOL AND PL/I LIBRARIES FROM       KEW0324*/
  /*            LINK-EDIT INCLUDE TO SOURCE INCLUDE                  */
  /* 07/08/94 - SUPPORT PLI/MVS                               KEW0365*/
  /* 10/21/94 - CORRECT PLI/MVS, COBOL/MVS LINKEDIT OPTIONS   KES0005*/
  /* 10/24/94 - ADD DYNAMICRULES OPTION                       KEP0478*/
  /* 01/10/95 - CHANGE CURRENTDATA DEFAULT FOR PLANS TO YES   KED0109*/
  /* 06/27/95 - CHANGE RELEASE LEVEL TO 420                  TU3270RC*/
  /* 09/01/95 - ADD ISOLATION(RS)                       D8183/PN75407*/
  /* V4R2:                                                           */
  /* 07/07/95 - SUPPORT OOCOBOL=IBMCOB                TU3190TS/LI3190*/
  /* 09/01/95 - ADD DEFER/NODEFER BIND/REBIND PACKAGE   D9000/KFD0005*/
  /*            ADD REOPT(VARS) BIND/REBIND PLAN/PACKAGE             */
  /* 10/31/95 - CHANGE CPPCSLIB DEFAULT                       KFP0140*/
  /* 11/10/95 - SUPPORT C++=CPP                         KFW0112/LI319*/
  /* 12/05/95 - CLEANUP TO USE CXX REXX EXEC      KFD0022/D9031/LI319*/
  /*            DELETE: CPPLOAD, CPPMSGS, CPPCMSGS. ADD: CPPUTIL     */
  /*  3/11/96 - Change IBM COBOL default                D9043/KFD0049*/
  /* 10/22/96 - ADD RRSAF TO RUN TIME ENVIRONMENT            TU35332I*/
  /*            ADD KEEP DYNAMIC SQL BIND PLAN/PKG (KPDYN)      D9028*/
  /*            INCLUDE IBMCOB/CICS UPDATES McALISTER             BCM*/
  /*  3/19/97 - ADD DBPROTOCOL BIND PLAN/PKG                 LI350TSO*/
  /*            PDYNAMICRULES(ADD-DEFINE/INVOKE) BIND PKG   LI333TAC1*/
  /*            CHANGE RELEASE LEVEL TO 610                          */
  /* 04/25/97 - COPY OPTIONS TO BIND PACKAGE    Def4924/D9149/PQ03427*/
  /* 05/29/97 - LI331, LI375. INCLUDE PATH PLAN/PACKAGE         LI333*/
  /* 10/03/97 - ADD QUERYOPT BIND PLAN/PACKAGE                  LI375*/
  /* 06/26/98 - CICS 410 LOWEST LEVEL SUPPORT PROVIDED   DG136/F10178*/
  /* 07/24/98 - CHANGE QUERYOPT TO OPTHINT            DG138/li375_tac*/
  /* 09/04/98 - CHANGE DSNH760I TO WARNING AND RC=4           PQ19126*/
  /* 09/18/98 - ADD SUPPORT FOR IBM COBOL V2.1                  D9200*/
  /* 10/09/98 - PDYNAMICRULES (PACKAGE) NEW OPTIONS   DG122/dg122_tac*/
  /*            PQ20086 KEEPDYNAMIC DEFAULT (NO->NONE)               */
  /* 10/27/99 - FIX ENTRY NAME GENERATED FOR COBOL            PQ32183*/
  /* 03/12/00 - Add continuation character omitted by PQ32183 PQ36839*/
  /* 01/21/00   CHANGE RELEASE LEVEL TO 710                          */
  /* 04/13/01   CHANGE RELEASE LEVEL TO 810                          */
  /* 05/29/02 - Allow STDSQL option of YES                    PQ58938*/
  /* 05/30/02 - Remove extraneous CONTROL stmt added in V7    PQ60617*/
  /* 03/08/03 - Fix hang caused by quoted compiler opts   PQ66361 @01*/
  /* 08/20/03 - Update language support                     DJ218 @02*/
  /* 01/06/04 - Add REOPT(ALWAYS), REOPT(NONE), and REOPT(ONCE) DJ137*/
  /* 06/07/04 - FIX SUPPORT FOR ENTERPRISE PL/I           PQ88890 @03*/
  /* 06/26/04 - Support CICS COBOL3 parm                  PQ87421 @04*/
  /* 09/16/04   CHANGE RELEASE LEVEL TO 910                     LI673*/
  /* 10/14/04 - Add CCSID and NEWFUN parms                PQ95109 @05*/
  /* 05/05/05 - Add FLOAT option and fix ATTACH option    PK02174 @06*/
  /*            handling of CAF and RRSAF                         @06*/
  /* 03/15/06 - Remove SQLFLAG precompiler option               DJ361*/
  /* 03/22/06 - Change ISOLATION default to CS                  DK139*/
  /*            and CURRENTDATA default to NO                   DK139*/
  /* 08/15/06 - Add REOPT(AUTO)                                 DK216*/
  /* 07/10/07 - Fix PREOPT processing to check the PREOPT PK45722 @07*/
  /*            setting instead of the REOPT setting              @07*/
  /* 06/09/08   CHANGE RELEASE LEVEL TO 1010                    LI908*/
  /* 04/15/10   Support NEWFUN=Vxx                             DM1341*/
  /* 05/02/11   dn1554r1                         dn1554_inst_1/DN1554*/
  /*            CHANGE RELEASE LEVEL TO 1110                   DN1554*/
  /* 10/17/13   CHANGE RELEASE LEVEL TO 1210 n19664_s19545    169360 */
  /* 01/16/14   CHANGE RELEASE LEVEL TO 1210 (cont.)          170430 */
  /* 11/06/13   Add PROGAUTH to BIND PLAN                 PM98049 @09*/
  /*            Add ENCODING, IMMEDWRITE to BIND PLAN/PACKAGE     @10*/
  /*            Add APREUSE, APCOMPARE, SYSTIMESENSITIVE,         @10*/
  /*                BUSTIMESENSITIVE, ARCHIVESENSITIVE,           @10*/
  /*                APPLCOMPAT to BIND PACKAGE                    @10*/
  /*-----------------------------------------------------------------*/
  /*                                                                 */
  /* PSEUDOCODE                                                      */
  /*                                                                 */
  /*       INITIALIZATION, CHECK KEYWORDS                            */
  /*       CHECK NAMES PASSED,                                       */
  /*       SET NAMES FOR LATER                                       */
  /*       IF HOST LANGUAGE IS PLI, MACRO PHASE REQUESTED            */
  /*         DO                                                      */
  /*           INVOKE DSNHC CLIST TO COMPILE                         */
  /*           IF ERROR ENCOUNTERED THEN EXIT WITH MESSAGE           */
  /*         END                                                     */
  /*       IF PRECOMPILE WAS REQUESTED THEN                          */
  /*         DO                                                      */
  /*           SET UP PRECOMPILER OPTION STRING                      */
  /*           ALLOCATE PRECOMPILER DATA SETS                        */
  /*           INVOKE PRECOMPILER                                    */
  /*           IF ERROR ENCOUNTERED THEN EXIT WITH MESSAGE           */
  /*         END                                                     */
  /*       IF CICS COMMAND TRANSLATOR WAS REQUESTED THEN             */
  /*         DO                                                      */
  /*           SET UP TRANSLATOR OPTION STRING                       */
  /*           ALLOCATE TRANSLATOR DATA SETS                         */
  /*           INVOKE TRANSLATOR                                     */
  /*           IF ERROR ENCOUNTERED THEN EXIT WITH MESSAGE           */
  /*         END                                                     */
  /*       IF BIND PACKAGE (PBIND) IS REQUESTED THEN                 */
  /*         DO                                                      */
  /*           INVOKE DSN                                            */
  /*           INVOKE BIND PACKAGE                                   */
  /*           CHECK FOR ERRORS IN BIND, ISSUE MSG, EXIT             */
  /*         END                                                     */
  /*       IF BIND PLAN (BIND) IS REQUESTED THEN                     */
  /*         DO                                                      */
  /*           INVOKE DSN                                            */
  /*           INVOKE BIND PLAN                                      */
  /*           CHECK FOR ERRORS IN BIND, ISSUE MSG, EXIT             */
  /*         END                                                     */
  /*       IF COMPILE IS REQUESTED THEN                              */
  /*         DO                                                      */
  /*           INVOKE DSNHC CLIST TO COMPILE                         */
  /*           CHECK FOR ERRORS IN COMPILE, ISSUE MSG, EXIT          */
  /*         END                                                     */
  /*       IF HOST LANGUAGE IS 'C', PRE-LINKEDIT REQUESTED           */
  /*         DO                                                      */
  /*           INVOKE THE 'C' PRE-LINKEDIT ROUTINE                   */
  /*           CHECK FOR ERRORS IN PRE-LINKEDIT, ISSUE MSG, EXIT     */
  /*         END                                                     */
  /*       ELSE                                                      */
  /*         GENERATE ERROR MESSAGE AND EXIT                         */
  /*       IF LINKEDIT IS REQUESTED THEN                             */
  /*         DO                                                      */
  /*           INVOKE THE LINKAGE EDITOR                             */
  /*           CHECK FOR ERRORS IN LINKEDIT, ISSUE MSG, EXIT         */
  /*         END                                                     */
  /*       IF RUN  IS REQUESTED THEN                                 */
  /*         IF ATTACH IS TSO THEN                            TU2390A*/
  /*           DO                                                    */
  /*             INVOKE DSN                                          */
  /*             INVOKE RUN FOR THE PROGRAM                          */
  /*             CHECK FOR ERRORS IN RUN, ISSUE MSG, EXIT            */
  /*           END                                                   */
  /*         ELSE                                                    */
  /*           IF ATTACH IS CAF THEN                          TU2390A*/
  /*             CALL PROGRAM                                TU35332I*/
  /*                                                                 */
  /*******************************************************************/
  /*                 INITIALIZATION                                  */
  /*******************************************************************/
  SET &ERROR = 0                                /* ASSUME NO ERRORS  */
  SET &M751 = &STR(DSNH751I DSNH ERROR IN)      /* ERROR MSG TXT     */
  SET &M759 = &STR(DSNH759I DSNH TERMINATING,)  /* ERRMSG TXT        */
  SET RPAR = &STR())
  SET LPAR = &STR((
  SET &COB370 = YES               /* USING COBOL/370?  Y/N        @02*/
  SET &PLITYPE = PLIENT           /* USING ePrise PL/I Y/N        @02*/
  SET &DB2VERS = 12               /* This version of DB2  169360     */
  /*******************************************************************/
  /*                                                                 */
  /*                 EXECUTION TRACE CONTROL                         */
  /*                                                                 */
  /*  SET CONTROL TRACE ATTRIBUTES FOR EXECUTION                     */
  /*                                                                 */
  /*  PARMS:   NONE, LIST, CONLIST, SYMLIST                          */
  /*  DEFAULT: NONE=NOLIST NOCONLIST NOSYMLIST                       */
  /*******************************************************************/
  IF &SUBSTR(1,&CONTROL) ^= N THEN              /* IF NOT NONE THEN  */+
    DO                                          /* SET UP TO TRACE   */
      /*-------------------------------------------------------------*/
      /* EXAMINE CONTROL VALUE SPECIFIED                             */
      /*-------------------------------------------------------------*/
      IF &SUBSTR(1,&CONTROL) = L THEN           /* IF 'LIST'         */+
        CONTROL LIST
      ELSE                                      /* NOT LIST,BUT WHAT?*/+
        DO                                      /* SET TRACING PROPER*/
         /*----------------------------------------------------------*/
         /* CHECK FOR CONLIST OR SYMLIST                             */
         /*----------------------------------------------------------*/
          IF &SUBSTR(1,&CONTROL) = C THEN       /* CHAR IS C         */+
            CONTROL LIST CONLIST
          ELSE                                  /* CHECK FOR SYMLIST */+
            DO
              /*-----------------------------------------------------*/
              /* CHECK FOR SYMLIST                                   */
              /*-----------------------------------------------------*/
              IF &SUBSTR(1,&CONTROL) = S THEN   /* WAS IT SYMLIST?   */+
                CONTROL LIST CONLIST SYMLIST    /* ISSUE CONTROL     */
              ELSE                              /* NONE OF THE ABOVE */+
                DO
                  /*-------------------------------------------------*/
                  /* DSNH751I: ERROR IN CONTROL VALUE SPECIFIED      */
                  /*-------------------------------------------------*/
                  SET &ERROR = 8                /* REMEMBER THE ERROR*/
                  WRITE &M751 CONTROL VALUE &CONTROL
                END
            END                                 /* CHECK FOR SYMLIST */
        END
    END
  ELSE CONTROL NOLIST NOCONLIST NOSYMLIST       /* @BA02917          */
  /*******************************************************************/
  /*                                                                 */
  /*                 DATE KEYWORD OPTION                             */
  /*                                                                 */
  /*  FORMAT OF DATE OUTPUT FOR PRECOMPILER                          */
  /*                                                                 */
  /*  PARMS:   DATE FORMAT                                           */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &DATE = NONE                /* DATE SYNTAX CHECK                */+
    THEN SET &DATE = &STR()      /* PASS NOTHING TO PRECOMPILER      */
    ELSE                         /* PASS IT TO PRECOMPILER           */+
      DO
       /*------------------------------------------------------------*/
       /* EXAMINE DATE VALUE SPECIFIED                               */
       /*------------------------------------------------------------*/
        SET &D = &SUBSTR(1,&DATE)   /* GET FIRST CHARACTER           */
        IF (&D^=I) AND (&D^=J) AND (&D^=U) AND (&D^=E) AND (&D^=L)     +
          THEN                   /* IF THE VALUE IS ILLEGAL, SAY IT  */+
            DO
              /*-----------------------------------------------------*/
              /* DSNH751I: ERROR IN DATE VALUE SPECIFIED             */
              /*-----------------------------------------------------*/
              SET &ERROR = 8     /* REMEMBER THE ERROR               */
              WRITE &M751 DATE VALUE &DATE
            END
        IF &D = I THEN SET &DATE = DATE(ISO) /* PREPARE TO PASS PARM */
        IF &D = J THEN SET &DATE = DATE(JIS) /* TO PRECOMPILER       */
        IF &D = U THEN SET &DATE = DATE(USA)
        IF &D = E THEN SET &DATE = DATE(EUR)
        IF &D = L THEN SET &DATE = DATE(LOCAL)
      END
  /*******************************************************************/
  /*                                                                 */
  /*                 TIME KEYWORD OPTION                             */
  /*                                                                 */
  /*  FORMAT OF TIME OUTPUT FOR PRECOMPILER                          */
  /*                                                                 */
  /*  PARMS:   TIME FORMAT                                           */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &TIME = NONE                /* DO TIME SYNTAX CHECKING          */+
    THEN SET &TIME = &STR()      /* PASS NOTHING TO PRECOMPILER      */
    ELSE                         /* PASS IT TO PRECOMPILER           */+
      DO
       /*------------------------------------------------------------*/
       /* EXAMINE TIME VALUE SPECIFIED                               */
       /*------------------------------------------------------------*/
        SET &T = &SUBSTR(1,&TIME)   /* GET FIRST CHARACTER           */
        IF (&T^=I) AND (&T^=J) AND (&T^=U) AND (&T^=E) AND (&T^=L)     +
          THEN                      /* IF VALUE IS ILLEGAL, SAY IT   */+
            DO
              /*-----------------------------------------------------*/
              /* DSNH751I: ERROR IN TIME VALUE SPECIFIED             */
              /*-----------------------------------------------------*/
              SET &ERROR = 8     /* REMEMBER THE ERROR               */
              WRITE &M751 TIME VALUE &TIME
            END
        IF &T = I THEN SET &TIME = TIME(ISO) /* PREPARE PARM FOR     */
        IF &T = J THEN SET &TIME = TIME(JIS) /* THE PRECOMPILER      */
        IF &T = U THEN SET &TIME = TIME(USA)
        IF &T = E THEN SET &TIME = TIME(EUR)
        IF &T = L THEN SET &TIME = TIME(LOCAL)
      END
  /*******************************************************************/
  /*                                                                 */
  /*                 GRAPHIC KEYWORD OPTION                          */
  /*                                                                 */
  /*  FORMAT OF GRAPHIC CHARACTERS FOR PRECOMPILER                   */
  /*                                                                 */
  /*  PARMS:   NONE, YES, NO                                         */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &GRAPHIC = NONE OR          /* GRAPHIC SYNTAX CHECK             */+
     &GRAPHIC = NON              /* NONE AND NON AREN'T AMBIGUOUS    */+
    THEN SET &GRAPHIC = &STR()   /* PASS NOTHING TO PRECOMPILER      */
    ELSE                         /* PASS SOMETHING TO PRECOMPILER    */+
      DO
        /*-----------------------------------------------------------*/
        /* EXAMINE GRAPHIC VALUE SPECIFIED                           */
        /*-----------------------------------------------------------*/
        IF &GRAPHIC = NO         /* IF NO, MAKE PRECOMPILER ACT LIKE */+
          THEN SET &GRAPHIC = NOGRAPHIC   /* SET TO NOGRAPHIC        */
          ELSE                            /* NOT NO                  */+
            IF &SUBSTR(1,&GRAPHIC) = Y    /* TEST FOR YES            */+
              THEN SET &GRAPHIC = GRAPHIC  /* SET TO GRAHPIC         */
              ELSE                  /* BAD PARM RECEIVED             */+
                DO
                  /*-------------------------------------------------*/
                  /* DSNH751I: ERROR IN GRAPHIC VALUE SPECIFIED      */
                  /*-------------------------------------------------*/
                  SET &ERROR = 8    /* REMEMBER THE ERROR            */
                  WRITE &M751 GRAPHIC VALUE &GRAPHIC
                END
      END
  /************************************************************* +@06*/
  /*                                                                 */
  /*                  FLOAT KEYWORD OPTION                           */
  /*                                                                 */
  /*  FORMAT OF FLOATING POINT HOST VARS FOR PRECOMPILER             */
  /*                                                                 */
  /*  PARMS:   S390, IEEE                                            */
  /*  DEFAULT: S390                                                  */
  /*******************************************************************/
  IF &FLOAT = S390 THEN          /* IF USING DEFAULT                 */+
    SET &FLOAT = &STR()          /*   PASS NOTHING TO PRECOMPILER    */
  ELSE IF &FLOAT = IEEE THEN     /* ELSE IF IEEE SPECIFIED           */+
    SET &FLOAT = FLOAT(IEEE)     /*   PASS FLOAT(IEEE) TO PRECOMP    */
  ELSE                           /* ELSE BAD PARM RECEIVED           */+
    DO
      /*-------------------------------------------------------------*/
      /* DSNH751I: ERROR IN FLOAT VALUE SPECIFIED                    */
      /*-------------------------------------------------------------*/
      SET &ERROR = 8             /* REMEMBER THE ERROR               */
      WRITE &M751 FLOAT VALUE &FLOAT                           /*-@06*/
    END
  /*******************************************************************/
  /*                                                                 */
  /*                 VERSION KEYWORD OPTION                          */
  /*                                                                 */
  /*  VERSION ID OF THE DBRM       FOR PRECOMPILER                   */
  /*                                                                 */
  /*  PARMS:   AUTO OR ANY STRING                                    */
  /*  DEFAULT: NULL                                                  */
  /*******************************************************************/
  IF &NRSTR(&VERSION) = THEN     /* IF KEYWORD NOT SPECIFIED      */+
     SET BVERSION =              /* NO KEYWORD SPECIFIED          */
  ELSE                           /* COPYVER IS PRESENT            */+
     SET BVERSION = &NRSTR(VERSION(&VERSION))
  /*******************************************************************/
  /*                                                                 */
  /*                 CONNECT KEYWORD OPTION                          */
  /*                                                                 */
  /*  CONNECT: CONNECT STATEMENT SEMANTICS OF PRECOMPILER            */
  /*                                                                 */
  /*  PARMS:                                                         */
  /*         1 USE DB2 V2R3 SEMANTICS                                */
  /*         2 USE DB2 V3R1 SEMANTICS                                */
  /*  DEFAULT: NULL                                                  */
  /*******************************************************************/
  IF &CONNECT ^= &STR() THEN        /* IF CONNECT IS SPECIFIED       */+
    IF &CONNECT = 1 THEN            /* CONNECT V2R3 ?                */+
      SET &CONNECT=CT(1)            /* SET CONNECT TO V2R3           */
    ELSE                            /* CONTINUE CONNECT CHECKING ?   */+
      IF &CONNECT = 2 THEN          /* CONNECT V3R1 ?                */+
        SET &CONNECT=CT(2)          /* SET CONNECT TO V3R1           */
      ELSE                          /* ERROR IN CONNECT PARAMETER    */+
        DO                          /* ISSUE THE ERROR MESSAGE       */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN CONNECT VALUE SPECIFIED              */
          /*---------------------------------------------------------*/
          SET &ERROR = 8              /* REMEMBER THE ERROR          */
          WRITE &M751 CONNECT VALUE &CONNECT
        END                           /* OF ERROR SETTING            */
  /*******************************************************************/
  /*                                                                 */
  /*                 ACQUIRE KEYWORD OPTION                          */
  /*                                                                 */
  /*  INFORM BIND WHERE TO ACQUIRE DB2 RESOURCES                     */
  /*                                                                 */
  /*  PARMS:   USE, ALLOCATE                                         */
  /*  DEFAULT: USE                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&ACQUIRE) = A THEN   /* ACQUIRE PARM SYNTAX CHECKING  */+
    SET &ACQUIRE = ALLOCATE         /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK FOR ACQUIRE AT USE      */+
    IF &SUBSTR(1,&ACQUIRE) = U THEN /* ACQUIRE AT USE                */+
      SET &ACQUIRE = USE            /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN ACQUIRE VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 ACQUIRE VALUE &ACQUIRE
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 ACTION KEYWORD OPTION                           */
  /*                                                                 */
  /*  INDICATE APPLICATION PLAN IS NEW OR REPLACEMENT                */
  /*                                                                 */
  /*  PARMS:   REPLACE, ADD                                          */
  /*  DEFAULT: REPLACE                                               */
  /*******************************************************************/
  IF &SUBSTR(1,&ACTION) = A THEN    /* ACTION PARAMETER SYNTAX CHECK */+
    SET &ACTION = ADD               /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK REPLACE ACTION          */+
    IF &SUBSTR(1,&ACTION) = R THEN  /* ACTION IS REPLACE             */+
      SET &ACTION = REPLACE         /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN ACTION VALUE SPECIFIED                 */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 ACTION VALUE &ACTION
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 BIND KEYWORD OPTION                             */
  /*                                                                 */
  /*  INVOKE BIND PROCESS BASED UPON COMPLETION CODE FROM PRIOR      */
  /*  STEPS                                                          */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: YES                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&BIND) = Y THEN      /* BIND(YES) WAS CHOSEN          */+
    SET &BIND   = YES               /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO BIND                 */+
    IF &SUBSTR(1,&BIND) = N THEN    /* BIND(NO) WAS CHOSEN           */+
      SET &BIND   = NO              /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN BIND VALUE SPECIFIED                   */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 BIND VALUE &BIND
      END                           /* OF ERROR SETTING              */
  /************************************************************* +@05*/
  /*                CCSID KEYWORD OPTION                             */
  /*                                                                 */
  /*  SPECIFY CCSID OTHER THAN THE DSNHDECP CCSID SETTING            */
  /*  - CCSID(DEFAULT) MEANS USE THE DSNHDECP CCSID SETTING          */
  /*                                                                 */
  /*  PARMS:   DEFAULT,1-65533                                       */
  /*  DEFAULT: DEFAULT                                               */
  /*******************************************************************/
  IF &SUBSTR(1,&CCSID) = D THEN     /* CCSID(DEFAULT) WAS CHOSEN     */+
    SET &CCSID  = DEFAULT           /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK FOR ACTUAL CCSID        */+
    IF &DATATYPE(&CCSID) NE NUM     /* IF IT IS NOT NUMERIC          */+
     OR &CCSID < 1                  /*   OR IS LESS THAN 1           */+
     OR &CCSID > 65533 THEN         /*   OR GREATER THAN 65533 THEN  */+
      DO                            /*     THIS IS AN ERROR          */
       /*------------------------------------------------------------*/
       /* DSNH751I: ERROR IN CCSID VALUE SPECIFIED                   */
       /*------------------------------------------------------------*/
       SET &ERROR = 8               /*       REMEMBER THE ERROR      */
       WRITE &M751 CCSID VALUE &CCSID
      END                           /*       OF ERROR SETTING    -@05*/
  /*******************************************************************/
  /*                                                                 */
  /*                 CICSXLAT KEYWORD OPTION                         */
  /*                                                                 */
  /*  INDICATES INVOCATION OF CICS COMMAND TRANSLATOR                */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: YES                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&EXPLAIN)= Y THEN    /* EXPLAIN PARM SYNTAX CHECK     */+
    SET &EXPLAIN = YES              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK FOR VALUE = 'NO'        */+
    IF &SUBSTR(1,&EXPLAIN)= N THEN  /* IF EXPLAIN IS NO  THEN        */+
      SET &EXPLAIN = NO             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 EXPLAIN VALUE &EXPLAIN
      END                           /* OF ERROR SETTING              */
  IF &SUBSTR(1,&CICSXLAT) = Y THEN  /* CICSXLAT SYNTAX CHECK         */+
    SET &CICSXLAT = YES             /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO CICSXLAT             */+
    IF &SUBSTR(1,&CICSXLAT) = N THEN   /* CICSXLAT(NO) CHOSEN        */+
      SET &CICSXLAT = NO            /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN CICSXLAT VALUE SPECIFIED               */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 CICSXLAT VALUE &CICSXLAT
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                          KDD0046*/
  /*                 CICSVER  KEYWORD OPTION                  KDD0046*/
  /*                                                          KDD0046*/
  /*  INDICATES CICS RELEASE                                  KDD0046*/
  /*                                                          KDD0046*/
  /*  PARMS ALLOWED: 13, 53, 22, 23                               @02*/
  /*    41 = 5655-018: CICS/ESA Version 4                      F10178*/
  /*    11 = 5655-147: CICS Transaction server for OS/390 V1R1 F10178*/
  /*    51 =             Element: CICS 5.1.0                   F10178*/
  /*    12 = 5655-147: CICS Transaction server for OS/390 V1R2 F10178*/
  /*    52 =             Element: CICS 5.2.0                   F10178*/
  /*    13 = 5655-147: CICS Transaction server for OS/390 V1R3    @02*/
  /*    53 =             Element: CICS 5.3.0                      @02*/
  /*    21 = 5697-E93: CICS Transaction Server for z/OS V2R1      @02*/
  /*    22 = 5697-E93: CICS Transaction Server for z/OS V2R2      @02*/
  /*    23 = 5697-E93: CICS Transaction Server for z/OS V2R3      @02*/
  /*                                                           F10178*/
  /*  DEFAULT: 53                                                 @02*/
  /*******************************************************************/
  IF &CICSVER = 13                  /*CICS TS 1.3                 @02*/+
   OR &CICSVER = 53                 /*CICS 5.3 (CICS TS 1.3)      @02*/+
    OR &CICSVER = 22                /*CICS TS 2.2                 @02*/+
     OR &CICSVER = 23               /*CICS TS 2.3                 @02*/+
      OR &CICSVER = 41              /*CICS 4.1                 F10178*/+
       OR &CICSVER = 51             /*CICS 5.1 (CICS TS 1.1)   F10178*/+
        OR &CICSVER = 11            /*CICS TS 1.1              F10178*/+
         OR &CICSVER = 52           /*CICS 5.2 (CICS TS 1.2)   F10178*/+
          OR &CICSVER = 12 THEN     /*CICS TS 1.2              F10178*/+
    DO                              /*                         F10178*/
      SET &CICSLOAD = SDFHLOAD      /*SET CICS LOADLIB SUFFIX  F10178*/
      SET &CICSPL1  = SDFHPL1       /*SET CICS PL/I SUFFIX     F10178*/
      SET &CICSCOB  = SDFHCOB       /*SET CICS COBOL SUFFIX    F10178*/
    END                             /*                         F10178*/
  ELSE                              /*                         F10178*/+
    DO                              /*                         F10178*/
      SET &ERROR = 8                /* REMEMBER THE ERROR      F10178*/
      WRITE &M751 CICSVER VALUE &CICSVER /*                    F10178*/
    END                             /*                         F10178*/
  /*******************************************************************/
  /*                                                                 */
  /*                 COMPILATION KEYWORD OPTION                      */
  /*                                                                 */
  /*  INDICATES INVOCATION OF COMPILATION STEP                       */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: YES                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&COMPILE)= Y THEN    /* COMPILE PARM SYNTAX CHECK     */+
    SET &COMPILE = YES              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO COMPILE              */+
    IF &SUBSTR(1,&COMPILE)= N THEN  /* IF COMPILE IS NO  THEN        */+
      SET &COMPILE = NO             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN COMPILE VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 COMPILE VALUE &COMPILE
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 PRELINK KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES INVOCATION OF PRELINKEDIT STEP                       */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: YES                                            PQ19126*/
  /*******************************************************************/
  IF &SUBSTR(1,&PRELINK)   = Y THEN /* IF PRELINK IS YES THEN        */+
    SET &PRELINK    = YES           /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO PRELINK              */+
    IF &SUBSTR(1,&PRELINK)   = N THEN  /* IF PRELINK IS NO THEN      */+
      SET &PRELINK    = NO          /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN PRELINK VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 PRELINK VALUE &PRELINK
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 LINK KEYWORD OPTION                             */
  /*                                                                 */
  /*  INDICATES INVOCATION OF LINKEDIT STEP UPON SUCCESSFUL          */
  /*  COMPLETION OF COMPILATION OR ASSEMBLY                          */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: YES                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&LINK)   = Y THEN    /* IF LINK    IS YES THEN        */+
    SET &LINK    = YES              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO LINK                 */+
    IF &SUBSTR(1,&LINK)   = N THEN  /* IF LINK    IS NO  THEN        */+
      SET &LINK    = NO             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN LINK VALUE SPECIFIED                   */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 LINK VALUE &LINK
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 MACRO KEYWORD OPTION                            */
  /*                                                                 */
  /*  INDICATES INVOCATION OF MACRO PROCESSOR BEFORE PRECOMPILATION  */
  /*  OF A PL/I PROGRAM                                              */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: YES                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&MACRO)= Y THEN      /* SYNTAX CHECK MACRO PARAMETER  */+
    SET &MACRO = YES                /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO MACRO                */+
    IF &SUBSTR(1,&MACRO)= N THEN    /* IF MACRO IS NO THEN           */+
      SET &MACRO = NO               /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN MACRO VALUE SPECIFIED                  */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 MACRO VALUE &MACRO
      END                           /* OF ERROR SETTING              */
  /************************************************************* +@05*/
  /*                 NEWFUN KEYWORD OPTION                           */
  /*                                                                 */
  /*  SPECIFY WHETHER PRECOMPILER SHOULD PERMIT NEW FUNCTION SQL     */
  /*  - NEWFUN(DEFAULT) MEANS USE THE DSNHDECP NEWFUN SETTING        */
  /*                                                                 */
  /*  PARMS:   DEFAULT, YES, NO, Vxx                                 */
  /*  DEFAULT: DEFAULT                                               */
  /*******************************************************************/
  SET &CURRVERS = V&DB2VERS
  SET &PREVERS1 = V&EVAL(&DB2VERS-1)
  SET &PREVERS2 = V&EVAL(&DB2VERS-2)
  SET &PREVERS3 = V&EVAL(&DB2VERS-3)
  IF &SUBSTR(1,&NEWFUN)= D THEN     /* SYNTAX CHECK NEWFUN PARAMETER */+
    SET &NEWFUN = DEFAULT           /* BE SURE KEYWORD IS EXACT      */
  ELSE IF &SUBSTR(1,&NEWFUN)= Y THEN/* CHECK NEW FUNCTION ALLOWED    */+
    SET &NEWFUN = YES               /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO NEW FUNCTION ALLOWED */+
    IF &SUBSTR(1,&NEWFUN)= N THEN   /* IF NEWFUN IS NO THEN          */+
      SET &NEWFUN = NO              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* Check Vxx allowed       DM1341*/+
    IF &NEWFUN NE &CURRVERS AND     /* IF NEWFUN not current version */+
       &NEWFUN NE &PREVERS1 AND     /*   and not prior version       */+
       &NEWFUN NE &PREVERS2 AND     /*   and not prior prior version */+
       &NEWFUN NE &PREVERS3 THEN    /*   and not 3 x prior   version */+
                                    /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN NEWFUN VALUE SPECIFIED                 */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 NEWFUN VALUE &NEWFUN
      END                           /* OF ERROR SETTING          @-05*/
  /*******************************************************************/
  /*                                                                 */
  /*                 PRECOMP KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES INVOCATION OF PRECOMPLE STEP                         */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: YES                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&PRECOMP)= Y THEN    /* SYNTAX CHECK PRECOMP PARAMETER*/+
    SET &PRECOMP = YES              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO PRECOMP              */+
    IF &SUBSTR(1,&PRECOMP)= N THEN  /* IF PRECOMP IS NO THEN         */+
      SET &PRECOMP = NO             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN PRECOMP VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 PRECOMP VALUE &PRECOMP
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 OPTIONS KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES OPTIONS USED WITH PRECOMPILE OR CICS TRANSLATOR      */
  /*  ARE TO BE PROVIDED IN OUTPUT LISTINGS                          */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: NO                                                    */
  /*******************************************************************/
  IF &SUBSTR(1,&OPTIONS)= Y THEN    /* SYNTAX CHECK OPTIONS KEYWORD  */+
    SET &OPTIONS = YES              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO OPTIONS              */+
    IF &SUBSTR(1,&OPTIONS)= N THEN  /* IF OPTIONS IS NO  THEN        */+
      SET &OPTIONS = NO             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN OPTIONS VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 OPTIONS VALUE &OPTIONS
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 RELEASE KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES WHEN BIND SHOULD RELEASE DB2 RESOURCES               */
  /*                                                                 */
  /*  PARMS:   COMMIT, DEALLOCATE                                    */
  /*  DEFAULT: COMMIT                                                */
  /*******************************************************************/
  IF &SUBSTR(1,&RELEASE) = D THEN   /* SYNTAX CHECK RELEASE PARAMETER*/+
    SET &RELEASE = DEALLOCATE       /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK FOR RELEASE COMMIT      */+
    IF &SUBSTR(1,&RELEASE) = C THEN /* SYNTAX CHECK RELEASE PARAMETER*/+
      SET &RELEASE = COMMIT         /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN RELEASE VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 RELEASE VALUE &RELEASE
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 RETAIN KEYWORD OPTION                           */
  /*                                                                 */
  /*  INDICATE BIND AND EXECUTE PRIVILEGES ARE TO CONTINUE WHEN      */
  /*  APPLICATION PLAN IS REPLACED                                   */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: NO                                                    */
  /*******************************************************************/
  IF &SUBSTR(1,&RETAIN )= Y THEN    /* SYNTAX CHECK RETAIN PARAMETER */+
    SET &RETAINKY = RETAIN          /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO RETAIN, DEFAULT      */+
    IF &SUBSTR(1,&RETAIN )= N THEN  /* IF RETAIN  IS NO  THEN        */+
      SET &RETAINKY =
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN RETAIN VALUE SPECIFIED                 */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 RETAIN  VALUE &RETAIN
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 RUN KEYWORD OPTION                              */
  /*                                                                 */
  /*  INDICATES INVOCATION OF COMPILED PROGRAM BASED UPON SUCCESSFUL */
  /*  COMPLETION OF PRIOR STEPS                                      */
  /*                                                                 */
  /*  PARMS: VALUES:           EXECUTE:  ATTACH:              TU2390A*/
  /*         (YES|TSO)         YES       TSO                  TU2390A*/
  /*         (CAF)             YES       CAF                  TU2390A*/
  /*         (NO|BATCH,CAF)    NO        TSO|CAF              TU2390A*/
  /*         (IMS|CICS|RRSAF)  NO        IMS|CICS|RRSAF      TU35332I*/
  /*                                                                 */
  /*  DEFAULT:                 YES       TSO                  TU2390A*/
  /*******************************************************************/
  SET &RUNERR = 0                   /* INITIALIZE RUN ERROR   TU2390A*/
  SET SYSDVAL = &RUN                /* OBTAIN RUN PARAMETER   TU2390A*/
  READDVAL RUN1 RUN2                /* PARSE INTO TWO VALUES  TU2390A*/
  SET POS = &SYSINDEX(&SUBSTR(1,&RUN1&STR( )),YTCNBIR)     /*TU35332I*/
  SET &ATTACH=TSO                   /* TSO MOST COMMON        TU2390A*/
  IF &POS ^= 0 THEN                 /* RUN PARM VALID ?       TU2390A*/+
    DO                              /* PROCESS RUN PARM       TU2390A*/
      /*-------------------------------------------------------------*/
      /*  PARM IS: YES, TSO, CAF/CICS, NO, BATCH, IMS         KYS0587*/
      /* SYSINDEX: Y=1  T=2  C=3       N=4 B=5    I=6         KYS0587*/
      /*-------------------------------------------------------------*/
      IF &POS <= 3 THEN             /* (YES|TSO|CAF|CICS) ?   KYS0587*/+
        DO                          /* PROCESS PARM           TU2390A*/
          /*---------------------------------------------------------*/
          /* FIRST PARAMETER IS: YES, TSO, CAF, OR CICS       KYS0587*/
          /*---------------------------------------------------------*/
          SET &RUN = YES            /* RUN(YES) MOST COMMON   TU2390A*/
          IF &POS = 3 THEN          /* SPECIFY CAF OR CICS ?  KYS0587*/+
            DO                      /* PROCESS CAF/CICS       KYS0587*/
              /*-----------------------------------------------------*/
              /* PARM IS: CAF, OR CICS                        KYS0587*/
              /*-----------------------------------------------------*/
              IF &SUBSTR(2,&RUN1&STR( )) = A THEN /* CAF ?    KYS0587*/+
                SET &ATTACH=CAF     /* ATTACH IS CAF          KYS0587*/
              ELSE                  /* CONTINUE CHECK         KYS0587*/+
                IF &SUBSTR(2,&RUN1&STR( )) = I THEN /* CICS ? KYS0587*/+
                  DO                /* PROCESS CICS           KYS0587*/
                    SET &RUN = NO   /* REQUEST IS RUN(NO)     KYS0587*/
                    SET &ATTACH=CICS /* ATTACH IS CICS        KYS0587*/
                  END               /* CICS COMPLETE          KYS0587*/
                ELSE                /* FIRST PARM INVALID     KYS0587*/+
                  SET &RUNERR = 8   /* REMEMBER THE ERROR     TU2390A*/
            END                     /* CAF/CICS COMPLETE      KYS0587*/
        END                         /* PARM COMPLETE          TU2390A*/
      ELSE                          /* (NO|BATCH|IMS|CICS|RRSAF)     */+
        DO                          /* PROCESS PARM           TU2390A*/
          /*---------------------------------------------------------*/
          /* PARM IS: NO, BATCH, IMS, OR RRSAF               TU35332I*/
          /*---------------------------------------------------------*/
          SET &RUN = NO             /* REQUEST IS RUN(NO)     TU2390A*/
          IF &POS = 4 OR            /* (NO) OR                TU2390A*/+
            &POS = 5 THEN           /* (BATCH) ?              TU2390A*/+
            DO                      /* SECOND PARM PERMITTED  TU2390A*/
              /*-----------------------------------------------------*/
              /* PARM IS: NO, BATCH                           TU2390A*/
              /* SECOND PARM PERMITTED IS: CAF                TU2390A*/
              /*-----------------------------------------------------*/
              IF &RUN2 ^= &STR() THEN  /* SECOND PARM ?       KYL1174*/+
                IF &SYSINDEX(&SUBSTR(1,&RUN2&STR( )),C)=1 THEN         +
                  SET &ATTACH=CAF   /* REQUESTS ATTACH = CAF  TU2390A*/
                ELSE                /* SECOND PARM INVALID    TU2390A*/+
                  SET &RUNERR = 8   /* REMEMBER THE ERROR     TU2390A*/
            END                     /* SECOND PARM COMPLETE   TU2390A*/
          ELSE                      /* MUST BE IMS OR RRSAF   TU2390A*/+
            DO                      /* PROCESS IMS OR RRSAF   TU2390A*/
              /*-----------------------------------------------------*/
              /* PARM IS: IMS OR RRSAF                       TU35332I*/
              /* SECOND PARM NOT PERMITTED                   TU35332I*/
              /*-----------------------------------------------------*/
              IF &RUN2 = &STR() THEN  /* NO SECOND PARM      TU35332I*/+
                IF &POS = 6 THEN    /* IMS ?                 TU35332I*/+
                  SET &ATTACH=IMS   /* REQUESTS ATTACH = IMS  TU2390A*/
                ELSE                /* MUST BE 7: RRSAF      TU35332I*/+
                  SET &ATTACH=RRSAF /* ATTACH = RRSAF        TU35332I*/
              ELSE                  /* SECOND NOT PERMITTED  TU35332I*/+
                SET &RUNERR = 8     /* REMEMBER THE ERROR    TU35332I*/
            END                     /* PROCESS COMPLETE      TU35332I*/
        END                         /* PARM COMPLETE         TU35332I*/
    END                             /* RUN PARM COMPLETE      TU2390A*/
  ELSE                              /* RUN PARM INVALID       TU2390A*/+
    SET &RUNERR = 8                 /* REMEMBER THE ERROR     TU2390A*/
  IF &RUNERR ^= 0 THEN              /* PARAMETER ERROR ?      TU2390A*/+
    DO                              /* ISSUE ERROR MESSAGE    TU2390A*/
      /*-------------------------------------------------------------*/
      /* DSNH751I: ERROR IN RUN VALUE SPECIFIED                      */
      /*-------------------------------------------------------------*/
      SET &ERROR = &RUNERR          /* REMEMBER THE ERROR     TU2390A*/
      WRITE &M751 RUN VALUE &SYSDVAL
    END                             /* OF ERROR SETTING       TU2390A*/
  /*******************************************************************/
  /*                                                                 */
  /*                 SOURCE KEYWORD OPTION                           */
  /*                                                                 */
  /*  INDICATES PRINT SOURCE CODE AND DIAGNOSTICS WITH OUTPUT FROM   */
  /*  PRECOMPILER                                                    */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: NO                                                    */
  /*******************************************************************/
  IF &SUBSTR(1,&SOURCE )= Y THEN    /* SYNTAX CHECK SOURCE PARAMETER */+
    SET &SOURCE  = YES              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO SOURCE               */+
    IF &SUBSTR(1,&SOURCE )= N THEN  /* IF SOURCE  IS NO  THEN        */+
      SET &SOURCE  = NO             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN SOURCE VALUE SPECIFIED                 */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 SOURCE VALUE &SOURCE
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 SUFFIX KEYWORD OPTION                           */
  /*                                                                 */
  /*  INDICATES USE TSO STANDARD NAMING CONVENTIONS                  */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: YES                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&SUFFIX )= Y THEN    /* IF SUFFIX  IS YES THEN        */+
    SET &SUFFIX  = YES              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO SUFFIX               */+
    IF &SUBSTR(1,&SUFFIX )= N THEN  /* IF SUFFIX  IS NO  THEN        */+
      SET &SUFFIX  = NO             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN SUFFIX VALUE SPECIFIED                 */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 SUFFIX VALUE &SUFFIX
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 XREF KEYWORD OPTION                             */
  /*                                                                 */
  /*  INDICATES CROSS-REFERENCE LISTING IS TO BE INCLUDED IN OUTPUT  */
  /*  OF PRECOMPILER, COMPILER, AND LINKAGE EDITOR                   */
  /*                                                                 */
  /*  PARMS:   YES, NO                                               */
  /*  DEFAULT: NO                                                    */
  /*******************************************************************/
  IF &SUBSTR(1,&XREF)= Y THEN       /* SYNTAX CHECK XREF PARAMETER   */+
    SET &XREF    = YES              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO XREF                 */+
    IF &SUBSTR(1,&XREF   )= N THEN  /* IF XREF    IS NO  THEN        */+
      SET &XREF    = NO             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN XREF VALUE SPECIFIED                   */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 XREF VALUE &XREF
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 DECARTH KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES THE DECIMAL PRECISION FOR PRECOMPILER: DEC(15/31)    */
  /*                                                                 */
  /*  PARMS:   DEFAULT, DEC(15), DEC(31)                             */
  /*  DEFAULT: DEFAULT - TO INSTALLATION OPTION                      */
  /*******************************************************************/
  IF &SUBSTR(1,&DECARTH)= D THEN    /* SYNTAX CHECK DECARTH KEYWORD  */+
    SET &DECARTH = DEFAULT          /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK OTHER KEYWORDS          */+
    IF &DECARTH = 15 THEN           /* IF DECARTH IS DEC(15)         */+
      SET &DECARTH = DEC(15)        /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* CHECK NO DELIMIT              */+
      IF &DECARTH = 31 THEN         /* IF DECARTH IS DEC(31)         */+
        SET &DECARTH = DEC(31)      /* BE SURE KEYWORD IS EXACT      */
      ELSE                          /* THIS IS AN ERROR              */+
        DO                          /* ISSUE THE ERROR MESSAGE       */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN DECARTH VALUE SPECIFIED              */
          /*---------------------------------------------------------*/
          SET &ERROR = 8            /* REMEMBER THE ERROR            */
          WRITE &M751 DECARTH VALUE &DECARTH
        END                         /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 DECIMAL KEYWORD OPTION                          */
  /*                                                                 */
  /*  PROVIDE DECIMAL POINT INDICATOR FOR DECIMAL AND FLOATING       */
  /*  POINT LITERALS                                                 */
  /*                                                                 */
  /*  PARMS:   PERIOD, COMMA                                         */
  /*  DEFAULT: PERIOD                                                */
  /*******************************************************************/
  IF &SUBSTR(1,&DECIMAL)= P THEN    /* SYNTAX CHECK DECIMAL PARAMETER*/+
    SET &DECIMAL = PERIOD           /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO DECIMAL              */+
    IF &SUBSTR(1,&DECIMAL)= C THEN  /* IF DECIMAL IS COMMA           */+
      SET &DECIMAL = COMMA          /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN DECIMAL VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 DECIMAL VALUE &DECIMAL
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 DEFER AND NODEFER KEYWORD OPTIONS               */
  /*                                                                 */
  /*  DEFER OR NODEFER PROCESSING OPTIONS (BIND PLAN)                */
  /*                                                                 */
  /*  PARMS:   PREP - PREPARE                                        */
  /*  DEFAULT: NODEFER(PREPARE)                                      */
  /*******************************************************************/
  IF &DEFER = NONE THEN             /* IF KEYWORD NOT SPECIFIED      */+
    SET &BDEFR =                    /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* DEFER KEYWORD SPECIFIED       */+
    IF &DEFER = PREPARE THEN        /* IF DEFER KEYWORD CORRECT      */+
      SET &BDEFR = DEFER(PREPARE)   /* SET TO DEFER PREPARE          */
    ELSE                            /* ERROR IN DEFER KEYWORD        */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN DEFER VALUE SPECIFIED                  */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /*  REMEMBER THE ERROR           */
        WRITE &M751 DEFER VALUE &DEFER
      END                           /* END ERROR SETTING             */
  IF &NODEFER = NONE THEN           /* IF KEYWORD NOT SPECIFIED      */+
    SET &BNDEFR =                   /* INDICATE KEYWORD NOT SPECIFIED*/
  ELSE                              /* NODEFER KEYWORD SPECIFIED     */+
    IF &NODEFER = PREPARE THEN      /* IF NODEFER KEYWORD CORRECT    */+
      SET &BNDEFR = NODEFER(PREPARE)  /* SET TO NODEFER PREPARE      */
    ELSE                            /* ERROR IN NODEFER KEYWORD      */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN NODEFER VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /*   REMEMBER THE ERROR          */
        WRITE &M751 NODEFER VALUE &NODEFER
      END                           /* END ERROR SETTING             */
  /*******************************************************************/
  /*                                                            D9028*/
  /*               KEEPDYNAMIC KEYWORD OPTION                   D9028*/
  /*                                                            D9028*/
  /*  INDICATE TO KEEP DYNAMIC SQL PAST COMMIT                  D9028*/
  /*                                                            D9028*/
  /*  PARMS:   NO, YES                                          D9028*/
  /*  DEFAULT: NO                                               D9028*/
  /*******************************************************************/
  IF &SUBSTR(1,&KEEPDYNAMIC)= N THEN  /* SYNTAX KEEPDYNAMIC     D9028*/+
    SET &KEEPDYNAMIC = NO           /* BE SURE KEYWORD IS EXACT D9028*/
  ELSE                              /* CHECK NO KEEPDYNAMIC     D9028*/+
    IF &SUBSTR(1,&KEEPDYNAMIC)= Y THEN  /* IF KEEPDYNAMIC YES   D9028*/+
      SET &KEEPDYNAMIC = YES        /* BE SURE KEYWORD IS EXACT D9028*/
    ELSE                            /* THIS IS AN ERROR         D9028*/+
      DO                            /* ISSUE THE ERROR MESSAGE  D9028*/
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN KEEPDYNAMIC VALUE SPECIFIED       D9028*/
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR       D9028*/
        WRITE &M751 KEEPDYNAMIC VALUE &KEEPDYNAMIC
      END                           /* OF ERROR SETTING         D9028*/
  /*******************************************************************/
  /*                                                                 */
  /*               CURRENTDATA KEYWORD OPTION                        */
  /*                                                                 */
  /*  INDICATES HOW DATA CURRENCY IS TO BE HANDLED FOR AMBIGUOUS     */
  /*  CURSORS.                                                       */
  /*                                                                 */
  /*  PARMS:   NO, YES                                               */
  /*  DEFAULT: NO                                               DK139*/
  /*******************************************************************/
  IF &SUBSTR(1,&CURRENTDATA)= N THEN  /* SYNTAX CURRENTDATA KEYWORD  */+
    SET &CURRENTDATA = NO           /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO CURRENTDATA          */+
    IF &SUBSTR(1,&CURRENTDATA)= Y THEN   /* IF CURRENTDATA IS YES    */+
      SET &CURRENTDATA = YES        /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN CURRENTDATA VALUE SPECIFIED            */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 CURRENTDATA VALUE &CURRENTDATA
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 CURRENTSERVER     KEYWORD OPTION                */
  /*                                                                 */
  /*  CURRENTSERVER(LOCATION)     OPTION  (BIND PLAN)                */
  /*                                                                 */
  /*  PARMS:   LOCATION OR NONE                                      */
  /*  DEFAULT: CURRENTSERVER(NONE)                                   */
  /*******************************************************************/
  IF &NRSTR(&CURRENTSERVER) = NONE THEN  /* IF KEYWORD NOT SPECIFIED */+
    SET &BCURRSRV =                 /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* CURRENTSERVER SPECIFIED       */+
    SET &BCURRSRV = &NRSTR(CURRENTSERVER(&CURRENTSERVER))
  /*******************************************************************/
  /*                                                                 */
  /*                  DEGREE KEYWORD OPTION                          */
  /*                                                                 */
  /*  REQUESTS DB2 TO EXECUTE A QUERY IN PARALLEL OR NOT             */
  /*                                                                 */
  /*  PARMS:                                                         */
  /*         1 - NOT TO EXECUTE A QUERY IN PARALLEL                  */
  /*       ANY - EXECUTE A QUERY IN PARALLEL                         */
  /*  DEFAULT: 1                                                     */
  /*******************************************************************/
  IF &SUBSTR(1,&DEGREE)= 1 THEN     /* IF DEGREE IS 1                */+
    SET &DEGREE = 1                 /* BE SURE KEYWORD IS EXACT      */
  ELSE                                                                 +
    IF &SUBSTR(1,&DEGREE)= A THEN   /* IF DEGREE IS ANY              */+
      SET &DEGREE = ANY             /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN DEGREE VALUE SPECIFIED                 */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 DEGREE VALUE &DEGREE
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                          KFD0005*/
  /*                 REOPT KEYWORD OPTIONS                    KFD0005*/
  /*                                                          KFD0005*/
  /*  REOPT PROCESSING OPTIONS (BIND PLAN)                    KFD0005*/
  /*                                                          KFD0005*/
  /*  PARMS:   NONE - KEYWORD NOT SPECIFIED ON INVOCATION       D9000*/
  /*           VARS - REOPT(VARS)                               D9000*/
  /*         ALWAYS - REOPT(ALWAYS)                             DJ137*/
  /*           AUTO - REOPT(AUTO)                               DK216*/
  /*           NONE - REOPT(NONE)                               DJ137*/
  /*           ONCE - REOPT(ONCE)                               DJ137*/
  /*  DEFAULT: NONE                                           KFD0005*/
  /*******************************************************************/
  IF &REOPT = NONE THEN             /* IF NOT SPECIFIED       KFD0005*/+
    SET &ROPT =                     /* NO KEYWORD SPECIFIED   KFD0005*/
  ELSE                              /* KEYWORD SPECIFIED      KFD0005*/+
    IF &REOPT = VARS THEN           /* IF VARS SPECIFIED        D9000*/+
      SET &ROPT = REOPT(VARS)       /* SET REOPT(VARS)          D9000*/
    ELSE IF &REOPT = ALWAYS THEN    /* IF ALWAYS SPECIFIED      DJ137*/+
      SET &ROPT = REOPT(ALWAYS)     /* SET REOPT(ALWAYS)        DJ137*/
    ELSE IF &REOPT = AUTO   THEN    /* IF AUTO SPECIFIED        DK216*/+
      SET &ROPT = REOPT(AUTO)       /* SET REOPT(AUTO)          DK216*/
    ELSE IF &REOPT = NONE THEN      /* IF NONE SPECIFIED        DJ137*/+
      SET &ROPT = REOPT(NONE)       /* SET REOPT(ONCE)          DJ137*/
    ELSE IF &REOPT = ONCE THEN      /* IF ONCE SPECIFIED        DJ137*/+
      SET &ROPT = REOPT(ONCE)       /* SET REOPT(ONCE)          DJ137*/
    ELSE                            /* MUST BE NONE/VARS        D9000*/+
      DO                            /* ISSUE ERROR MESSAGE    KFD0005*/
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN REOPT VALUE SPECIFIED           KFD0005*/
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR     KFD0005*/
        WRITE &M751 REOPT VALUE &REOPT
      END                           /* END ERROR SETTING      KFD0005*/
  /*******************************************************************/
  /*                                                                 */
  /*                SQLRULES KEYWORD OPTION                          */
  /*                                                                 */
  /*  SPECIFIES WHETHER A TYPE 2 CONNECT STATEMENT IS EXECUTED IN    */
  /*  ACCORDANCE WITH THE  RULES OF DB2 OR THE ISO/ANS SQL2 STANDARD */
  /*                                                                 */
  /*  PARMS:                                                         */
  /*       DB2 - DB2 RULES                                           */
  /*       STD - ISO/ANS SQL2 STANDARD                               */
  /*  DEFAULT: DB2                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&SQLRULES) = D THEN     /* IF SQLRULES IS D           */+
    SET &SQLRULES = DB2                /* BE SURE KEYWORD IS EXACT   */
  ELSE                                                                 +
    IF &SUBSTR(1,&SQLRULES) = S THEN   /* IF SQLRULES IS S           */+
      SET &SQLRULES = STD              /* BE SURE KEYWORD IS EXACT   */
    ELSE                               /* THIS IS AN ERROR           */+
      DO                               /* ISSUE THE ERROR MESSAGE    */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN SQLRULES VALUE SPECIFIED               */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 SQLRULES VALUE &SQLRULES
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*              DISCONNECT KEYWORD OPTION                          */
  /*                                                                 */
  /*  SPECIFIES WHAT REMOTE CONNECTIONS ARE DESTROYED DURING COMMIT  */
  /*  OPERATIONS.                                                    */
  /*                                                                 */
  /*  PARMS:                                                         */
  /*       EXPLICIT - DESTROY ONLY CONNECTIONS IN THE RELEASED STATE */
  /*       AUTOMATIC - DESTROY ALL REMOTE CONNECTIONS                */
  /*       CONDITIONAL - DESTROY REMOTE CONNECTIONS WHICH ARE NOT    */
  /*                     ASSOCIATED WITH AN OPEN WITH HOLD CURSOR    */
  /*  DEFAULT: EXPLICIT                                              */
  /*******************************************************************/
  IF &SUBSTR(1,&DISCONNECT) = E THEN   /* IF DISCONNECT IS E         */+
    SET &DISCONNECT = EXPLICIT         /* BE SURE KEYWORD IS EXACT   */
  ELSE                                                                 +
    IF &SUBSTR(1,&DISCONNECT) = A THEN   /* IF DISCONNECT IS AUTO    */+
      SET &DISCONNECT = AUTOMATIC        /* BE SURE KEYWORD IS EXACT */
    ELSE                                                               +
      IF &SUBSTR(1,&DISCONNECT) = C THEN  /* IF DISCONNECT IS COND   */+
        SET  &DISCONNECT = CONDITIONAL
      ELSE                                /* THIS IS AN ERROR        */+
       DO                                 /* ISSUE THE ERROR MESSAGE */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN DISCONNECT VALUE SPECIFIED             */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 DISCONNECT VALUE &DISCONNECT
       END                          /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                            LI333*/
  /*              BIND PLAN PATH (SCHEMA) KEYWORD               LI333*/
  /*                                                            LI333*/
  /*  PATH(SCHEMA LIST) OR PATH(NONE)                           LI333*/
  /*******************************************************************/
  IF &NRSTR(&PATH) = NONE THEN      /* IF KEYWORD NOT SPECIFIED LI333*/+
    SET BPATHS =                    /* NO KEYWORD SPECIFIED     LI333*/
  ELSE                              /* PATH LIST FOR PLAN       LI333*/+
    SET &BPATHS = &NRSTR(PATH(&PATH)) /* ADD PATH KEYWORD       LI333*/
  /*******************************************************************/
  /* ADD PACKAGE SUPPORT IN BIND PLAN SUBCOMMAND                     */
  /*                                                                 */
  /*  QUALIFIER(NAME) OR NONE                                        */
  /*  PKLIST(LOCATION.COLLECTION.ID ...) OR PKLIST(NONE)             */
  /*  DISABLE(LIST) OR NONE (LIST OF SUBSYSTEMS TO DISABLE)          */
  /*  ENABLE(LIST) OR NONE (LIST OF SUBSYSTEMS TO ENABLE)            */
  /*  CICS(LIST OF SUBSYSTEMS) OR NONE                               */
  /*  IMSBMP(LIST OF SUBSYSTEMS) OR NONE                             */
  /*  IMSMPP(LIST OF SUBSYSTEMS) OR NONE                             */
  /*  DLIBATCH(LIST OF SUBSYSTEMS) OR NONE                           */
  /*  CACHESIZE(N) SIZE OF CACHE                                     */
  /*                                                                 */
  /*******************************************************************/
  IF &NRSTR(&QUALIFIER) = NONE THEN /* IF KEYWORD NOT SPECIFIED      */+
     SET BQUALF =                   /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* QUALIFIER FOR TABLES PRESENT  */+
     SET &BQUALF = &NRSTR(QUALIFIER(&QUALIFIER))
  IF &NRSTR(&PKLIST) = NONE THEN    /* IF KEYWORD NOT SPECIFIED      */+
     SET BPKLIST =                  /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* PACKAGE LIST FOR PLAN PRESENT */+
     SET &BPKLIST = &NRSTR(PKLIST(&PKLIST))
  IF &NRSTR(&ENABLE) = NONE THEN    /* IF KEYWORD NOT SPECIFIED      */+
     SET BENABL =                   /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* DISABLE SUBSYSTEMS IS PRESENT */+
     SET BENABL = &NRSTR(ENABLE(&ENABLE))
  IF &NRSTR(&DISABLE) = NONE THEN   /* IF KEYWORD NOT SPECIFIED      */+
     SET BDISABL =                  /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* DISABLE SUBSYSTEMS IS PRESENT */+
     SET BDISABL = &NRSTR(DISABLE(&DISABLE))
  IF &NRSTR(&CICS) = NONE THEN      /* IF KEYWORD NOT SPECIFIED      */+
     SET BCICS =                    /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* CICSCONNECTIONS ARE PRESENT   */+
     SET BCICS = &NRSTR(CICS(&CICS))
  IF &NRSTR(&IMSBMP) = NONE THEN    /* IF KEYWORD NOT SPECIFIED      */+
     SET BIMSBMP =                  /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* IMSCONNECTIONS ARE PRESENT    */+
     SET BIMSBMP = &NRSTR(IMSBMP(&IMSBMP))
  IF &NRSTR(&IMSMPP) = NONE THEN    /* IF KEYWORD NOT SPECIFIED      */+
     SET BIMSMPP =                  /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* IMSCONNECTIONS ARE PRESENT    */+
     SET BIMSMPP = &NRSTR(IMSMPP(&IMSMPP))
  IF &NRSTR(&DLIBATCH) = NONE THEN  /* IF KEYWORD NOT SPECIFIED      */+
     SET BDLIBATC =                 /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* DLIBATCHCONNS  ARE PRESENT    */+
     SET BDLIBATC = &NRSTR(DLIBATCH(&DLIBATCH))
  IF &NRSTR(&CACHESIZE) = NONE THEN /* IF KEYWORD NOT SPECIFIED      */+
    SET BCACHSZ =                   /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* CACHESIZE IS  SPECIFIED,SET IT*/+
    IF &DATATYPE(&CACHESIZE) = NUM  THEN /* IF IT IS NUMERIC         */+
       SET BCACHSZ = &NRSTR(CACHESIZE(&CACHESIZE))
    ELSE                            /* ERROR IN CACHESIZE KEYWORD    */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN CACHESIZE IS IT NOT NUMERIC            */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /*  REMEMBER THE ERROR           */
        WRITE &M751 CACHESIZE VALUE &CACHESIZE
      END                           /* END ERROR SETTING             */
  /*******************************************************************/
  /*                                                                 */
  /*                 DELIMIT KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES THE STRING DELIMITER USED WITHIN THE HOST LANGUAGE   */
  /*                                                                 */
  /*  PARMS:   DEFAULT, APOST, QUOTE                                 */
  /*  DEFAULT: DEFAULT                                               */
  /*******************************************************************/
  IF &SUBSTR(1,&DELIMIT)= D THEN    /* SYNTAX CHECK DELIMIT KEYWORD  */+
    SET &DELIMIT = DEFAULT          /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK OTHER KEYWORDS          */+
    IF &SUBSTR(1,&DELIMIT)= A THEN  /* IF DELIMIT IS APOST           */+
      SET &DELIMIT = APOST          /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* CHECK NO DELIMIT              */+
      IF &SUBSTR(1,&DELIMIT)= Q THEN   /* IF DELIMIT IS QUOTE        */+
        SET &DELIMIT = QUOTE        /* BE SURE KEYWORD IS EXACT      */
      ELSE                          /* THIS IS AN ERROR              */+
        DO                          /* ISSUE THE ERROR MESSAGE       */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN DELIMIT VALUE SPECIFIED              */
          /*---------------------------------------------------------*/
          SET &ERROR = 8            /* REMEMBER THE ERROR            */
          WRITE &M751 DELIMIT VALUE &DELIMIT
        END                         /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 SQLDELIM KEYWORD OPTION                         */
  /*                                                                 */
  /*  INDICATES THE APOSTSQL OR QUOTESQL PRECOMPILER OPTION          */
  /*                                                                 */
  /*  PARMS:   DEFAULT, APOSTSQL, QUOTESQL                           */
  /*  DEFAULT: DEFAULT                                               */
  /*******************************************************************/
  IF &SUBSTR(1,&SQLDELIM)= D THEN   /* SYNTAX CHECK SQLDELIM KEYWORD */+
    SET &SQLDELIM = DEFAULT         /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK OTHER VALUES            */+
    IF &SUBSTR(1,&SQLDELIM)= A THEN /* IF SQLDELIM IS APOST          */+
      SET &SQLDELIM = APOSTSQL      /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* CHECK NO SQLDELIM             */+
      IF &SUBSTR(1,&SQLDELIM)= Q THEN  /* IF SQLDELIM IS QUOTE       */+
        SET &SQLDELIM = QUOTESQL    /* SET EXACT KEYWORD             */
      ELSE                          /* THIS IS AN ERROR              */+
        DO                          /* ISSUE THE ERROR MESSAGE       */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN SQLDELIM VALUE SPECIFIED             */
          /*---------------------------------------------------------*/
          SET &ERROR = 8            /* REMEMBER THE ERROR            */
          WRITE &M751 SQLDELIM VALUE &SQLDELIM
        END                         /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 SQL KEYWORD OPTION                              */
  /*                                                                 */
  /*  INDICATES DB2 OR ALL PRECOMPILER OPTION                        */
  /*                                                                 */
  /*  PARMS:   DEFAULT, DB2, ALL                                     */
  /*  DEFAULT: DEFAULT                                               */
  /*******************************************************************/
  IF &SUBSTR(1,&SQL)= D OR          /* CHECK SQL DB2 PARAMETER       */+
     &SQL = DEFAULT THEN            /* CHECK FOR DEFAULT             */+
    SET &SQL = &STR()               /* PASS NULL TO PRECOMPILER      */
  ELSE                              /* CHECK OTHER VALUES            */+
    IF &SUBSTR(1,&SQL)= A THEN      /* CHECK FOR ALL                 */+
      SET &SQL = SQL(ALL)           /* SET SQL TO ALL                */
    ELSE                            /* CHECK NO SQLDELIM             */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN SQL VALUE SPECIFIED                    */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 SQL VALUE &SQL
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                   STDSQL KEYWORD OPTION                         */
  /*                                                                 */
  /*  INDICATES THE LEVEL OF ANSI SQL THAT IS BEING SUPPORTED        */
  /*  BY THE PRECOMPILER                                             */
  /*                                                                 */
  /*  PARMS:   NO (DB2 STANDARD), 86 (ANSI 86 LEVEL),                */
  /*           YES (ANSI 92 LEVEL)                                   */
  /*  DEFAULT: NO                                                    */
  /*******************************************************************/
  IF &SUBSTR(1,&STDSQL) = N THEN    /* SYNTAX CHECK STDSQL KEYWORD   */+
    SET &STDSQL = NO                /* BE SURE KEYWORD IS EXACT      */
  ELSE IF &SUBSTR(1:1,&STDSQL)= Y THEN /* IF STDSQL IS YES    PQ58938*/+
    SET &STDSQL = YES               /* SET EXACT KEYWORD      PQ58938*/
  ELSE                              /* CHECK OTHER VALUES            */+
    IF &SUBSTR(1:2,&STDSQL)= 86 THEN/* IF STDSQL IS 86               */+
      SET &STDSQL = 86              /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* BAD STDSQL                    */+
        DO                          /* ISSUE THE ERROR MESSAGE       */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN STDSQL VALUE SPECIFIED               */
          /*---------------------------------------------------------*/
          SET &ERROR = 8            /* REMEMBER THE ERROR            */
          WRITE &M751 STDSQL VALUE &STDSQL
        END                         /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 ISOLATION KEYWORD OPTION                        */
  /*                                                                 */
  /*  INDICATES THE EXTENT TO WHICH THE APPLICATION PROGRAM IS       */
  /*  TO BE ISOLATED FROM OTHER EXECUTING APPLICATION PROGRAMS       */
  /*                                                                 */
  /*  PARMS:   RR (REPEATABLE READ), CS (CURSOR STABILITY)           */
  /*           UR (UNCOMMITTED READ), RS (READ STABILITY)     PN75407*/
  /*  DEFAULT: CS                                               DK139*/
  /*******************************************************************/
  SET &PIERR = 0                    /* INIT ISOLATION ERROR   PN75407*/
  IF &SUBSTR(1,&ISOLATION)= R THEN  /* SYNTAX CHECK ISOLATION KEYWORD*/+
    DO                              /* MUST BE RR OR RS       PN75407*/
      IF &LENGTH(&ISOLATION) > 1 THEN /* AVOID SUBSTR ERRORS  PN75407*/+
        DO                          /* CHECK SYNTAX RR OR RS  PN75407*/
          IF &SUBSTR(1:2,&ISOLATION)= RR THEN /* OPERAND RR ? PN75407*/+
            SET &ISOLATION = RR     /* SET TO RR              PN75407*/
          ELSE                      /* CONTINUE CHECK         PN75407*/+
            IF &SUBSTR(1:2,&ISOLATION)= RS THEN /*OPER RS ?   PN75407*/+
              SET &ISOLATION = RS   /* SET TO RS              PN75407*/
            ELSE                    /* ERROR, MUST RR OR RS   PN75407*/+
              SET &PIERR = 8        /* REMEMBER THE ERROR     PN75407*/
        END                         /* CHECK COMPLETE RR/RS   PN75407*/
      ELSE                          /* MUST LEAST TWO CHARS   PN75407*/+
        SET &PIERR = 8              /* REMEMBER THE ERROR     PN75407*/
    END                             /* RR/RS COMPLETE         PN75407*/
  ELSE                              /* NOT RR/RS CONTINUE     PN75407*/+
    IF &SUBSTR(1,&ISOLATION)= U THEN   /* IF ISOLATION IS UR         */+
      SET &ISOLATION = UR           /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* CHECK NO ISOLATION            */+
      IF &SUBSTR(1,&ISOLATION)= C THEN /* IF ISOLATION IS CS         */+
        SET &ISOLATION = CS         /* BE SURE KEYWORD IS EXACT      */
  IF &PIERR = 8 THEN                /* SYNTAX ERRORS ?        PN75407*/+
    DO                              /* ISSUE ERROR MESSAGE    PN75407*/
      /*-------------------------------------------------------------*/
      /* DSNH751I: ERROR IN ISOLATION VALUE SPECIFIED         PN75407*/
      /*-------------------------------------------------------------*/
      SET &ERROR = &PIERR           /* TRANSFER TO DSNH ERROR PN75407*/
      WRITE &M751 ISOLATION VALUE &ISOLATION
    END                             /* END ERROR PROCESSING   PN75407*/
  /*******************************************************************/
  /*                                                                 */
  /*                 SPACEUN KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES THE TYPE OF UNIT FOR PSPACE AND WSPACE               */
  /*                                                                 */
  /*  PARMS:   TRACK, CYLINDER                                       */
  /*  DEFAULT: TRACK                                                 */
  /*******************************************************************/
  IF &SUBSTR(1,&SPACEUN)= T THEN    /* SYNTAX CHECK SPACEUN KEYWORD  */+
    SET &SPACEUN = TRACK            /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO SPACEUN              */+
    IF &SUBSTR(1,&SPACEUN)= C THEN  /* IF SPACEUN IS CYL             */+
      SET &SPACEUN = CYL            /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN SPACEUN VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 SPACEUN VALUE &SPACEUN
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 VALIDATE KEYWORD OPTION                         */
  /*                                                                 */
  /*  INDICATES TO BIND WHEN SQL STATEMENTS ARE TO BE VERIFIED       */
  /*                                                                 */
  /*  PARMS:   RUN, BIND                                             */
  /*  DEFAULT: RUN                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&VALIDATE)= R THEN   /* SYNTAX CHECK VALIDATE KEYWORD */+
    SET &VALIDATE= RUN              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO VALID                */+
    IF &SUBSTR(1,&VALIDATE)= B THEN /* IF VALIDATE IS BIND           */+
      SET &VALIDATE= BIND           /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN VALIDATE VALUE SPECIFIED               */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 VALIDATE VALUE &VALIDATE
      END                           /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 DYNAMICRULES KEYWORD OPTION                     */
  /*                                                                 */
  /*  DETERMINE AUTHORIZATION ID AT BIND TIME OR RUN TIME            */
  /*                                                                 */
  /*  PARMS:   RUN, BIND                                             */
  /*  DEFAULT: RUN                                                   */
  /*******************************************************************/
  IF &SUBSTR(1,&DYNAMICRULES) = R THEN /* SYNTAX CHECK KEYWD  KEP0478*/+
    SET &DYNAMICRULES = RUN        /* BE SURE KEYWORD IS EXACTKEP0478*/
  ELSE                              /* CHECK NO VALID         KEP0478*/+
    IF &SUBSTR(1,&DYNAMICRULES) = B THEN /* KEYWD VAL IS BIND KEP0478*/+
      SET &DYNAMICRULES = BIND     /* BE SURE KEYWORD IS EXACTKEP0478*/
    ELSE                            /* THIS IS AN ERROR       KEP0478*/+
      DO                            /* ISSUE ERROR MESSAGE      LI350*/
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN DYNAMICRULES VALUE SPECIFIED           */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR     KEP0478*/
        WRITE &M751 DYNAMICRULES VALUE &DYNAMICRULES        /*KEP0478*/
      END                           /* OF ERROR SETTING       KEP0478*/
  /*******************************************************************/
  /*                                                                 */
  /*               DBPROTOCOL KEYWORD OPTION                    LI350*/
  /*                                                            LI350*/
  /*  INDICATE DRDA OR PRIVATE PROTOCOLS                        LI350*/
  /*                                                            LI350*/
  /*  PARMS:   NONE, DRDA, PRIVATE                              LI350*/
  /*  DEFAULT: NONE                                             LI350*/
  /*******************************************************************/
  IF &STR(&DBPROTOCOL) ^= NONE THEN DO  /* KEYWORD SPECIFIED ?  LI350*/
   IF &SUBSTR(1,&DBPROTOCOL)= D THEN /* SPECIFY DRDA ?          LI350*/+
     SET &BDBPRO = &STR(DBPROTOCOL(DRDA))  /* SET DRDA          LI350*/
   ELSE                              /* CONTINUE CHECK          LI350*/+
     IF &SUBSTR(1,&DBPROTOCOL) = P THEN /* SPECIFY PRIVATE ?    LI350*/+
       SET &BDBPRO = &STR(DBPROTOCOL(PRIVATE)) /* SET PRIVATE   LI350*/
     ELSE                            /* THIS IS AN ERROR        LI350*/+
       DO                            /* ISSUE THE ERROR MESSAGE LI350*/
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN DBPROTOCOL VALUE SPECIFIED       LI350*/
         /*----------------------------------------------------------*/
         SET &BDBPRO = &STR()        /* SET KEYWORD NULL        LI350*/
         SET &ERROR = 8              /* REMEMBER THE ERROR      LI350*/
         WRITE &M751 DBPROTOCOL VALUE &DBPROTOCOL
       END                           /* END OF ERROR SETTING    LI350*/
  END                                /* DBPROTOCOL COMPLETE     LI350*/
  ELSE                               /* DBPROTOCOL IS NULL      LI350*/+
   SET &BDBPRO = &STR()              /* SET KEYWORD NULL        LI350*/
  /*******************************************************************/
  /*                                                            LI375*/
  /*               OPTHINT KEYWORD OPTION                       LI375*/
  /*                                                            LI375*/
  /*  INDICATE OPTHINT OPTIMIZATION HINT-ID                     LI375*/
  /*                                                            LI375*/
  /*  PARMS:   'Blank' or 'non-blank within quoted string'      LI375*/
  /*  DEFAULT: Blank                                            LI375*/
  /*******************************************************************/
  SET &QYERR = 0                     /* INIT OPTHINT ERROR      LI375*/
  IF &NRSTR(&OPTHINT) ^= THEN        /* OPTHINT SPECIFIED ?     LI375*/+
    DO                               /* PROCESS OPTHINT         LI375*/
      IF &SUBSTR(1,&NRSTR(&OPTHINT)) ^= &STR(') THEN  /* START  LI375*/+
        DO                           /* INSURE QUOTED STRING    LI375*/
          SET &OPTHINT = &STR(')&NRSTR(&OPTHINT) /* ADD         LI375*/
          SET &BQYE = &SYSINDEX(',&NRSTR(&OPTHINT),2) /* END    LI375*/
          IF &BQYE = 0 THEN          /* ENDING QUOTE ?          LI375*/+
            SET &OPTHINT = &NRSTR(&OPTHINT)&STR(') /* ADD       LI375*/
        END                          /* NOW QUOTED STRING       LI375*/
      IF &LENGTH(&NRSTR(&OPTHINT)) > 10 THEN /* > MAX LENGTH ?  LI375*/+
        SET &QYERR = 8               /* REMEMBER THE ERROR      LI375*/
      IF &QYERR ^= 0 THEN            /* ANY ERRORS ?            LI375*/+
        DO                           /* ISSUE THE ERROR MESSAGE LI375*/
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN OPTHINT VALUE SPECIFIED         LI375*/
          /*---------------------------------------------------------*/
          SET &BQYOPT = &STR()       /* SET KEYWORD NULL        LI375*/
          SET &ERROR = 8             /* REMEMBER THE ERROR      LI375*/
          WRITE &M751 OPTHINT VALUE &OPTHINT
        END                          /* END OF ERROR SETTING    LI375*/
      ELSE                           /* THIS IS AN ERROR        LI375*/+
        SET &BQYOPT = &NRSTR(OPTHINT(&OPTHINT)) /* KEYWORD      LI375*/
    END                              /* OPTHINT COMPLETE        LI375*/
  ELSE                               /* OPTHINT IS NONE         LI375*/+
    SET &BQYOPT = &STR()             /* SET KEYWORD NULL        LI375*/
                                                               /*<@10*/
  /*******************************************************************/
  /*                                                                 */
  /*               ENCODING KEYWORD OPTION                           */
  /*                                                                 */
  /*  INDICATE ENCODING OPTION FOR BIND PLAN                         */
  /*                                                                 */
  /*  PARMS:   ASCII|EBCDIC|UNICODE|ccsid or NONE                    */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &STR(&ENCODING) ^= NONE THEN         /* KEYWORD SPECIFIED ?     */+
    DO                                    /*   CHECK ENCODING        */
      IF &SUBSTR(1,&ENCODING)= A THEN         /* SPECIFY ASCII ?     */+
        SET &BENCOD = &STR(ENCODING(ASCII))   /*   SET ASCII         */
      ELSE IF &SUBSTR(1,&ENCODING) = E THEN   /* SPECIFY EBCDIC ?    */+
        SET &BENCOD = &STR(ENCODING(EBCDIC))  /*   SET EBCDIC        */
      ELSE IF &SUBSTR(1,&ENCODING) = U THEN   /* SPECIFY UNICODE ?   */+
        SET &BENCOD = &STR(ENCODING(UNICODE)) /*   SET UNICODE       */
      ELSE IF &DATATYPE(&ENCODING) = NUM THEN /* SPECIFY NUMERIC ?   */+
        SET &BENCOD = &NRSTR(ENCODING(&ENCODING))
      ELSE                                    /* THIS IS AN ERROR    */+
        DO                                    /*   ISSUE ERROR MSG   */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN ENCODING VALUE SPECIFIED             */
          /*---------------------------------------------------------*/
          SET &BENCOD = &STR()                /*   SET KEYWORD NULL  */
          SET &ERROR = 8                      /*   REMEMBER ERROR    */
          WRITE &M751 ENCODING VALUE &ENCODING
        END                                   /* END OF ERROR SETTING*/
    END                                   /*   ENCODING COMPLETE     */
  ELSE                                    /* ENCODING IS NULL        */+
    SET &BENCOD = &STR()                  /*   SET KEYWORD NULL      */
  /*******************************************************************/
  /*                                                                 */
  /*               IMMEDWRITE KEYWORD OPTION                         */
  /*                                                                 */
  /*  INDICATE IMMEDWRITE OPTION FOR BIND PLAN                       */
  /*                                                                 */
  /*  PARMS:   YES, NO, NONE                                         */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &STR(&IMMEDWRITE) ^= NONE THEN         /* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CHECK IMMEDWRITE    */
      IF &SUBSTR(1,&IMMEDWRITE)= Y THEN         /* SPECIFY YES ?     */+
        SET &BIMWRI = &STR(IMMEDWRITE(YES))     /*   SET YES         */
      ELSE IF &SUBSTR(1,&IMMEDWRITE) = N THEN   /* SPECIFY NO ?      */+
       SET &BIMWRI = &STR(IMMEDWRITE(NO))       /*   SET NO          */
      ELSE                                      /* THIS IS AN ERROR  */+
        DO                                      /*   ISSUE ERROR MSG */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN IMMEDWRITE VALUE SPECIFIED           */
          /*---------------------------------------------------------*/
          SET &BIMWRI = &STR()                  /*   SET KEYWORD NULL*/
          SET &ERROR = 8                        /*   REMEMBER ERROR  */
          WRITE &M751 IMMEDWRITE VALUE &IMMEDWRITE
        END                                     /* END OF ERROR      */
    END                                     /*   IMMEDWRITE COMPLETE */
  ELSE                                      /* IMMEDWRITE IS NULL    */+
    SET &BIMWRI = &STR()                    /*   SET KEYWORD NULL    */
                                                               /*>@10*/
  /**************************************************************<@09*/
  /*                                                                 */
  /*               PROGAUTH KEYWORD OPTION                           */
  /*                                                                 */
  /*  INDICATE PROGAUTH OPTION FOR BIND PLAN                         */
  /*                                                                 */
  /*  PARMS:   DISABLE, ENABLE, NONE                                 */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &STR(&PROGAUTH) ^= NONE THEN           /* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CHECK PROGAUTH      */
      IF &SUBSTR(1,&PROGAUTH)= D THEN           /* SPECIFY DISABLE ? */+
        SET &BPRAUT = &STR(PROGAUTH(DISABLE))   /*   SET DISABLE     */
      ELSE IF &SUBSTR(1,&PROGAUTH) = E THEN     /* SPECIFY ENABLE ?  */+
        SET &BPRAUT = &STR(PROGAUTH(ENABLE))    /*   SET ENABLE      */
      ELSE                                      /* THIS IS AN ERROR  */+
        DO                                      /*   ISSUE ERROR MSG */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN PROGAUTH VALUE SPECIFIED             */
          /*---------------------------------------------------------*/
          SET &BPRAUT = &STR()                  /*   SET KEYWORD NULL*/
          SET &ERROR = 8                        /*   REMEMBER ERROR  */
          WRITE &M751 PROGAUTH VALUE &PROGAUTH
        END                                     /* END OF ERROR      */
    END                                     /*   PROGAUTH COMPLETE   */
  ELSE                                      /* PROGAUTH IS NULL      */+
    SET &BPRAUT = &STR()                    /*   SET KEYWORD NULL    */
                                                               /*>@09*/
  /*******************************************************************/
  /*                                                                 */
  /*                 HOST KEYWORD OPTION                             */
  /*                                                                 */
  /*  DEFINES THE HOST LANGUAGE IN WHICH THE SQL STATEMENTS ARE      */
  /*  EMBEDDED                                                       */
  /*                                                                 */
  /*  PARMS:   COBOL   - OS/VA COBOL                                 */
  /*           COB2    - VS COBOL II                                 */
  /*           IBMCOB  - IBM COBOL COMPILER (OOCOBOL)           LI319*/
  /*           ASM     - HIGH LEVEL ASSEMBLER                        */
  /*           FORTRAN - VS FORTRAN                                  */
  /*           PLI     - OS PL/I OPTIMIZING COMPILER                 */
  /*           C       - 'C' PROGRAM COMPILER                        */
  /*           CPP     - C++ PROGRAM COMPILER                   LI319*/
  /*                                                                 */
  /*  DEFAULT: COBOL                                                 */
  /*******************************************************************/
  SET &CSYSM = &STR()               /* INITIALIZE SYSMSGS       LI319*/
  SET &PLINK = &STR()               /* INITIALIZE PRELINK       LI319*/
  SET &PLNKVD = NO                  /* ASSUME PRELINK INVALID   LI319*/
  SET &HOSTOK = NO                  /* ASSUME HOST PARM INVALID      */
  IF &STR(&HOST) = COB2 THEN        /* COBOL 2 ?                     */+
    SET &HOSTOK = YES               /* COB2 PROGRAM COMPILER    LI319*/
  IF &STR(&HOST) = C THEN           /* IF C PROGRAM COMPILER    LI319*/+
    DO                              /* PROCESS C                LI319*/
      /*-------------------------------------------------------------*/
      /* INDICATE HOST LANGUAGE IS 'C'                          LI319*/
      /*-------------------------------------------------------------*/
      SET &PLNKVD = YES             /* PRELINK SUPPORTED        LI319*/
      SET &PLINK  = &STR(&CCLINK)   /* PRELINK FOR 'C'          LI319*/
      SET &CSYSM  = &STR(&CCPMSGS)  /* SET SYSMSGS              LI319*/
      SET &HOSTOK = YES             /* INDICATE THAT GOOD PARM FOUND */
    END                             /* PROCESSING COMPLETE      LI319*/
  IF &LENGTH(&HOST) > 1 THEN        /* AVOID SUBSTR ERRORS      LI319*/+
    IF &SUBSTR(1:2,&STR(&HOST)) = CP THEN /* C++ COMPILER ?     LI319*/+
      DO                            /* PROCESS CPP              LI319*/
        /*-----------------------------------------------------------*/
        /* INDICATE HOST LANGUAGE IS C++                        LI319*/
        /*-----------------------------------------------------------*/
        SET &HOST = CPP             /* CPP PROGRAM COMPILER     LI319*/
        SET &PLNKVD = YES           /* PRELINK SUPPORTED        LI319*/
        SET &PLINK  = &STR(&CPPCLINK) /* PRELINK FOR 'C++'      LI319*/
        SET &CSYSM = &STR(&CPPPMSGS) /* SET SYSMSGS             LI319*/
        SET &HOSTOK = YES           /* INDICATE THAT GOOD PARM FOUND */
      END                           /* PROCESSING COMPLETE      LI319*/
  IF &SUBSTR(1,&STR(&HOST)) = I THEN /* IBMCOB COMPILER ?       LI319*/+
    DO                              /* PROCESS IBMCOB           LI319*/
      /*-------------------------------------------------------------*/
      /* INDICATE HOST LANGUAGE IS OOCOBOL                      LI319*/
      /*-------------------------------------------------------------*/
      SET &HOST = IBMCOB            /* IBMCOB PROGRAM COMPILER  LI319*/
      SET &PLNKVD = YES             /* PRELINK SUPPORTED        LI319*/
      SET &PLINK  = &STR(&COBIPLNK) /* PRELINK FOR IBMCOB       LI319*/
      SET &CSYSM = &STR(&COBIPMSG)  /* SET SYSMSGS              LI319*/
      SET &HOSTOK = YES             /* INDICATE THAT GOOD PARM FOUND */
    END                             /* PROCESSING COMPLETE      LI319*/
  IF &SUBSTR(1,&STR(&HOST)) = A THEN /* ASSEMBLER ?             LI319*/+
    DO                              /* PROCESS ASM              LI319*/
      /*-------------------------------------------------------------*/
      /* INDICATE HOST LANGUAGE IS HIGH LEVEL ASSEMBLER (ASM)   LI319*/
      /*-------------------------------------------------------------*/
      SET &HOST = ASM               /* ASM PROGRAM COMPILER     LI319*/
      SET &HOSTOK = YES             /* INDICATE THAT GOOD PARM FOUND */
    END                             /* ASM PROCESSING COMPLETE  LI319*/
  IF &LENGTH(&HOST) > 3 THEN        /* AVOID SUBSTR ERRORS ON NEXT 1 */+
    IF &SUBSTR(1:4,&STR(&HOST)) = COBO THEN  /* COBOL?               */+
      DO
        /*-----------------------------------------------------------*/
        /* INDICATE HOST LANGUAGE IS COBOL                           */
        /*-----------------------------------------------------------*/
        SET &HOST = COBOL           /* ALLOW MINIMUM ABBREVIATION    */
        SET &HOSTOK = YES           /* INDICATE THAT GOOD PARM FOUND */
      END
  IF &SUBSTR(1,&STR(&HOST)) = P THEN   /* PL/I?                      */+
    DO
      /*-------------------------------------------------------------*/
      /* INDICATE HOST LANGUAGE IS PLI                               */
      /*-------------------------------------------------------------*/
      SET &HOST = PLI               /* ALLOW MINIMUM ABBREVIATION    */
      IF &PLITYPE = PLIENT THEN     /* ENTERPRISE PL/I: DO PLKED +@02*/+
        DO
          SET &PLNKVD = YES           /* PRELINK SUPPORTED           */
          SET &PLINK  = &STR(&PLIPLNK)/* PRELINK FOR ENTERPRISE PL/I */
          SET &CSYSM = &STR(&PLIPMSG) /* SET SYSMSGS                 */
        END                                                    /*-@02*/
      SET &HOSTOK = YES             /* INDICATE THAT GOOD PARM FOUND */
    END
  IF &SUBSTR(1,&STR(&HOST)) = F THEN   /* FORTRAN?                   */+
    DO
      /*-------------------------------------------------------------*/
      /* INDICATE HOST LANGUAGE IS FORTRAN                           */
      /*-------------------------------------------------------------*/
      SET &HOST = FORTRAN           /* ALLOW MINIMUM ABBREVIATION    */
      SET &HOSTOK = YES             /* INDICATE THAT GOOD PARM FOUND */
      IF &ATTACH = IMS OR           /* FORTRAN AND IMS OR            */+
         &ATTACH = CICS THEN        /* CICS IS NOT SUPPORTED         */+
        DO                          /* GENERATE ERROR MESSAGE        */
          /*---------------------------------------------------------*/
          /* DSNH758I: HOST FORTRAN NOT PERMITTED WITH RUN IMS/CICS  */
          /*---------------------------------------------------------*/
          WRITE DSNH758I HOST(FORTRAN) IS NOT +
                         PERMITTED WITH RUN(IMS) OR RUN(CICS)
          SET &ERROR = 8            /* NOTE THE ERROR                */
        END                         /* NOTE THE INVALID LANG/ATT     */
    END
  IF &STR(&HOSTOK) = NO THEN        /* IF NO VALID LANGUAGE IN HOST  */+
    DO                              /* PARM ISSUE ERROR MESSAGE      */
      /*-------------------------------------------------------------*/
      /* DSNH751I: ERROR IN HOST VALUE SPECIFIED                     */
      /*-------------------------------------------------------------*/
      SET &ERROR = 8                /* REMEMBER THE ERROR            */
      WRITE &M751 HOST VALUE &HOST
    END                             /* OF ERROR SETTING              */
  SET &SUFF = &HOST                 /* SET THE PROPER SUFFIX         */
  IF &HOST = COB2 THEN              /* IF HOST IS COB2               */+
    SET &SUFF = COBOL               /* SET THE PROPER SUFFIX         */
  /*-----------------------------------------------------------------*/
  /* VALIDATE HOST LANGUAGE AND PRELINK OPTION                       */
  /*-----------------------------------------------------------------*/
  IF &PRELINK = YES AND             /* IF PRELINK REQUESTED AND LI319*/+
    &PLNKVD = NO THEN               /* PRELINK NOT SUPPORTED    LI319*/+
    DO                              /* PRELINK AND VALID LANHUAGE    */
      /*-------------------------------------------------------------*/
      /* DSNH760I: PRELINK OPTION INVALID WITH HOST LANGUAGE         */
      /*-------------------------------------------------------------*/
      WRITE DSNH760I PRELINK OPTION INVALID WITH HOST +
                     LANGUAGE &HOST
      SET &ERROR = 4                /* WARN THE USER          PQ19126*/
      SET &PRELINK = NO             /* BYPASS PRELINK STEP    PQ19126*/
    END                             /* OF ERROR SETTING              */
  /*-----------------------------------------------------------------*/
  /* SUPPRESS DUAL LISTINGS FOR PLI AND ASM                          */
  /*-----------------------------------------------------------------*/
  IF (&PRINT = TERM AND &TERM = TERM)  /* SUPPRESS DUAL LISTINGS FOR */+
      AND (&SUFF = PLI OR &SUFF= ASM)  /* PLI AND ASM                */+
    THEN SET &TERM = NONE           /* TURN OFF THE TERM COPY        */
  /*******************************************************************/
  /*                                                                 */
  /*                 PASS KEYWORD OPTION                             */
  /*                                                                 */
  /*  INDICATE THE NUMBER OF PASSES THE PRECOMPILER IS TO USE        */
  /*                                                                 */
  /*  PARMS:   1/ONE, 2/TWO                                          */
  /*  DEFAULT: DEFAULT                                               */
  /*           PLI - 1/ONE                                           */
  /*           ASM - 2/TWO                                           */
  /*           COBOL/FORTRAN - PASS N/A - FORCED 1/ONE               */
  /*******************************************************************/
  IF &SUBSTR(1,&PASS) = D THEN      /* SYNTAX CHECK PASS KEYWORD     */+
    SET &PASS = DEFAULT             /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK OTHER PASS KEYWORDS     */+
    IF &SUBSTR(1,&PASS) = O OR      /* IF PASS IS O OR ONE           */+
       &SUBSTR(1,&PASS) = 1 THEN    /* IF PASS IS 1                  */+
      SET &PASS = ONE               /* BE SURE KEYWORD IS EXACT      */
      ELSE                          /* CHECK ASM PASS                */+
        IF &SUBSTR(1,&PASS) = T OR  /* IF PASS IS TWO                */+
           &SUBSTR(1,&PASS) = 2 THEN   /* IF PASS IS TWO             */+
          SET &PASS = TWO           /* BE SURE KEYWORD IS EXACT      */
        ELSE                        /* THIS IS AN ERROR              */+
          DO                        /* ISSUE THE ERROR MESSAGE       */
            /*-------------------------------------------------------*/
            /* DSNH751I: ERROR IN PASS VALUE SPECIFIED               */
            /*-------------------------------------------------------*/
            SET &ERROR = 8          /* REMEMBER THE ERROR            */
            WRITE &M751 PASS VALUE &PASS
          END                       /* OF ERROR SETTING              */
  /*******************************************************************/
  /*                                                                 */
  /*                 LOPTION KEYWORD OPTION                          */
  /*                                                                 */
  /*  DEFINE LIST OF LINKEDIT OPTIONS                                */
  /*                                                                 */
  /*  PARMS:   OS/VS LINKAGE EDITOR AND LOADER                       */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &NRSTR(&LOPTION) = NONE THEN   /* SYNTAX CHECK LOPTION KEYWORD  */-
    SET &LOPTION =                  /* REMOVE ALL TEXT               */
  /*******************************************************************/
  /*                                                                 */
  /*                 POPTION KEYWORD OPTION                          */
  /*                                                                 */
  /*  DEFINE LIST OF PRE-LINKEDIT OPTIONS                            */
  /*                                                                 */
  /*  PARMS:   DEFINED BY 'C' COMPILER LANGUAGE                      */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &POPTION = NONE THEN               /* IF POPTION IS NONE        */+
    SET &POPTION =                      /* REMOVE ALL TEXT           */
  ELSE                                  /* POPTION SPECIFIED         */+
    IF &SUBSTR(1,&POPTION) = &STR(') THEN /* QUOTED STRING ?         */+
      SET &POPTION = &STR(&SUBSTR(2:&LENGTH(&POPTION)-1,&POPTION))
  /*******************************************************************/
  /*                                                                 */
  /*                 FLAG KEYWORD OPTION                             */
  /*                                                                 */
  /*  INDICATE MESSAGES TO BE DISPLAYED                              */
  /*                                                                 */
  /*  PARMS:   I - INFORMATIONAL (INCLUDES W, E AND C)               */
  /*           W - WARNING, ERROR, AND SEVERE ERROR                  */
  /*           E - ERROR, AND SEVERE ERROR                           */
  /*           S - SEVERE ERROR                                      */
  /*  DEFAULT: I                                                     */
  /*******************************************************************/
  IF &FLAG ^= I AND                 /* IF FLAG ISN'T INFORMATION     */+
     &FLAG ^= W AND                 /* IF FLAG ISN'T WARNING         */+
     &FLAG ^= E AND                 /* IF FLAG ISN'T ERROR           */+
     &FLAG ^= S THEN                /* IF FLAG ISN'T SEVERE          */+
    DO                              /* ISSUE THE ERROR MESSAGE       */
      /*-------------------------------------------------------------*/
      /* DSNH751I: ERROR IN FLAG VALUE SPECIFIED                     */
      /*-------------------------------------------------------------*/
      SET &ERROR = 8                /* REMEMBER THE ERROR            */
      WRITE &M751 FLAG VALUE &FLAG
    END                             /* OF ERROR SETTING              */
  SET &FLAGB = &FLAG                /* SET UP THE BIND FLAG          */
  IF &FLAG = S THEN                 /* IF FLAG IS SEVERE             */+
    SET &FLAGB = E                  /* SET UP THE BIND FLAG          */
  /*******************************************************************/
  /*                                                                 */
  /*                 INPUT KEYWORD OPTION                            */
  /*                                                                 */
  /*  SPECIFY DATA SET NAME THAT CONTAINS HOST LANGUAGE SOURCE       */
  /*                                                                 */
  /*  PARMS:   DATA SET NAME(MEMBER)                                 */
  /*  DEFAULT: REQUIRED                                              */
  /*******************************************************************/
  DO WHILE &INPUT = NONE OR &INPUT =   /* GET INPUT PARM; IS REQUIRED*/
    /*---------------------------------------------------------------*/
    /* DSNH752I: INPUT DATA SET NAME IS MISSING                      */
    /*---------------------------------------------------------------*/
    WRITE DSNH752I INPUT DATA SET NAME IS MISSING OR NONE
    IF &ERROR LT &RCTERM THEN       /* IF THERE IS NO OTHER ERROR    */+
      DO                            /* PROMPT FOR A NAME             */
        /*-----------------------------------------------------------*/
        /* DSNH753I: ENTER INPUT DATA SET NAME                       */
        /*-----------------------------------------------------------*/
        WRITE DSNH753I ENTER INPUT DATA SET NAME
        READ &INPUT                 /* GET THE ANSWER                */
      END                           /* OF PROMPTING FOR A NAME       */
    ELSE SET &INPUT = ERROR         /* END THE LOOP ANYWAY           */
  END
  /*******************************************************************/
  /*                                                                 */
  /*                 OUTNAME KEYWORD OPTION                          */
  /*                                                                 */
  /*  SPECIFY PREFIX FOR INTERMEDIATE DATA SET NAMES                 */
  /*                                                                 */
  /*  PARMS:   STRING                                                */
  /*  DEFAULT: TEMP                                                  */
  /*******************************************************************/
  SET &J = 1                        /* INIT THE INDEX                */
  DO WHILE &J LE &LENGTH(&STR(&OUTNAME))  /* LOOK AT INPUT           */+
     AND &ERROR = 0                       /* AND NO ERROR YET        */
    /*---------------------------------------------------------------*/
    /* INSURE NAME CONTAINS NO SPECIAL CHARACTERS                    */
    /*---------------------------------------------------------------*/
    IF &SUBSTR(&J,&OUTNAME) NE &STR(.) AND   /* PERIOD IS OK         */+
      &SUBSTR(&J,&OUTNAME) NE &STR($) AND    /* DOLLAR IS OK         */+
      &SUBSTR(&J,&OUTNAME) NE &STR(#) AND    /* POUND IS OK          */+
      &SUBSTR(&J,&OUTNAME) NE &STR(@) AND    /* AT SIGN IS OK        */+
      &SUBSTR(&J,&OUTNAME) < &STR(A) THEN    /* OTHERWISE NOT        */+
      DO                                     /* YES, NOTE THE END    */
        /*-----------------------------------------------------------*/
        /* DSNH754I: OUTNAME MUST NOT CONTAIN SPECIAL CHARACTERS     */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8                       /* YES, NOTE THE ERROR  */
        SET &TEMP = &STR(MUST NOT CONTAIN SPECIAL CHARACTERS)
        WRITE DSNH754I DSNH OUTNAME PARAMETER &OUTNAME &TEMP
      END                                 /* YES, NOTE THE END       */
    SET &J = &J + 1                       /* BUMP THE SUBSCRIPT      */
  END                                     /* START OF MEMBER IS SET  */
  /*-----------------------------------------------------------------*/
  /* DETERMINE IF OUTNAME WILL CAUSE INPUT DATA SET NAME TO BE       */
  /* OVERWRITTEN, OR DELETED. IF INPUT DATA SET NAME ENCLOSED IN     */
  /* APOSTROPHIES, THEN USER MAY HAVE INCLUDED USERID PREFIX         */
  /* AS DATA SET QUALIFIER.                                          */
  /*-----------------------------------------------------------------*/
  SET &OUCHK = &STR(&SYSPREF..&OUTNAME) /* USERID PREFIX TO OUTNAME  */
  IF &SUBSTR(1,&INPUT) NE &STR(') THEN /* INPUT NOT ENCLOSED APOSTS  */+
    SET &INCHK = &STR(&SYSPREF..&INPUT) /* USERID PREFIX TO INPUT    */
  ELSE                                 /* INPUT NOT ENCLOSED APOSTS  */+
    SET &INCHK = &SUBSTR(2:&LENGTH(&STR(&INPUT))-1,&INPUT)
  IF &SYSINDEX(&OUCHK,&STR(&INCHK)) = 1 THEN   +
    IF &LENGTH(&STR(&INCHK)) EQ &LENGTH(&STR(&OUCHK)) OR +
       &SYSINDEX(&OUCHK&STR(.),&STR(&INCHK)) = 1 THEN +
      DO
        /*-----------------------------------------------------------*/
        /* DSNH755I: OUTNAME MUST NOT BEGIN THE SAME AS INPUT NAME   */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8               /* YES, NOTE THE ERROR          */
        SET &TEMP = &STR(DSNH755I OUTNAME PARAMETER &OUCHK)
        WRITE &TEMP MUST NOT BEGIN THE SAME AS INPUT &INCHK
      END
  /*******************************************************************/
  /*                                                                 */
  /*                 PRINT KEYWORD OPTION                            */
  /*                                                                 */
  /*  INDICATES WHERE TO SEND PRINTED OUTPUT                         */
  /*                                                                 */
  /*  PARMS:   NONE   - OMITS PRINTED OUTPUT                         */
  /*           TERM   - SENDS OUTPUT TO TERMINAL                     */
  /*           LEAVE  - SENDS OUTPUT TO SPECIFIED SYSPRINT DATA SET  */
  /*           DSNAME - SPECIFIES THE DATA SET TO BE USED FOR OUTPUT */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  SET &J = 1                              /* INIT THE INDEX          */
  DO WHILE &J LE &LENGTH(&STR(&PRINT))    /* LOOK AT PRINT           */+
     AND &ERROR = 0                       /* FIND AN ERROR           */
    /*---------------------------------------------------------------*/
    /*  INSURE PRINT DSNAME CONTAINS NO SPECIAL CHARACTERS           */
    /*---------------------------------------------------------------*/
    IF &SUBSTR(&J,&PRINT) NE &STR(.) AND  /* PERIOD IS OK            */+
      &SUBSTR(&J,&PRINT) NE &STR($) AND   /* DOLLAR IS OK            */+
      &SUBSTR(&J,&PRINT) NE &STR(#) AND   /* POUND IS OK             */+
      &SUBSTR(&J,&PRINT) NE &STR(@) AND   /* AT SIGN IS OK           */+
      &SUBSTR(&J,&PRINT) < &STR(A) THEN   /* OTHERWISE NOT           */+
      DO                                  /* YES, NOTE THE END       */
        /*-----------------------------------------------------------*/
        /* DSNH756I: PRINT NAME MUST NOT CONTAIN SPECIAL CHARACTERS  */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8                    /* YES, NOTE THE ERROR     */
        SET &TEMP1= &STR(DSNH PRINT PARAMETER)
        SET &TEMP2= &STR(MUST NOT CONTAIN SPECIAL CHARACTERS)
        WRITE DSNH756I &TEMP1 &PRINT &TEMP2
      END                                 /* YES, NOTE THE END       */
    SET &J = &J + 1                       /* BUMP THE SUBSCRIPT      */
  END                                     /* LOOK AT PRINT NAME      */
  /*******************************************************************/
  /*                                                                 */
  /*               EXAMINE INPUT SOURCE DATA SET NAME                */
  /*                                                                 */
  /* CHECK FOR APOSTROPHES, SUFFIX, AND MEMBER NAME SPECIFIED        */
  /*                                                                 */
  /* IF NAME NOT ENCLOSED IN APOSTROPHIES, AND SUFFIX SPECIFIED,     */
  /* AND SUFFIX NOT ALREADY APPENDED, THEN ADD SUFFIX TO DATA SET:   */
  /*                                                                 */
  /* - DATA-SET-NAME.SUFFIX                                          */
  /* - DATA-SET-NAME.SUFFIX(MEMBER)                                  */
  /*******************************************************************/
  SET &PRECIN = &INPUT                 /* INPUT FOR PRECOMPILER      */
  SET J = &SYSINDEX(&LPAR,&SYSNSUB(1,&INPUT))
  SET JEND = &SYSINDEX(&RPAR,&SYSNSUB(1,&INPUT))
  IF (&J > 0 AND &JEND = 0) OR         /* LEFT PAREN AND NO RIGHT    */+
     (&J = 0 AND &JEND > 0) THEN       /* NO LEFT PAREN BUT RIGHT    */+
    DO                                 /* SETUP DSNH750I ERROR MSG   */
      /*-------------------------------------------------------------*/
      /* DSNH750I: INVALID DATA SET NAME (MEMBER)                    */
      /*-------------------------------------------------------------*/
      SET &ERROR = 8                   /* NOTE THE ERROR             */
      WRITE DSNH750I INVALID DATA SET: INPUT &INPUT
    END                                /* DSNH750I COMPLETE          */
  ELSE                                 /* NO DATA SET ERRORS         */+
    DO                                 /* PROCESS DATA SET NAME      */
      /*-------------------------------------------------------------*/
      /*  OBTAIN MEMBER NAME FOR DATA SET                            */
      /*-------------------------------------------------------------*/
      IF &J > 0 THEN                   /* LEFT PAREN SPECIFIED       */+
        DO                             /* BOTH INPUT AND OUTPUT      */
          /*---------------------------------------------------------*/
          /*  MEMBER NAME ENCLOSED IN PARENS: DATA SET.(MEMBER)      */
          /*  CHECK FOR APOSTROPHIED DATA SET NAME AND SUFFIX        */
          /*---------------------------------------------------------*/
          SET &MEMBER = &SUBSTR(&J+1:&JEND-1,&INPUT)   /* SET MEMBER */
          IF &SUBSTR(1,&INPUT) NE &STR(') AND          /* IF NO APOST*/+
            &SUFFIX EQ YES THEN        /* AND WE ARE TO SUFFIX       */+
            DO                         /* THEN SUFFIX IT             */
              /*-----------------------------------------------------*/
              /*  ADD SUFFIX: DATA SET.SUFFIX(MEMBER)                */
              /*-----------------------------------------------------*/
              IF &J LE &LENGTH(&STR(&SUFF)) +1 THEN     /* TOO SHORT */+
                SET &PRECIN = &SUBSTR(1:&J-1,&INPUT).&SUFF(&MEMBER)
              ELSE                          /* WE CAN COMPARE NAMES  */+
                IF &SUBSTR(&J-&LENGTH(&STR(&SUFF))-1:&J-1,&INPUT)      +
                  NE &STR(.)&SUFF THEN     /* NOT .SUFF ALREADY      */+
                  SET &PRECIN = &SUBSTR(1:&J-1,&INPUT).&SUFF(&MEMBER)
            END                        /* THEN SUFFIX IT             */
        END                            /* OF MEMBER NAME SUPPLIED    */
      ELSE                             /* NAME NOT SUPPLIED          */+
        DO                             /* BUILD A MEMBER NAME        */
          /*---------------------------------------------------------*/
          /*  CHECK FOR APOSTROPHIED DATA SET NAME AND SUFFIX        */
          /*---------------------------------------------------------*/
          IF &SUBSTR(1,&INPUT) NE &STR(') AND /* NOT APOST NAME      */+
            &SUFFIX = YES THEN         /* AND WE SHOULD SUFFIX       */+
            DO                         /* ADD .SUFF TO THE NAME      */
              /*-----------------------------------------------------*/
              /*  DATA SET NAME NOT ENCLOSED IN APOSTROPHIES         */
              /*  ADD SUFFIX: DATA SET.SUFFIX                        */
              /*-----------------------------------------------------*/
              IF &LENGTH(&STR(&INPUT)) LE &LENGTH(&STR(&SUFF)) THEN    +
                SET &PRECIN = &INPUT..&SUFF   /* JUST ADD .SUFF      */
              ELSE                     /* CHECK NAME FOR .SUFF       */+
                IF &SUBSTR(&LENGTH(&STR(&INPUT))-                      +
                   &LENGTH(&STR(&SUFF)):&LENGTH(&STR(&INPUT)),&INPUT)  +
                   NE &STR(.)&SUFF THEN        /* NOT .SUFF NOW      */+
                  SET &PRECIN = &INPUT..&SUFF /* ADD .SUFF           */
            END                        /* ADD .SUFF TO THE NAME      */
          /*---------------------------------------------------------*/
          /* INSURE MEMBER NAME LENGTH NOT GREATER THAN MAXIMUM      */
          /*---------------------------------------------------------*/
          SET &INLEN = &LENGTH(&STR(&INPUT))  /* LENGTH OF INPUT     */
          IF &INLEN > 8 THEN                  /* MAX LEN MEMBER      */+
            SET &INLEN = 8             /* MAX LEN MEMBER             */
          SET &K = 1                   /* START OF MEMBER            */
          IF &SUBSTR(1,&INPUT) = &STR(') THEN /* APOST DSNAME?       */+
            DO                         /* START MEMBER SEARCH        */
              /*-----------------------------------------------------*/
              /*  SCAN FOR PERIOD (.) IN APOSTROPHIED DATA SET NAME  */
              /*-----------------------------------------------------*/
              SET &K = 2               /* DEFAULT, NOT FOUND         */
              SET &J = 2               /* START PERIOD SEARCH        */
              SET &DONE = 0            /* FLAG PERIOD SEARCH         */
              DO WHILE &J LT &LENGTH(&STR(&INPUT))  /* IN INPUT      */+
                AND &J-&K LE &INLEN AND             /* LOOK FOR (.)  */+
                &DONE = 0              /* FOUND OR END               */
                /*---------------------------------------------------*/
                /*  SAVE LOCATION OF PERIOD (.) IN DATA SET NAME     */
                /*---------------------------------------------------*/
                IF '&SUBSTR(&J,&INPUT)'='&STR(.)' THEN  /* PERIOD?   */+
                  SET &DONE = 1         /* END OF PERIOD SEARCH      */
                ELSE                    /* NOT A PERIOD              */+
                  SET &J = &J + 1       /* KEEP LOOKING              */
              END                       /* OF PERIOD SEARCH          */
              IF &DONE = 1 THEN         /* PERIOD WAS FOUND          */+
                SET &K = &J + 1         /* GET PAST 1ST QUAL         */
            END                         /* OF MEMBER SEARCH          */
          /*---------------------------------------------------------*/
          /*  CONTINUE SCAN FOR DATA SET MEMBER NAME                 */
          /*---------------------------------------------------------*/
          SET &J = &K                   /* MAX LEN FOR MEMBER        */
          SET &DONE = 0                 /* NOTE AT END MEMBER        */
          DO WHILE &J LE &LENGTH(&STR(&INPUT))      /* LOOK AT INPUT */+
             AND &J-&K LT &INLEN        /* FOR MAXIMUM MEMBER LENGTH */+
             AND &DONE = 0              /* AND NOT AT END            */
             /*------------------------------------------------------*/
             /*  SCAN FOR BEGINNING OF DATA SET MEMBER NAME: . ' (   */
             /*------------------------------------------------------*/
             IF  '&SUBSTR(&J,&INPUT)' = '&STR(.)'   /* AVOID PERIOD  */+
               OR &SUBSTR(&J,&INPUT)  = &STR(')     /* AVOID APOST   */+
               OR '&SUBSTR(&J,&INPUT)' = '('        /* AVOID PAREN   */+
               THEN SET &DONE = 1       /* END OF THE SEARCH         */
             ELSE                       /* OTHERWISE                 */+
               SET &J = &J + 1          /* BUMP THE SUBSCRIPT        */
          END                           /* LENGTH OF MEMBER SET      */
          /*---------------------------------------------------------*/
          /* OBTAIN DATA SET MEMBER NAME                             */
          /* COULD BE (8) LEFTMOST CHARACTERS OF DATA SET NAME       */
          /*---------------------------------------------------------*/
          SET &MEMBER = &SUBSTR(&K:&J-1,&INPUT)  /* SET UP MEMBER    */
        END                                /* BUILD A MEMBER NAME    */
    END                                /* DATA SET NAME COMPLETE     */
  /*******************************************************************/
  /*                                                                 */
  /*                 PLAN KEYWORD OPTION                             */
  /*                                                                 */
  /*  IDENTIFIES THE APPLICATION NAME FOR BIND                       */
  /*                                                                 */
  /*  PARMS:   PLAN-NAME                                             */
  /*  DEFAULT: FIRST OF THESE CHOICES AVAILABLE:                     */
  /*           - MEMBER NAME OF INPUT DATA SET                       */
  /*           - LEFTMOST QUALIFIER OF THE INPUT DATA SET            */
  /*******************************************************************/
  IF &NRSTR(&PLAN)  = DEFAULT THEN     /* WE USE DEFAULT OUTPUT      */+
    SET &PLAN = &NRSTR(&MEMBER)        /* SAME AS THE MEMBER NAME    */
  ELSE                                 /* PLAN WAS SET BY INVOKER    */+
    IF &LENGTH(&NRSTR(&PLAN)) > 8 THEN /* CHECK THE LENGTH           */+
      DO                               /* TOO BIG, IT'S AN ERROR     */
        /*-----------------------------------------------------------*/
        /* DSNH757I: ERROR IN PLAN NAME LENGTH                       */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8                 /* NOTE THE ERROR             */
        WRITE DSNH757I ERROR IN PLAN NAME LENGTH &PLAN
      END                              /* OF ERROR PROCESSING        */
  /*******************************************************************/
  /*                                                                 */
  /*                 LOAD KEYWORD OPTION                             */
  /*                                                                 */
  /*  IDENTIFIES THE DATA SET NAME TO CONTAIN THE OUTPUT FROM THE    */
  /*  LINKAGE EDITOR (LOAD MODULE)                                   */
  /*                                                                 */
  /*  PARMS:   DATA SET NAME                                         */
  /*  DEFAULT: RUNLIB.LOAD                                           */
  /*           MEMBER EITHER SPECIFIED, OR DEFAULTED TO MEMBER NAME  */
  /*           FROM INPUT DATA SET                                   */
  /*******************************************************************/
  SET &LOADIT = &LOAD                  /* LOAD MODULE TO USE         */
  SET J = &SYSINDEX(&LPAR,&SYSNSUB(1,&LOAD))
  SET JEND = &SYSINDEX(&RPAR,&SYSNSUB(1,&LOAD))
  IF (&J > 0 AND &JEND = 0) OR         /* LEFT PAREN AND NO RIGHT    */+
     (&J = 0 AND &JEND > 0) THEN       /* NO LEFT PAREN BUT RIGHT    */+
    DO                                 /* SETUP DSNH750I ERROR MSG   */
      /*-------------------------------------------------------------*/
      /* DSNH750I: INVALID DATA SET NAME (MEMBER)                    */
      /*-------------------------------------------------------------*/
      SET &ERROR = 8                   /* NOTE THE ERROR             */
      WRITE DSNH750I INVALID DATA SET: LOAD &LOAD
    END                                /* DSNH750I COMPLETE          */
  ELSE                                 /* NO DATA SET ERRORS         */+
    DO                                 /* PROCESS LOAD DATA SET      */
      IF &J > 0 THEN                   /* SET UP THE MEMBER          */+
        SET &LMEM = &SUBSTR(&J+1:&JEND-1,&LOAD)   /* SET MEMBER      */
      ELSE                             /* BUILD A MEMBER NAME        */+
        DO                             /* BUILD A MEMBER NAME        */
          /*---------------------------------------------------------*/
          /* DEFAULT LOAD MODULE NAME TO INPUT DATA SET MEMBER NAME  */
          /*---------------------------------------------------------*/
          SET &LOADIT = &LOAD.(&MEMBER) /* BUILD LINK NAME        */
          IF &SUBSTR(1,&LOAD) = &STR(') THEN  /* IF APOSTED, ADD MEM */+
            SET &LOADIT=&SUBSTR(1:&LENGTH(&LOAD)-1,&LOAD)+
                (&MEMBER)&STR(')
          SET &LMEM = &MEMBER          /* USE STANDARD MEMBER NAME   */
        END                            /* BUILD A MEMBER NAME        */
    END                                /* LOAD DATA SET COMPLETE     */
  /*******************************************************************/
  /*                                                                 */
  /*                 DBRMLIB KEYWORD OPTION                          */
  /*                                                                 */
  /*  IDENTIFIES THE DATA SET TO CONTAIN THE DBRM MEMBER             */
  /*                                                                 */
  /*  PARMS:   DATA SET NAME                                         */
  /*  DEFAULT: OUTNAME-KEYWORD-STRING.DBRMLIB                        */
  /*******************************************************************/
  SET &DBRMINP = &STR(&DBRMLIB)        /* SAVE THE NAME AS INPUT     */
  IF &STR(&DBRMLIB) = DEFAULT THEN     /* DEFAULT THE DBRMLIB        */+
    DO                                 /* ALLOCATE THE DBRMLIB       */
      /*-------------------------------------------------------------*/
      /* SET DBRMLIB TO DEFAULT: OUTNAME.DBRMLIB                     */
      /*-------------------------------------------------------------*/
      SET &DBRMLIB  = &OUTNAME..DBRM   /* LIBRARY NAME               */
      SET &DBRMNAME = &OUTNAME..DBRM(&MEMBER)   /* BUILD NAME        */
      SET &DMEM = &NRSTR(&MEMBER)      /* USE THE STD MEMBER NAME    */
    END                                /* ALLOCATE THE DBRMLIB       */
  ELSE                                 /* USE PROVIDED DBRMLIB       */+
    DO                                 /* BUILD NAME, ALLOC          */
      /*-------------------------------------------------------------*/
      /* DETERMINE IF MEMBER NAME WAS SPECIFIED IN DATA SET NAME     */
      /*-------------------------------------------------------------*/
      SET J = &SYSINDEX(&LPAR,&SYSNSUB(1,&DBRMLIB))
      SET JEND = &SYSINDEX(&RPAR,&SYSNSUB(1,&DBRMLIB))
      IF (&J > 0 AND &JEND = 0) OR     /* LEFT PAREN AND NO RIGHT    */+
         (&J = 0 AND &JEND > 0) THEN   /* NO LEFT PAREN BUT RIGHT    */+
        DO                             /* SETUP DSNH750I ERROR MSG   */
          /*---------------------------------------------------------*/
          /* DSNH750I: INVALID DATA SET NAME (MEMBER)                */
          /*---------------------------------------------------------*/
          SET &ERROR = 8               /* NOTE THE ERROR             */
          WRITE DSNH750I INVALID DATA SET: DBRMLIB &DBRMLIB
        END                            /* DSNH750I COMPLETE          */
      ELSE                             /* NO DATA SET ERRORS         */+
        DO                             /* PROCESS DATA SET NAME      */
          SET JSL = &SYSINDEX(/,&SYSNSUB(1,&DBRMLIB))
          SET TL = &LENGTH(&STR(&DBRMLIB))
          IF &J > 0 THEN               /* MEMBER IS ALREADY PRESENT  */+
            DO                         /* REMEMBER FOR BIND @BA31086 */
              /*-----------------------------------------------------*/
              /* USE DBRMLIB MEMBER NAME SPECIFIED IN DATA SET       */
              /*-----------------------------------------------------*/
              SET &DMEM = &SUBSTR(&J+1:&JEND-1,&STR(&DBRMLIB))
              SET &DBRMNAME=&STR(&DBRMLIB) /* JUST USE DBRMLIB NAME  */
            END                        /* MEMBER NOTED  @BA31086     */
          ELSE                         /* NO MEMBER, ADD ONE         */+
            DO                         /* ADD MEMBER TO DBRMLIB      */
              /*-----------------------------------------------------*/
              /* DEFAULT DBRM MEMBER NAME TO INPUT MEMBER NAME       */
              /*-----------------------------------------------------*/
              IF &JSL = 0 THEN         /* NO PASSWORD PRESENT        */+
                SET &DBRMNAME=         /* NO ' PRESENT               */+
                    &STR(&DBRMLIB.(&MEMBER))
              ELSE                     /* PASSWORD IS THERE          */+
                SET DBRMNAME=          /* PASSWORD PROVIDED          */+
                    &SUBSTR(1:&JSL-1,&STR(&DBRMLIB))+
                    &STR((&MEMBER)/+
                    &SUBSTR(&JSL+1:&TL,&STR(&DBRMLIB)))
              IF &SUBSTR(1,&STR(&DBRMLIB))=&STR(') THEN   /*YES '    */+
                DO
                  /*-------------------------------------------------*/
                  /* DBRMLIB DATA SET ENCLOSED IN APOSTROPHIES       */
                  /*-------------------------------------------------*/
                  IF &JSL = 0 THEN       /* NO PASSWORD PRESENT      */+
                    SET &DBRMNAME =      /* BEGIN THE NAME           */+
                        &SUBSTR(1:&TL-1,&STR(&DBRMLIB))+
                        &STR((&MEMBER))&STR(')
                  ELSE                   /* PASSWORD IS PRESENT      */+
                    SET DBRMNAME=        /* PASSWORD PROVIDED        */+
                        &SUBSTR(1:&JSL-2,&STR(&DBRMLIB))+
                        &STR((&MEMBER)'/+
                        &SUBSTR(&JSL+1:&TL,&STR(&DBRMLIB)))
                END
              SET &DMEM = &NRSTR(&MEMBER)      /* USE THE STD MEMBER */
            END                        /* ADD MEMBER NAME            */
        END                            /* PROCESS DATA SET NAME      */
    END                                /* BUILD NAME COMPLETE        */
  /*******************************************************************/
  /*                                                                 */
  /*                BDBRMLIB KEYWORD OPTION                          */
  /*                                                                 */
  /*  IDENTIFIES THE DATA SET USED FOR BIND PLAN                     */
  /*                                                                 */
  /*  PARMS:   DATA SET NAME                                         */
  /*  DEFAULT: SAME DEFAULT AS THE DBRMLIB DATASET                   */
  /*******************************************************************/
  IF &STR(&BDBRMLIB) = NONE THEN       /* IF NO LIBRARY IS DESIRED   */+
    DO
      SET &BPLNLIB =                    /* MAKE LIBRARY NULL         */
      IF &NRSTR(&BDMEM) = DEFAULT THEN   /* IF MBR = DEFAULT         */+
        SET &BDMEM = &NRSTR(&DMEM)    /* USE THE DBRM MEMBER NAME    */
    END
  ELSE                                 /* IF DEFAULT IS DESIRED      */+
    IF &STR(&BDBRMLIB) = DEFAULT THEN  /* DEFAULT THE BDBRMLIB       */+
      DO                               /* ALLOCATE THE BDBRMLIB      */
        SET &BDBRMLIB = &STR(&DBRMLIB)   /* LIBRARY NAME             */
        SET &BDBRMNAME = &STR(&DBRMNAME)  /* BUILD NAME              */
        IF &NRSTR(&BDMEM) = DEFAULT THEN   /* IF MBR ^ DEFAULT       */+
          SET &BDMEM = &NRSTR(&DMEM)    /* USE THE DBRM MEMBER NAME  */
        SET BPLNLIB = &STR(&BDBRMLIB)
      END                              /* ALLOCATE THE BDBRMLIB      */
    ELSE                               /* USE PROVIDED BDBRMLIB      */+
      DO                               /* BUILD NAME, ALLOC          */
        /*-----------------------------------------------------------*/
        /* DETERMINE IF MEMBER NAME WAS SPECIFIED IN DATA SET NAME   */
        /*-----------------------------------------------------------*/
        SET TL = &LENGTH(&STR(&BDBRMLIB))
        SET J = &SYSINDEX(&STR( ),&STR(&BDBRMLIB)
        IF &J > 0 THEN              /* MULTIPLE LIBRARIES ???        */+
          DO
            IF &J+1 < &TL THEN      /* INSURE MULTIPLE LIBRARIES     */+
              SET B9LIB = &SUBSTR(&J+1:&TL,&STR(&BDBRMLIB))
            SET BDBRMLIB = &SUBSTR(1:&J-1,&STR(&BDBRMLIB))
            SET TL = &LENGTH(&STR(&BDBRMLIB))
          END
         SET J = &SYSINDEX(&LPAR,&SYSNSUB(1,&BDBRMLIB))
         SET JEND = &SYSINDEX(&RPAR,&SYSNSUB(1,&BDBRMLIB))
         IF (&J > 0 AND &JEND = 0) OR   /* LEFT PAREN AND NO RIGHT   */+
            (&J = 0 AND &JEND > 0) THEN /* NO LEFT PAREN BUT RIGHT   */+
           DO                       /* SETUP DSNH750I ERROR MSG      */
             /*------------------------------------------------------*/
             /* DSNH750I: INVALID DATA SET NAME (MEMBER)             */
             /*------------------------------------------------------*/
             SET &ERROR = 8         /* NOTE THE ERROR                */
             WRITE DSNH750I INVALID DATA SET: BDBRMLIB &BDBRMLIB
           END                      /* DSNH750I COMPLETE             */
         ELSE                       /* NO DATA SET ERRORS            */+
           DO                       /* PROCESS DATA SET NAME         */
             SET JSL = &SYSINDEX(/,&SYSNSUB(1,&BDBRMLIB))
             IF &J > 0 THEN         /* MEMBER IS ALREADY PRESENT     */+
               DO                   /* REMEMBER FOR BIND             */
                 /*--------------------------------------------------*/
                 /* USE BDBRMLIB MEMBER NAME SPECIFIED IN DATA SET   */
                 /*--------------------------------------------------*/
                 SET &BDMEM = &SUBSTR(&J+1:&JEND-1,&STR(&BDBRMLIB))
                 SET &BDBRMNAME=&STR(&BDBRMLIB)  /*USE BDBRMLIB NAME */
               END                  /* MEMBER NOTED                  */
             ELSE                   /* NO MEMBER, ADD ONE            */+
               DO                   /* ADD MEMBER NAME TO BDBRMLIB   */
                 /*--------------------------------------------------*/
                 /* DEFAULT DBRM MEMBER NAME TO INPUT MEMBER NAME    */
                 /*--------------------------------------------------*/
                 IF &JSL = 0 THEN   /* NO PASSWORD PRESENT           */+
                   SET &BDBRMNAME=  /* NO ' PRESENT                  */+
                       &STR(&BDBRMLIB.(&MEMBER))
                 ELSE               /* PASSWORD IS THERE             */+
                   SET BDBRMNAME=   /* PASSWORD PROVIDED             */+
                       &SUBSTR(1:&JSL-1,&STR(&BDBRMLIB))+
                       &STR((&MEMBER)/+
                       &SUBSTR(&JSL+1:&TL,&STR(&BDBRMLIB)))
                 IF &SUBSTR(1,&STR(&BDBRMLIB))=&STR(') THEN  /*YES ' */+
                   DO
                     /*----------------------------------------------*/
                     /* BDBRMLIB DATA SET ENCLOSED IN APOSTROPHIES   */
                     /*----------------------------------------------*/
                     IF &JSL = 0 THEN   /* NO PASSWORD PRESENT       */+
                       SET &BDBRMNAME =  /* BEGIN THE NAME           */+
                           &SUBSTR(1:&TL-1,&STR(&BDBRMLIB))+
                           &STR(&MEMBER)&STR(')
                     ELSE             /* PASSWORD IS PRESENT         */+
                       SET BDBRMNAME=  /* PASSWORD PROVIDED          */+
                           &SUBSTR(1:&JSL-2,&STR(&BDBRMLIB))+
                           &STR((&MEMBER)'/+
                           &SUBSTR(&JSL+1:&TL,&STR(&BDBRMLIB)))
                   END
                 IF &NRSTR(&BDMEM) = DEFAULT THEN /* IF MBR ^ DEFAULT*/+
                   SET &BDMEM = &NRSTR(&MEMBER) /* USE STD MEMBER    */
               END                  /* ADD MEMBER NAME               */
             SET BPLNLIB = &STR(&BDBRMLIB)
           END                      /* DATA SET COMPLETE             */
      END                           /* BUILD NAME COMPLETED          */
    /*---------------------------------------------------------------*/
    /* DSNH740I: INITIALIZE DSNH... WALL MESSAGES TO INDICATE STATUS */
    /*---------------------------------------------------------------*/
    SET &WALL1 = &STR(DSNH740I =======)
    SET &WALL2 = &STR(FINISHED, RC = )
    SET &WALLB = &STR(=============================)
    SET &WALL3 = &STR(=============================)
    SET &WALL4 = &STR(=============================)
    SET &WALLF = NO                    /* WALL FLAG, NO PRINT NAME   */
    IF &PRINT NE NONE AND &PRINT NE LEAVE AND &PRINT NE TERM THEN +
       DO                              /* SET UP A LISTING NAME      */
         /*----------------------------------------------------------*/
         /* SETUP WALL MESSAGES FOR SPECIFIED OUTPUT DATA SET        */
         /*----------------------------------------------------------*/
         SET &WALLF = YES              /* INDICATE THE WALL HAS DSN  */
         SET &WALL3 = &STR(======= LISTING IN &PRINT)
       END                             /* SET UP A LISTING NAME      */
  /*******************************************************************/
  /*                                                                 */
  /*                 WORKUNIT KEYWORD OPTION                         */
  /*                                                                 */
  /*  INDICATES THE TYPE OF DEVICE TO USE FOR TEMPORARY AND          */
  /*  INTERMEDIATE DATA SETS                                         */
  /*                                                                 */
  /*  PARMS:   UNIT-TYPE                                             */
  /*  DEFAULT: UADS UNIT NAME FOR THE CURRENT TSO USER, OR           */
  /*           ANY ELIGIBLE DEVICE IN BATCH MODE                     */
  /*******************************************************************/
    SET &WORKU =
    IF &WORKUNIT NE DEFAULT THEN          /* NO A DEFAULT WORK SPACE */+
       SET &WORKU = &STR(UNIT(&WORKUNIT)) /* SET UNIT PARM           */
    SET &DSNHC = &STR(%DSNHC )
  /*******************************************************************/
  /*  ADD SUPPORT FOR BIND PACKAGE: (ALL KEYWORDS THAT ARE COMMON    */
  /*      WITH BIND PLAN HAVE A "P" ADDED IN FRONT TO MAKE THEM      */
  /*      DIFFERENT THUS ALLOWING BIND PLAN AND BIND PACKAGE         */
  /*      AT THE SAME TIME.                                          */
  /*                                                                 */
  /*  COPY(COLLECTION.PACKAGEID) OR COPY(NONE)                       */
  /*  COPYVER(VERSION ID) OR COPYVER()                               */
  /*  COPYOPTS(COMPOSITE|COMMAND) OR NONE                     PQ03427*/
  /*  PACKAGE(LOCATION.COLLECTION) OR PACKAGE(NONE)                  */
  /*  PACTION(REPLACE|ADD)  DEFAULT REPLACE                          */
  /*  PPATH(SCHEMA LIST) OR PPATH(NONE)                         LI333*/
  /*  PCURRENTDATA(NO|YES) OR NONE                                   */
  /*  PKEEPDYNAMIC(NO|YES) OR NONE                            PQ20086*/
  /*  PCICS(LIST OF SUBSYSTEMS) OR NONE                              */
  /*  PDBRMLIB(DEFAULT) DBRM LIBRARY OR DEFAULT                      */
  /*  PDEGREE(1|ANY) OR NONE                                         */
  /*  PDISABLE(LIST) OR NONE (LIST OF SUBSYSTEMS TO DISABLE)         */
  /*  PDLIBATCH(LIST OF SUBSYSTEMS) OR NONE                          */
  /*  PEXPLAIN(NO|YES) OR NONE                                       */
  /*  PENABLE(LIST) OR NONE (LIST OF SUBSYSTEMS TO ENABLE)           */
  /*  PFLAG(I|W|E|C)   DEFAULT I                                     */
  /*  PISOLATION(RR|RS|CS|UR|NC) OR NONE                             */
  /*  PIMSBMP(LIST OF SUBSYSTEMS) OR NONE                            */
  /*  PIMSMPP(LIST OF SUBSYSTEMS) OR NONE                            */
  /*  POWNER(AUTHID) OR NONE                                         */
  /*  PQUALIFIER(NAME) OR NONE                                       */
  /*  PRELEASE(COMMIT|DEALLOCATE) OR NONE                            */
  /*  PVALIDATE(RUN|BIND) OR NONE                                    */
  /*  REPLVER(VERSION ID) OR REPLVER()                        KYD0288*/
  /*  SQLERROR(NOPACKAGE) OR SQLERROR(CONTINUE) OR NONE              */
  /*  REMOTE(LIST OF SUBSYSTEMS) OR NONE                             */
  /*  POPTHINT('Blank' or 'nonblank within quoted string'       LI375*/
  /*  PENCODING(ASCII|EBCDIC|UNICODE|ccsid) or NONE               @10*/
  /*  PIMMEDWRITE(NO|YES|INHERITFROMPLAN) or NONE                 @10*/
  /*  PAPREUSE(NONE|ERROR|WARN)                                   @10*/
  /*  PAPCOMPARE(NONE|ERROR|WARN)                                 @10*/
  /*  PSYSTIMESENSITIVE(blank|NO|YES)                             @10*/
  /*  PBUSTIMESENSITIVE(blank|NO|YES)                             @10*/
  /*  PARCHIVESENSITIVE(blank|NO|YES)                             @10*/
  /*  PAPPLCOMPAT(blank|V10R1|V11R1)                              @10*/
  /*                                                                 */
  /*******************************************************************/
  IF &NRSTR(&COPY) = NONE THEN      /* IF KEYWORD NOT SPECIFIED      */+
    DO                              /* PROCESS COPY AND COPYVER      */
      /*-------------------------------------------------------------*/
      /* COPY NOT SPECIFIED: IGNORE COPY, COPYVER, COPYOPTS   PQ03427*/
      /*-------------------------------------------------------------*/
      SET BCOPY =                   /* INDICATE NO COPY KEYWORD      */
      SET BCOPYVER =                /* INDICATE NO COPYVER KEYWORD   */
      SET BCOPYOPS =                /* NO COPYOPTS KEYWORD    PQ03427*/
    END                             /* KEYWORDS COMPLETE             */
  ELSE                              /* COPY VERSION IS PRESENT       */+
    DO                              /* PROCESS COPY AND COPYVER      */
      /*-------------------------------------------------------------*/
      /* COPY SPECIFIED: CHECK COPYVER                        PQ03427*/
      /*-------------------------------------------------------------*/
      SET BCOPY = &NRSTR(COPY(&COPY))
      IF &NRSTR(&COPYVER) = THEN    /* IF KEYWORD NOT SPECIFIED      */+
        SET BCOPYVER =              /* NO KEYWORD SPECIFIED          */
      ELSE                          /* COPYVER IS PRESENT            */+
        SET BCOPYVER = &NRSTR(COPYVER(&COPYVER))
      /*-------------------------------------------------------------*/
      /* COPY SPECIFIED: CHECK COPYOPTS                       PQ03427*/
      /*-------------------------------------------------------------*/
      SET &COPSERR = 0              /* INIT COPYOPTS ERROR    PQ03427*/
      IF &STR(&COPYOPTS) ^= NONE THEN  /* COPYOPTS SPECIFIED  PQ03427*/+
        DO                          /* VALIDATE COPYOPTS      PQ03427*/
          IF &LENGTH(&COPYOPTS) > 3 THEN /* AVOID ERRORS      PQ03427*/+
            IF &SUBSTR(1:4,&COPYOPTS) = COMP THEN  /*         PQ03427*/+
              SET &BCOPYOPS = COMPOSITE /* COMPOSITE          PQ03427*/
            ELSE                    /* CONTINUE CHECK         PQ03427*/+
              IF &SUBSTR(1:4,&COPYOPTS) = COMM THEN  /*       PQ03427*/+
                SET &BCOPYOPS = COMMAND /* COMMAND            PQ03427*/
              ELSE                  /* INVALID PARAMETER      PQ03427*/+
                SET &COPSERR = 8    /* REMEMBER ERROR         PQ03427*/
          ELSE                      /* INVALID LENGTH         PQ03427*/+
            SET &COPSERR = 8        /* REMEMBER THE ERROR     PQ03427*/
          IF &COPSERR = 8 THEN      /* COPYOPTS ERROR ?       PQ03427*/+
            DO                      /* GENERATE ERROR MESSAGE PQ03427*/
              /*-----------------------------------------------------*/
              /* DSNH751I: ERROR IN COPYOPTS VALUE SPECIFIED         */
              /*-----------------------------------------------------*/
              SET &ERROR = 8        /* REMEMBER THE ERROR            */
              WRITE &M751 COPYOPTS VALUE &COPYOPTS
            END                     /* ERROR COMPLETE         PQ03427*/
          ELSE                      /* SETUP COPYOPTS         PQ03427*/+
            SET &BCOPYOPS = &NRSTR(OPTIONS(&BCOPYOPS))  /*    PQ03427*/
        END                         /* VALIDATION COMPLETE    PQ03427*/
      ELSE                          /* NOT SPECIFIED          PQ03427*/+
        SET &BCOPYOPS = &STR()      /* SET KEYWORD NULL       PQ03427*/
    END                             /* COPY PROCESSING COMPLETE      */
  /*-----------------------------------------------------------------*/
  /* PACKAGE: DEFAULT or PACKAGE NAME                                */
  /*-----------------------------------------------------------------*/
  IF &NRSTR(&PACKAGE) = DEFAULT THEN   /* WE USE DEFAULT OUTPUT      */+
     SET PACKAGE = &MEMBER             /* SAME AS THE MEMBER NAME    */
  SET BPACKAGE = &NRSTR(&PACKAGE)
  /*******************************************************************/
  /*                                                                 */
  /*                PACTION KEYWORD OPTION                           */
  /*                                                                 */
  /*  INDICATE APPLICATION PACKAGE IS NEW OR REPLACEMENT             */
  /*                                                                 */
  /*  PARMS:   REPLACE, ADD                                          */
  /*  DEFAULT: REPLACE                                               */
  /*******************************************************************/
  IF &SUBSTR(1,&PACTION) = A THEN   /* ACTION PARAMETER SYNTAX CHECK */+
    SET &PACTION = ADD              /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK REPLACE ACTION          */+
    IF &SUBSTR(1,&PACTION) = R THEN /* ACTION IS REPLACE             */+
      SET &PACTION = REPLACE        /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN ACTION VALUE SPECIFIED                 */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 PACTION VALUE &PACTION
      END                           /* OF ERROR SETTING              */
  IF &NRSTR(&PCICS) = NONE THEN     /* IF KEYWORD NOT SPECIFIED      */+
     SET PBCICS =                   /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* CICSCONNECTIONS ARE PRESENT   */+
     SET PBCICS = &NRSTR(CICS(&PCICS))
  IF &NRSTR(&PDISABLE) = NONE THEN  /* IF KEYWORD NOT SPECIFIED      */+
     SET PBDISABL =                 /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* DISABLE SUBSYSTEMS IS PRESENT */+
     SET PBDISABL = &NRSTR(DISABLE(&PDISABLE))
  /*******************************************************************/
  /*                                                                 */
  /*              PKEEPDYNAMIC KEYWORD OPTION                   D9028*/
  /*                                                            D9028*/
  /*  INDICATE TO KEEP DYNAMIC SQL PAST COMMIT                  D9028*/
  /*                                                            D9028*/
  /*  PARMS:   NONE, NO or YES                                PQ20086*/
  /*  DEFAULT: NONE                                           PQ20086*/
  /*******************************************************************/
  SET &PKDERR = 0                   /* INIT PKEEPDYNAMIC      PQ20086*/
  IF &STR(&PKEEPDYNAMIC) ^= NONE THEN  /* KEYWORD SPECIFIED ? PQ20086*/+
    DO                              /* PROCESS KEYWORD        PQ20086*/
      IF &SUBSTR(1,&PKEEPDYNAMIC)= N THEN  /* SPECIFY NO ?    PQ20086*/+
        SET &PKEEPDYNAMIC = NO      /* KEYWORD NO             PQ20086*/
      ELSE                          /* CONTINUE CHECK         PQ20086*/+
        IF &SUBSTR(1,&PKEEPDYNAMIC)= Y THEN  /* SPECIFY YES ? PQ20086*/+
          SET &PKEEPDYNAMIC = YES   /* KEYWORD YES            PQ20086*/
        ELSE                        /* INVALID KEYWORD        PQ20086*/+
          SET &PKDERR = 8           /* REMEMBER THE ERROR     PQ20086*/
      IF &PKDERR = 8 THEN           /* SYNTAX ERRORS ?        PQ20086*/+
        DO                          /* ISSUE ERROR MESSAGE    PQ20086*/
          /*---------------------------------------------------------*/
          /*DSNH751I: ERROR IN PKEEPDYNAMIC VALUE SPECIFIED   PQ20086*/
          /*---------------------------------------------------------*/
          SET &ERROR = 8            /* REMEMBER THE ERROR     PQ20086*/
          WRITE &M751 PKEEPDYNAMIC VALUE &PKEEPDYNAMIC
        END                         /* ERROR MESSAGE COMPLETE PQ20086*/
      ELSE                          /* NO SYNTAX ERRORS       PQ20086*/+
        SET PBKEEPDYNAMIC = &STR(KEEPDYNAMIC(&PKEEPDYNAMIC))
    END                             /* PKEEPDYNAMIC NOT NULL  PQ20086*/
  ELSE                              /* PKEEPDYNAMIC IS NULL   PQ20086*/+
    SET &PBKEEPDYNAMIC = &STR()     /* SET KEYWORD NULL       PQ20086*/
  /*******************************************************************/
  /*                                                                 */
  /*                PCURRENTDATA KEYWORD OPTION                      */
  /*                                                                 */
  /*  INDICATES HOW DATA CURRENCY IS TO BE HANDLED FOR AMBIGUOUS     */
  /*  CURSORS.                                                       */
  /*                                                                 */
  /*  PARMS:   NO, YES, OR NONE                                      */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
 IF &STR(&PCURRENTDATA) ^= NONE THEN DO
  IF &SUBSTR(1,&PCURRENTDATA)= N THEN /* SYNTAX PCURRENTDATA KEYWORD */+
    SET &PCURRENTDATA = NO          /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO PCURRENTDATA         */+
    IF &SUBSTR(1,&PCURRENTDATA)= Y THEN /* IF PCURRENTDATA IS YES    */+
      SET &PCURRENTDATA = YES       /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN PCURRENTDATA VALUE SPECIFIED            */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 PCURRENTDATA VALUE &PCURRENTDATA
      END                           /* OF ERROR SETTING              */
  SET PBCURRDATA = &STR(CURRENTDATA(&PCURRENTDATA))
 END                                /* WHEN PCURRENTDATA IS NOT NULL */
 ELSE                               /* WHEN PCURRENTDATA IS NULL     */+
  SET PBCURRDATA =
  /*******************************************************************/
  /*                                                          KFD0005*/
  /*                PDEFER AND PNODEFER KEYWORD OPTIONS       KFD0005*/
  /*                                                          KFD0005*/
  /*  DEFER OR NODEFER PROCESSING OPTIONS (BIND PACKAGE)      KFD0005*/
  /*                                                          KFD0005*/
  /*  PARMS:   PREP - PREPARE                                 KFD0005*/
  /*  DEFAULT: NODEFER(PREPARE)                               KFD0005*/
  /*******************************************************************/
  IF &PDEFER = NONE THEN            /* IF NOT SPECIFIED       KFD0005*/+
    SET &PDEFR =                    /* INDICATE NO KEYWORD    KFD0005*/
  ELSE                              /* DEFER SPECIFIED        KFD0005*/+
    IF &PDEFER = PREPARE THEN       /* IF KEYWORD CORRECT     KFD0005*/+
      SET &PDEFR = DEFER(PREPARE)   /* SET DEFER PREPARE      KFD0005*/
    ELSE                            /* ERROR IN KEYWORD       KFD0005*/+
      DO                            /* ISSUE ERROR MESSAGE    KFD0005*/
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN PDEFER VALUE SPECIFIED          KFD0005*/
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /*  REMEMBER THE ERROR    KFD0005*/
        WRITE &M751 PDEFER VALUE &PDEFER
      END                           /* END ERROR SETTING      KFD0005*/
  IF &PNODEFER = NONE THEN          /* IF NOT SPECIFIED       KFD0005*/+
    SET &PNDEFR =                   /* INDICATE NO KEYWORD    KFD0005*/
  ELSE                              /* NODEFER SPECIFIED      KFD0005*/+
    IF &PNODEFER = PREPARE THEN     /* IF KEYWORD CORRECT     KFD0005*/+
      SET &PNDEFR = NODEFER(PREPARE) /* SET NODEFER PREPARE   KFD0005*/
    ELSE                            /* ERROR IN KEYWORD       KFD0005*/+
      DO                            /* ISSUE ERROR MESSAGE    KFD0005*/
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN PNODEFER VALUE SPECIFIED        KFD0005*/
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /*   REMEMBER THE ERROR   KFD0005*/
        WRITE &M751 PNODEFER VALUE &PNODEFER
      END                           /* END ERROR SETTING      KFD0005*/
  /*******************************************************************/
  /*                                                                 */
  /*                  PDEGREE KEYWORD OPTION                         */
  /*                                                                 */
  /*  REQUESTS DB2 TO EXECUTE A QUERY IN PARALLEL OR NOT             */
  /*                                                                 */
  /*  PARMS:                                                         */
  /*         1 - NOT TO EXECUTE A QUERY IN PARALLEL                  */
  /*       ANY - EXECUTE A QUERY IN PARALLEL                         */
  /*  DEFAULT: 1                                                     */
  /*******************************************************************/
 IF &STR(&PDEGREE) ^= NONE THEN DO
  IF &SUBSTR(1,&PDEGREE)= 1 THEN    /* IF PDEGREE IS 1               */+
    SET &PDEGREE = 1                /* BE SURE KEYWORD IS EXACT      */
  ELSE                                                                 +
    IF &SUBSTR(1,&PDEGREE)= A THEN  /* IF PDEGREE IS ANY             */+
      SET &PDEGREE = ANY            /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN DEGREE VALUE SPECIFIED                 */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 PDEGREE VALUE &PDEGREE
      END                           /* OF ERROR SETTING              */
  SET PBDEGREE = &STR(DEGREE(&PDEGREE))
 END                                /* WHEN PDEGREE IS NOT NULL      */
 ELSE                               /* WHEN PDEGREE IS NULL          */+
  SET PBDEGREE =
  /*******************************************************************/
  /*                                                                 */
  /*                PDBRMLIB KEYWORD OPTION                          */
  /*                                                                 */
  /*  IDENTIFIES THE DATA SET TO CONTAIN THE DBRM MEMBER             */
  /*                                                                 */
  /*  PARMS:   DATA SET NAME                                         */
  /*  DEFAULT: OUTNAME-KEYWORD-STRING.PDBRMLIB                       */
  /*******************************************************************/
  IF &STR(&PDBRMLIB) = NONE THEN       /* IF NO LIBRARY IS DESIRED   */+
    DO
      SET &BPKGLIB =                   /* MAKE LIBRARY NULL          */
      IF &NRSTR(&PDMEM) = DEFAULT THEN         /* IF NO MBR, DEFAULT */+
        SET BPKGMBR = &NRSTR(MEMBER(&DMEM))
      ELSE                             /* MBR NOT NULL, BUILD KEYWORD*/+
        IF &PDMEM ^= NONE THEN         /* MBR NOT NULL, BUILD KEYWORD*/+
          SET BPKGMBR = &NRSTR(MEMBER(&PDMEM))
        ELSE                           /* MBR IS NULL, BUILD KEYWORD */+
          SET &BPKGMBR =               /* MAKE MEMBER NULL           */
    END
  ELSE                                 /* IF DEFAULT LIBRARY DESIRED */+
    IF &STR(&PDBRMLIB) = DEFAULT THEN  /* DEFAULT THE PDBRMLIB       */+
      DO                               /* ALLOCATE THE PDBRMLIB      */
        SET &PDBRMLIB = &STR(&DBRMLIB)   /* LIBRARY NAME             */
        SET &PDBRMNAME = &STR(&DBRMNAME) /* BUILD NAME               */
        SET BPKGLIB = &NRSTR(LIBRARY(&PDBRMLIB))
        IF &NRSTR(&PDMEM) = DEFAULT THEN       /* IF NO MBR, DEFAULT */+
          SET BPKGMBR = &NRSTR(MEMBER(&DMEM))
        ELSE                           /* MBR NOT NULL, BUILD KEYWORD*/+
          IF &PDMEM ^= NONE THEN       /* MBR NOT NULL, BUILD KEYWORD*/+
            SET BPKGMBR = &NRSTR(MEMBER(&PDMEM))
          ELSE                         /* MBR IS NULL, BUILD KEYWORD */+
            SET &BPKGMBR =             /* MAKE MEMBER  NULL          */
      END                              /* ALLOCATE THE PDBRMLIB      */
    ELSE                               /* USE PROVIDED PDBRMLIB      */+
      DO                               /* BUILD NAME, ALLOC          */
        /*-----------------------------------------------------------*/
        /* DETERMINE IF MEMBER NAME WAS SPECIFIED IN DATA SET NAME   */
        /*-----------------------------------------------------------*/
        SET J = &SYSINDEX(&LPAR,&SYSNSUB(1,&PDBRMLIB))
        SET JEND = &SYSINDEX(&RPAR,&SYSNSUB(1,&PDBRMLIB))
        IF (&J > 0 AND &JEND = 0) OR   /* LEFT PAREN AND NO RIGHT    */+
           (&J = 0 AND &JEND > 0) THEN /* NO LEFT PAREN BUT RIGHT    */+
          DO                           /* SETUP DSNH750I ERROR MSG   */
            /*-------------------------------------------------------*/
            /* DSNH750I: INVALID DATA SET NAME (MEMBER)              */
            /*-------------------------------------------------------*/
            SET &ERROR = 8              /* NOTE THE ERROR             */
            WRITE DSNH750I INVALID DATA SET: PDBRMLIB &PDBRMLIB
          END                          /* DSNH750I COMPLETE          */
        ELSE                           /* NO DATA SET ERRORS         */+
          DO                           /* PROCESS DATA SET NAME      */
            SET JSL = &SYSINDEX(/,&SYSNSUB(1,&PDBRMLIB))
            SET TL = &LENGTH(&STR(&PDBRMLIB))
            IF &J > 0 THEN             /* MEMBER IS ALREADY PRESENT  */+
              DO                       /* REMEMBER FOR BIND          */
                /*----------------------------------------------------*/
                /* USE PDBRMLIB MEMBER NAME SPECIFIED IN DATA SET    */
                /*---------------------------------------------------*/
                SET &PDMEM = &SUBSTR(&J+1:&JEND-1,&STR(&PDBRMLIB))
                SET &PDBRMNAME=&STR(&PDBRMLIB) /* USE PDBRMLIB NAME  */
              END                      /* MEMBER NOTED               */
            ELSE                       /* NO MEMBER, ADD ONE         */+
              DO                       /* ADD MEMBER NAME TO PDBRMLIB*/
                /*---------------------------------------------------*/
                /* DEFAULT DBRM MEMBER INPUT DATA SET MEMBER NAME    */
                /*---------------------------------------------------*/
                IF &JSL = 0 THEN       /* NO PASSWORD PRESENT        */+
                  SET &PDBRMNAME=&STR(&PDBRMLIB.(&MEMBER))  /*NO '   */
                ELSE                   /* PASSWORD IS THERE          */+
                  SET PDBRMNAME=       /* PASSWORD PROVIDED          */+
                      &SUBSTR(1:&JSL-1,&STR(&PDBRMLIB))+
                      &STR((&MEMBER)/+
                      &SUBSTR(&JSL+1:&TL,&STR(&PDBRMLIB)))
                IF &SUBSTR(1,&STR(&PDBRMLIB))=&STR(') THEN /* YES '  */+
                  DO
                    /*-----------------------------------------------*/
                    /* PDBRMLIB DATA SET ENCLOSED IN APOSTROPHIES    */
                    /*-----------------------------------------------*/
                    IF &JSL = 0 THEN   /* NO PASSWORD PRESENT        */+
                      SET &PDBRMNAME = /* BEGIN THE NAME             */+
                          &SUBSTR(1:&TL-1,&STR(&PDBRMLIB))+
                          &STR(&MEMBER)&STR(')
                    ELSE               /* PASSWORD IS PRESENT        */+
                      SET PDBRMNAME=   /* PASSWORD PROVIDED          */+
                          &SUBSTR(1:&JSL-2,&STR(&PDBRMLIB))+
                          &STR((&MEMBER)'/+
                          &SUBSTR(&JSL+1:&TL,&STR(&PDBRMLIB)))
                  END
                IF &NRSTR(&PDMEM) = DEFAULT THEN  /* IF NO, DEFAULT  */+
                  SET PDMEM = &NRSTR(&MEMBER)
              END                     /* ADD MEMBER NAME             */
            IF &PDMEM ^= NONE THEN    /* MBR NOT NULL, BUILD KEYWORD */+
              SET BPKGMBR = &NRSTR(MEMBER(&PDMEM))
            ELSE                      /* MBR IS NULL, BUILD KEYWORD  */+
              SET &BPKGMBR =          /* MAKE MEMBER NULL            */
            SET BPKGLIB = &NRSTR(LIBRARY(&PDBRMLIB))
          END                       /* DATA SET NAME COMPLETE        */
      END                           /* BUILD NAME, ALLOC             */
  /*******************************************************************/
  /*  PROCESS PDLIBATCH                                              */
  /*******************************************************************/
  IF &NRSTR(&PDLIBATCH) = NONE THEN /* IF KEYWORD NOT SPECIFIED      */+
     SET PBDLIBATC =                /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* DLIBATCHCONNS  ARE PRESENT    */+
     SET PBDLIBATC = &NRSTR(DLIBATCH(&PDLIBATCH))
  /*******************************************************************/
  /*  PROCESS PEXPLAIN                                               */
  /*******************************************************************/
 IF &STR(&PEXPLAIN) ^= NONE THEN DO
  IF &SUBSTR(1,&PEXPLAIN)= Y THEN   /* PEXPLAIN PARM SYNTAX CHECK    */+
    SET &PEXPLAIN = YES             /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK FOR VALUE = 'NO'        */+
    IF &SUBSTR(1,&PEXPLAIN)= N THEN /* IF PEXPLAIN IS NO  THEN       */+
      SET &PEXPLAIN = NO            /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 PEXPLAIN VALUE &PEXPLAIN
      END                           /* OF ERROR SETTING              */
  SET PBEXPLAIN = &STR(EXPLAIN(&PEXPLAIN))
 END                                /* WHEN PEXPLAIN IS NOT NULL     */
 ELSE                               /* WHEN PEXPLAIN IS NULL         */+
  SET PBEXPLAIN =
  /*******************************************************************/
  /*  PROCESS PENABLE                                                */
  /*******************************************************************/
  IF &NRSTR(&PENABLE) = NONE THEN   /* IF KEYWORD NOT SPECIFIED      */+
     SET PBENABL =                  /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* DISABLE SUBSYSTEMS IS PRESENT */+
     SET PBENABL = &NRSTR(ENABLE(&PENABLE))
  /*******************************************************************/
  /*                                                                 */
  /*                PFLAG KEYWORD OPTION                             */
  /*                                                                 */
  /*  INDICATE MESSAGES TO BE DISPLAYED                              */
  /*                                                                 */
  /*  PARMS:   I - INFORMATIONAL (INCLUDES W, E AND C)               */
  /*           W - WARNING, ERROR, AND SEVERE ERROR                  */
  /*           E - ERROR, AND SEVERE ERROR                           */
  /*           S - SEVERE ERROR                                      */
  /*  DEFAULT: I                                                     */
  /*******************************************************************/
  IF &PFLAG ^= I AND                /* IF FLAG ISN'T INFORMATION     */+
     &PFLAG ^= W AND                /* IF FLAG ISN'T WARNING         */+
     &PFLAG ^= E AND                /* IF FLAG ISN'T ERROR           */+
     &PFLAG ^= S THEN               /* IF FLAG ISN'T SEVERE          */+
    DO                              /* ISSUE THE ERROR MESSAGE       */
      /*-------------------------------------------------------------*/
      /* DSNH751I: ERROR IN FLAG VALUE SPECIFIED                     */
      /*-------------------------------------------------------------*/
      SET &ERROR = 8                /* REMEMBER THE ERROR            */
      WRITE &M751 PFLAG VALUE &PFLAG
    END                             /* OF ERROR SETTING              */
  SET &PFLAGB = &PFLAG              /* SET UP THE BIND FLAG          */
  IF &PFLAG = S THEN                /* IF FLAG IS SEVERE             */+
    SET &PFLAGB = E                 /* SET UP THE BIND FLAG          */
  /*******************************************************************/
  /*                                                                 */
  /*                PISOLATION KEYWORD OPTION                        */
  /*                                                                 */
  /*  INDICATES THE EXTENT TO WHICH THE APPLICATION PROGRAM IS       */
  /*  TO BE ISOLATED FROM OTHER EXECUTING APPLICATION PROGRAMS       */
  /*                                                                 */
  /*  PARMS:   RR (REPEATABLE READ), RS (READ STABILITY),            */
  /*           CS (CURSOR STABILITY), UR (UNCOMMITTED READ),         */
  /*           NC (NO COMMIT)                                        */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
 SET &PIERR = 0                    /* INITIALIZE PISOLATION ERROR    */
 IF &STR(&PISOLATION) ^= NONE THEN /* NOT DEFAULT, CHECK OPERAND     */+
   DO                              /* CHECK SYNTAX CORRECT VALUES    */
     IF &SUBSTR(1,&PISOLATION)= R THEN /* SYNTAX CHECK PISOLATION    */+
       DO                          /* CHECK SYNTAX FOR RR OR RS      */
         IF &LENGTH(&PISOLATION) > 1 THEN /* AVOID SUBSTR ERRORS     */+
           DO                      /* CHECK SYNTAX FOR RR OR RS      */
             IF &SUBSTR(1:2,&PISOLATION)= RR THEN /* OPERAND RR ?    */+
               SET &PISOLATION = RR  /* SET TO RR                    */
             ELSE                    /* CONTINUE CHECK               */+
               IF &SUBSTR(1:2,&PISOLATION)= RS THEN /* OPERAND RS ?  */+
                 SET &PISOLATION = RS /* SET TO RS                   */
               ELSE                /* ERROR, MUST BE RR OR RS        */+
                 SET &PIERR = 8    /* REMEMBER THE ERROR             */
           END                     /* CHECK COMPLETE RR OR RS        */
         ELSE                      /* MUST BE LEAST TWO CHARACTERS   */+
           SET &PIERR = 8          /* REMEMBER THE ERROR             */
       END                         /* CHECK COMPLETE FOR RR OR RS    */
     ELSE                          /* CONTINUE CHECK                 */+
       DO                          /* CHECK SYNTAX FOR CS, UR, OR NC */
         IF &SUBSTR(1,&PISOLATION)= C THEN /* OPERAND CS ?           */+
           SET &PISOLATION = CS    /* SET TO CS                      */
         ELSE                      /* CONTINUE CHECK                 */+
           IF &SUBSTR(1,&PISOLATION)= U THEN /* OPERAND UR ?         */+
             SET &PISOLATION = UR  /* SET TO UR                      */
           ELSE                    /* CONTINUE CHECK                 */+
             IF &SUBSTR(1,&PISOLATION)= N THEN /* OPERAND NC ?       */+
               SET &PISOLATION = NC  /* SET TO NC                    */
             ELSE                  /* ERROR, MUST BE CS, UR, OR NC   */+
               SET &PIERR = 8      /* REMEMBER THE ERROR             */
       END                         /* CHECK COMPLETE CS, UR, OR NC   */
     IF &PIERR = 8 THEN            /* ERRORS IN PISOLATION SYNTAX ?  */+
       DO                          /* ISSUE THE ERROR MESSAGE        */
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PISOLATION VALUE SPECIFIED            */
         /*----------------------------------------------------------*/
         SET &ERROR = &PIERR       /* TRANSFER TO DSNH CLIST ERROR   */
         WRITE &M751 PISOLATION VALUE &PISOLATION
       END                         /* END ERROR MESSAGE PROCESSING   */
     ELSE                          /* NO ERRORS, GOOD PISOLATION     */+
       SET PBISOLATION = &STR(ISOLATION(&PISOLATION))
   END                              /* PISOLATION CHECK COMPLETE     */
 ELSE                               /* WHEN PISOLATION IS NULL       */+
   SET PBISOLATION =
  /*******************************************************************/
  /*                                                                 */
  /*                PIMSBMP, PIMSMPP, PQUALIFIER                     */
  /*                                                                 */
  /*  INDICATES THE EXTENT TO WHICH THE APPLICATION PROGRAM IS       */
  /*  TO BE ISOLATED FROM OTHER EXECUTING APPLICATION PROGRAMS       */
  /*                                                                 */
  /*  PARMS:                                                         */
  /*       PIMSBMP, PIMSMPP: IMS SUBSYSTEM NAMES                     */
  /*       PQUALIFIER: NAME                                          */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &NRSTR(&PIMSBMP) = NONE THEN   /* IF KEYWORD NOT SPECIFIED      */+
     SET PBIMSBMP =                 /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* IMSCONNECTIONS ARE PRESENT    */+
     SET PBIMSBMP = &NRSTR(IMSBMP(&PIMSBMP))
  IF &NRSTR(&PIMSMPP) = NONE THEN   /* IF KEYWORD NOT SPECIFIED      */+
     SET PBIMSMPP =                 /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* IMSCONNECTIONS ARE PRESENT    */+
     SET PBIMSMPP = &NRSTR(IMSMPP(&PIMSMPP))
  IF &NRSTR(&PQUALIFIER) = NONE THEN /* IF KEYWORD NOT SPECIFIED     */+
     SET PBQUALF =                  /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* QUALIFIER FOR TABLES PRESENT  */+
     SET PBQUALF = &NRSTR(QUALIFIER(&PQUALIFIER))
  /*******************************************************************/
  /*                                                                 */
  /*                PRELEASE KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES WHEN BIND SHOULD RELEASE DB2 RESOURCES               */
  /*                                                                 */
  /*  PARMS:   COMMIT, DEALLOCATE                                    */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
 IF &STR(&PRELEASE) ^= NONE THEN DO
  IF &SUBSTR(1,&PRELEASE) = D THEN /* SYNTAX CHECK PRELEASE PARAMETER*/+
    SET &PRELEASE = DEALLOCATE      /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK FOR RELEASE COMMIT      */+
    IF &SUBSTR(1,&PRELEASE) = C THEN /*SYNTAX CHECK PRELEASE PARAM   */+
      SET &PRELEASE = COMMIT        /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN RELEASE VALUE SPECIFIED                */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 PRELEASE VALUE &PRELEASE
      END                           /* OF ERROR SETTING              */
  SET PBRELEASE = &STR(RELEASE(&PRELEASE))
 END                           /* OF PRELEASE WHEN NOT NULL          */
 ELSE                              /*    PRELEASE IS   NULL          */+
  SET PBRELEASE =
  /*******************************************************************/
  /*                                                          KFD0005*/
  /*                PREOPT KEYWORD OPTIONS                    KFD0005*/
  /*                                                          KFD0005*/
  /*  PREOPT PROCESSING OPTIONS (BIND PACKAGE)                KFD0005*/
  /*                                                          KFD0005*/
  /*  PARMS:   NONE - KEYWORD NOT SPECIFIED ON INVOCATION       D9000*/
  /*           VARS - REOPT(VARS)                               D9000*/
  /*         ALWAYS - REOPT(ALWAYS)                             DJ137*/
  /*           AUTO - REOPT(AUTO)                               DK216*/
  /*           NONE - REOPT(NONE)                               DJ137*/
  /*           ONCE - REOPT(ONCE)                               DJ137*/
  /*  DEFAULT: NONE                                           KFD0005*/
  /*******************************************************************/
  IF &PREOPT = NONE THEN            /* IF NOT SPECIFIED       KFD0005*/+
    SET &PROPT =                    /* NO KEYWORD SPECIFIED   KFD0005*/
  ELSE                              /* KEYWORD SPECIFIED      KFD0005*/+
    IF &PREOPT = VARS THEN          /* IF VARS SPECIFIED        D9000*/+
      SET &PROPT = REOPT(VARS)      /* SET REOPT(VARS)          D9000*/
    ELSE IF &PREOPT = ALWAYS THEN   /* IF ALWAYS SPECIFIED  DJ137 @07*/+
      SET &PROPT = REOPT(ALWAYS)    /* SET REOPT(ALWAYS)        DJ137*/
    ELSE IF &PREOPT = AUTO THEN     /* IF AUTO SPECIFIED    DK216 @07*/+
      SET &PROPT = REOPT(AUTO)      /* SET REOPT(AUTO)          DK216*/
    ELSE IF &PREOPT = NONE THEN     /* IF NONE SPECIFIED    DJ137 @07*/+
      SET &PROPT = REOPT(NONE)      /* SET REOPT(NONE)          DJ137*/
    ELSE IF &PREOPT = ONCE THEN     /* IF ONCE SPECIFIED    DJ137 @07*/+
      SET &PROPT = REOPT(ONCE)      /* SET REOPT(ONCE)          DJ137*/
    ELSE                            /* MUST BE NONE/VARS        D9000*/+
      DO                            /* ISSUE ERROR MESSAGE    KFD0005*/
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN PREOPT VALUE SPECIFIED          KFD0005*/
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR     KFD0005*/
        WRITE &M751 PREOPT VALUE &PREOPT
      END                           /* END ERROR SETTING      KFD0005*/
  /*******************************************************************/
  /*                                                                 */
  /*                SQLERROR KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATES SUBSEQUENT BIND PACKAGE PROCESSING TO BE PERFORMED   */
  /*  SHOULD SQL ERRORS BE ENCOUNTERED DURING BIND PROCESSING        */
  /*                                                                 */
  /*  PARMS:   NOPACKAGE: NO PACKAGE CREATED                         */
  /*           CONTINUE: CREATE PACKAGE                              */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
 IF &STR(&SQLERROR) ^= NONE THEN DO
  IF &SUBSTR(1,&SQLERROR)= N THEN   /* SYNTAX CHECK SQLERROR KEYWORD */+
    SET &SQLERROR = NOPACKAGE       /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO ISOLATION            */+
    IF &SUBSTR(1,&SQLERROR)= C THEN /* IF SQLERROR IS CONTINUE       */+
      SET &SQLERROR = CONTINUE      /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN SQLERROR VALUE SPECIFIED               */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 SQLERROR VALUE &SQLERROR
      END                           /* OF ERROR SETTING              */
  SET PBSQLERROR = &STR(SQLERROR(&SQLERROR))
 END                                /* WHEN PISOLATION IS NOT NULL   */
 ELSE                               /* WHEN PISOLATION IS NULL       */+
  SET PBSQLERROR =
  /*******************************************************************/
  /*                                                                 */
  /*                PVALIDATE KEYWORD OPTION                         */
  /*                                                                 */
  /*  INDICATES TO BIND WHEN SQL STATEMENTS ARE TO BE VERIFIED       */
  /*                                                                 */
  /*  PARMS:   RUN, BIND                                             */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
 IF &STR(&PVALIDATE) ^= NONE THEN DO
  IF &SUBSTR(1,&PVALIDATE)= R THEN /* SYNTAX CHECK PVALIDATE KEYWORD */+
    SET &PVALIDATE= RUN             /* BE SURE KEYWORD IS EXACT      */
  ELSE                              /* CHECK NO VALID                */+
    IF &SUBSTR(1,&PVALIDATE)= B THEN /* IF PVALIDATE IS BIND         */+
      SET &PVALIDATE= BIND          /* BE SURE KEYWORD IS EXACT      */
    ELSE                            /* THIS IS AN ERROR              */+
      DO                            /* ISSUE THE ERROR MESSAGE       */
        /*-----------------------------------------------------------*/
        /* DSNH751I: ERROR IN VALIDATE VALUE SPECIFIED               */
        /*-----------------------------------------------------------*/
        SET &ERROR = 8              /* REMEMBER THE ERROR            */
        WRITE &M751 PVALIDATE VALUE &PVALIDATE
      END                           /* OF ERROR SETTING              */
  SET PBVALIDATE = &STR(VALIDATE(&PVALIDATE))
 END                                /* WHEN PVALIDATE IS NOT NULL    */
 ELSE                               /* WHEN PVALIDATE IS NULL        */+
  SET PBVALIDATE =
  IF &NRSTR(&REPLVER) = THEN        /* IF KEYWORD NOT SPECIFIED      */+
     SET BREPLVER =                 /* NO KEYWORD SPECIFIED          */
  ELSE                              /* REPLVER IS PRESENT            */+
     SET BREPLVER = &NRSTR(REPLVER(&REPLVER))
  IF &NRSTR(&REMOTE) = NONE THEN    /* IF KEYWORD NOT SPECIFIED      */+
     SET BREMOTE =                  /* INDICATE NO KEYWORD SPECIFIED */
  ELSE                              /* REMOTE CONNECTIONS PRESENT    */+
     SET BREMOTE = &NRSTR(REMOTE(&REMOTE))
  /*******************************************************************/
  /*                                                                 */
  /*                PDYNAMICRULES KEYWORD OPTION                     */
  /*                                                                 */
  /*  DETERMINE AUTHORIZATION ID AT BIND TIME OR RUN TIME            */
  /*                                                                 */
  /*  PARMS:   RUN, BIND, DEFINERUN, DEFINEBIND,                DG122*/
  /*           INVOKERUN, INVOKEBIND                            DG122*/
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
 SET &PDRERR = 0                    /* INIT PDYNAMICRULES       DG122*/
 IF &STR(&PDYNAMICRULES) ^= NONE THEN                       /*  DG122*/+
   DO                               /* PROCESS KEYWORD          DG122*/
     IF &SUBSTR(1,&PDYNAMICRULES)=R THEN /* SPECIFY RUN ?       DG122*/+
       SET &PDYNAMICRULES = RUN     /* SET KEYWORD RUN          DG122*/
     ELSE                           /* CONTINUE CHECK           DG122*/+
       IF &SUBSTR(1,&PDYNAMICRULES)=B THEN /* SPECIFY BIND ?    DG122*/+
         SET &PDYNAMICRULES = BIND  /* SET KEYWORD BIND         DG122*/
       ELSE                         /* NOT BIND                 DG122*/+
         IF &LENGTH(&PDYNAMICRULES) > 6 THEN /* VALID LENGTH ?  DG122*/+
           DO                       /* CONTINUE KEYWORD CHECK   DG122*/
             IF &SUBSTR(1,&PDYNAMICRULES)=D THEN /* DEFINE ?    DG122*/+
               DO                   /* VALIDATE DEFINE          DG122*/
                 IF &SUBSTR(1:7,&STR(&PDYNAMICRULES))=DEFINER THEN     +
                   SET &PDYNAMICRULES = DEFINERUN  /* SET       DG122*/
                 ELSE               /* CONTINUE CHECK           DG122*/+
                   IF &SUBSTR(1:7,&STR(&PDYNAMICRULES))=DEFINEB THEN   +
                     SET &PDYNAMICRULES = DEFINEBIND /* SET     DG122*/
                   ELSE             /* KEYWORD ERROR            DG122*/+
                     SET &PDRERR = 8  /* REMEMBER THE ERROR     DG122*/
               END                  /* DEFINE COMPLETE          DG122*/
             ELSE                   /* CHECK INVOKE             DG122*/+
               IF &SUBSTR(1,&PDYNAMICRULES)=I THEN /* INVOKE ?  DG122*/+
                 DO                 /* CONTINUE KEYWORD CHECK   DG122*/
                   IF &SUBSTR(1:7,&STR(&PDYNAMICRULES))=INVOKER THEN   +
                     SET &PDYNAMICRULES = INVOKERUN /* SET      DG122*/
                   ELSE             /* CONTINUE CHECK           DG122*/+
                     IF &SUBSTR(1:7,&STR(&PDYNAMICRULES))=INVOKEB THEN +
                       SET &PDYNAMICRULES = INVOKEBIND /* SET   DG122*/
                   ELSE             /* KEYWORD NOT VALID        DG122*/+
                     SET &PDRERR = 8 /* REMEMBER THE ERROR      DG122*/
                 END                /* INVOKE COMPLETE          DG122*/
               ELSE                 /* KEYWORD ERROR            DG122*/+
                 SET &PDRERR = 8    /* REMEMBER THE ERROR       DG122*/
           END                      /* KEYWORD CHECK COMPLETE   DG122*/
         ELSE                       /* INSUFFICIENT LENGTH      DG122*/+
           SET &PDRERR = 8          /* REMEMBER THE ERROR       DG122*/
     IF &PDRERR = 8 THEN            /* SYNTAX ERRORS ?          DG122*/+
       DO                           /* ISSUE ERROR MESSAGE      DG122*/
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PDYNAMICRULES VALUE SPECIFIED         */
         /*----------------------------------------------------------*/
         SET &ERROR = 8             /* REMEMBER THE ERROR       DG122*/
         WRITE &M751 PDYNAMICRULES VALUE &PDYNAMICRULES
       END                          /* ERROR MESSAGE COMPLETE   DG122*/
     ELSE                           /* NO SYNTAX ERRORS         DG122*/+
       SET PBDYNAMICRULES = &STR(DYNAMICRULES(&PDYNAMICRULES))
   END                              /* PDYNAMICRULES NOT NULL   DG122*/
 ELSE                               /* PDYNAMICRULES IS NULL    DG122*/+
   SET PBDYNAMICRULES = &STR()      /* SET KEYWORD NULL         DG122*/
  /*******************************************************************/
  /*                                                                 */
  /*              PDBPROTOCOL KEYWORD OPTION                    LI350*/
  /*                                                            LI350*/
  /*  INDICATE DRDA OR PRIVATE PROTOCOLS                        LI350*/
  /*                                                            LI350*/
  /*  PARMS:   NONE, DRDA, PRIVATE                              LI350*/
  /*  DEFAULT: NONE                                             LI350*/
  /*******************************************************************/
  IF &STR(&PDBPROTOCOL) ^= NONE THEN DO  /* KEYWORD SPECIFIED ? LI350*/
   IF &SUBSTR(1,&PDBPROTOCOL)= D THEN /* SPECIFY DRDA ?         LI350*/+
     SET &PDBPRO = &STR(DBPROTOCOL(DRDA))  /* SET DRDA          LI350*/
   ELSE                              /* CONTINUE CHECK          LI350*/+
     IF &SUBSTR(1,&PDBPROTOCOL) = P THEN /* SPECIFY PRIVATE ?   LI350*/+
       SET &PDBPRO = &STR(DBPROTOCOL(PRIVATE)) /* SET PRIVATE   LI350*/
     ELSE                            /* THIS IS AN ERROR        LI350*/+
       DO                            /* ISSUE THE ERROR MESSAGE LI350*/
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PDBPROTOCOL VALUE SPECIFIED      LI350*/
         /*----------------------------------------------------------*/
         SET &PDBPRO = &STR()        /* SET KEYWORD NULL        LI350*/
         SET &ERROR = 8              /* REMEMBER THE ERROR      LI350*/
         WRITE &M751 PDBPROTOCOL VALUE &PDBPROTOCOL
       END                           /* END OF ERROR SETTING    LI350*/
  END                                /* PDBPROTOCOL COMPLETE    LI350*/
  ELSE                               /* PDBPROTOCOL IS NULL     LI350*/+
   SET &PDBPRO = &STR()              /* SET KEYWORD NULL        LI350*/
  /*******************************************************************/
  /*                                                            LI375*/
  /*              POPTHINT KEYWORD OPTION                       LI375*/
  /*                                                            LI375*/
  /*  INDICATE OPTHINT OPTIMIZATION HINT-ID                     LI375*/
  /*                                                            LI375*/
  /*  PARMS:   'Blank' or 'non-blank within quoted string'      LI375*/
  /*  DEFAULT: Blank                                            LI375*/
  /*******************************************************************/
  SET &QYERR = 0                     /* INIT OPTHINT ERROR      LI375*/
  IF &NRSTR(&POPTHINT) ^= THEN       /* POTHINT SPECIFIED ?     LI375*/+
    DO                               /* PROCESS POPTHINT        LI375*/
      IF &SUBSTR(1,&NRSTR(&POPTHINT)) ^= &STR(') THEN  /* START LI375*/+
        DO                           /* INSURE QUOTED STRING    LI375*/
          SET &POPTHINT = &STR(')&NRSTR(&POPTHINT) /* ADD LI375      */
          SET &PQYE = &SYSINDEX(',&NRSTR(&POPTHINT),2) /* END   LI375*/
          IF &PQYE = 0 THEN          /* ENDING QUOTE ?          LI375*/+
            SET &POPTHINT = &NRSTR(&POPTHINT)&STR(') /* ADD     LI375*/
        END                          /* NOW QUOTED STRING       LI375*/
      IF &LENGTH(&NRSTR(&POPTHINT)) > 10 THEN /* > MAX LENGTH ? LI375*/+
        SET &QYERR = 8               /* REMEMBER THE ERROR      LI375*/
      IF &QYERR ^= 0 THEN            /* ANY ERRORS ?            LI375*/+
        DO                           /* ISSUE THE ERROR MESSAGE LI375*/
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN POPTHINT VALUE SPECIFIED        LI375*/
          /*---------------------------------------------------------*/
          SET &PQYOPT = &STR()       /* SET KEYWORD NULL        LI375*/
          SET &ERROR = 8             /* REMEMBER THE ERROR      LI375*/
          WRITE &M751 POPTHINT VALUE &POPTHINT
        END                          /* END OF ERROR SETTING    LI375*/
      ELSE                           /* THIS IS AN ERROR        LI375*/+
        SET &PQYOPT = &NRSTR(OPTHINT(&POPTHINT)) /* KEYWORD     LI375*/
    END                              /* OPTHINT COMPLETE        LI375*/
  ELSE                               /* OPTHINT IS NONE         LI375*/+
    SET &PQYOPT = &STR()             /* SET KEYWORD NULL        LI375*/
  /*******************************************************************/
  /*                                                            LI333*/
  /*              BIND PACKAGE PATH (SCHEMA) KEYWORD            LI333*/
  /*                                                            LI333*/
  /*  PPATH(SCHEMA LIST) OR PPATH(NONE)                         LI333*/
  /*                                                            LI333*/
  /*******************************************************************/
  IF &NRSTR(&PPATH) = NONE THEN     /* IF KEYWORD NOT SPECIFIED LI333*/+
    SET BPPATHS =                   /* NO KEYWORD SPECIFIED     LI333*/
  ELSE                              /* PATH LIST FOR PACKAGE    LI333*/+
    SET &BPPATHS = &NRSTR(PATH(&PPATH)) /* ADD PATH KEYWORD     LI333*/
                                                               /*<@10*/
  /*******************************************************************/
  /*                                                                 */
  /*               PENCODING KEYWORD OPTION                          */
  /*                                                                 */
  /*  INDICATE ENCODING OPTION FOR BIND PACKAGE                      */
  /*                                                                 */
  /*  PARMS:   ASCII|EBCDIC|UNICODE|ccsid or NONE                    */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &STR(&PENCODING) ^= NONE THEN          /* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CHECK PENCODING     */
      IF &SUBSTR(1,&PENCODING)= A THEN          /* SPECIFY ASCII ?   */+
        SET &PENCOD = &STR(ENCODING(ASCII))     /*   SET ASCII       */
      ELSE IF &SUBSTR(1,&PENCODING) = E THEN    /* SPECIFY EBCDIC ?  */+
        SET &PENCOD = &STR(ENCODING(EBCDIC))    /*   SET EBCDIC      */
      ELSE IF &SUBSTR(1,&PENCODING) = U THEN    /* SPECIFY UNICODE ? */+
        SET &PENCOD = &STR(ENCODING(UNICODE))   /*   SET UNICODE     */
      ELSE IF &DATATYPE(&PENCODING) = NUM THEN  /* SPECIFY NUMERIC ? */+
        SET &PENCOD = &NRSTR(ENCODING(&PENCODING))
      ELSE                                      /* THIS IS AN ERROR  */+
        DO                                      /*   ISSUE ERROR MSG */
          /*---------------------------------------------------------*/
          /* DSNH751I: ERROR IN PENCODING VALUE SPECIFIED            */
          /*---------------------------------------------------------*/
          SET &PENCOD = &STR()                  /*   SET KEYWORD NULL*/
          SET &ERROR = 8                        /*   REMEMBER ERROR  */
          WRITE &M751 PENCODING VALUE &PENCODING
        END                                     /* END OF ERROR      */
    END                                     /*   PENCODING COMPLETE  */
  ELSE                                      /* PENCODING IS NULL     */+
    SET &PENCOD = &STR()                    /*   SET KEYWORD NULL    */
  /*******************************************************************/
  /*                                                                 */
  /*               PIMMEDWRITE KEYWORD OPTION                        */
  /*                                                                 */
  /*  INDICATE IMMEDWRITE OPTION FOR BIND PACKAGE                    */
  /*  PARMS:   YES, NO, INHERITFROMPLAN, or NONE                     */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &STR(&PIMMEDWRITE) ^= NONE THEN        /* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CHECK PIMMEDWRITE   */
      IF &SUBSTR(1,&PIMMEDWRITE)= Y THEN        /* SPECIFY YES ?     */+
        SET &PIMWRI = &STR(IMMEDWRITE(YES))     /*   SET YES         */
      ELSE IF &SUBSTR(1,&PIMMEDWRITE) = N THEN  /* SPECIFY NO ?      */+
        SET &PIMWRI = &STR(IMMEDWRITE(NO))      /*   SET NO          */
      ELSE IF &SUBSTR(1,&PIMMEDWRITE) = I THEN  /* INHERITFROMPLAN?  */+
        SET &PIMWRI                             /*   SET             */+
          = &STR(IMMEDWRITE(INHERITFROMPLAN))   /*   INHERITFROMPLAN */
      ELSE                                      /* THIS IS AN ERROR  */+
       DO                                       /*   ISSUE ERROR MSG */
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PIMMEDWRITE VALUE SPECIFIED           */
         /*----------------------------------------------------------*/
         SET &PIMWRI = &STR()                   /*   SET KEYWORD NULL*/
         SET &ERROR = 8                         /*   REMEMBER ERROR  */
         WRITE &M751 PIMMEDWRITE VALUE &PIMMEDWRITE
       END                                      /* END OF ERROR      */
    END                                     /*   PIMMEDWRITE COMPLETE*/
  ELSE                                      /* PIMMEDWRITE IS NULL   */+
    SET &PIMWRI = &STR()                    /*   SET KEYWORD NULL    */
  /*******************************************************************/
  /*                                                                 */
  /*               PAPREUSE KEYWORD OPTION                           */
  /*                                                                 */
  /*  INDICATE APREUSE OPTION FOR BIND PACKAGE                       */
  /*  PARMS:   NONE, ERROR, WARN                                     */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &STR(&PAPREUSE) ^= NONE THEN           /* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CHECK PAPREUSE      */
      IF &SUBSTR(1,&PAPREUSE)= E THEN           /* SPECIFY ERROR ?   */+
        SET &PAPREU = &STR(APREUSE(ERROR))      /*   SET ERROR       */
      ELSE IF &SUBSTR(1,&PAPREUSE) = W THEN     /* SPECIFY WARN ?    */+
        SET &PAPREU = &STR(APREUSE(WARN))       /*   SET WARN        */
      ELSE                                      /* THIS IS AN ERROR  */+
       DO                                       /*   ISSUE ERROR MSG */
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PAPREUSE VALUE SPECIFIED              */
         /*----------------------------------------------------------*/
         SET &PAPREU = &STR()                   /*   SET KEYWORD NULL*/
         SET &ERROR = 8                         /*   REMEMBER ERROR  */
         WRITE &M751 PAPREUSE VALUE &PAPREUSE
       END                                      /* END OF ERROR      */
    END                                     /*   PAPREUSE COMPLETE   */
  ELSE                                      /* PAPREUSE IS NULL      */+
    SET &PAPREU = &STR()                    /*   SET KEYWORD NULL    */
  /*******************************************************************/
  /*                                                                 */
  /*               PAPCOMPARE KEYWORD OPTION                         */
  /*                                                                 */
  /*  INDICATE APCOMPARE OPTION FOR BIND PACKAGE                     */
  /*  PARMS:   NONE, ERROR, WARN                                     */
  /*  DEFAULT: NONE                                                  */
  /*******************************************************************/
  IF &STR(&PAPCOMPARE) ^= NONE THEN         /* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CHECK PAPCOMPARE    */
      IF &SUBSTR(1,&PAPCOMPARE)= E THEN         /* SPECIFY ERROR ?   */+
        SET &PAPCOM = &STR(APCOMPARE(ERROR))    /*   SET ERROR       */
      ELSE IF &SUBSTR(1,&PAPCOMPARE) = W THEN   /* SPECIFY WARN ?    */+
        SET &PAPCOM = &STR(APCOMPARE(WARN))     /*   SET WARN        */
      ELSE                                      /* THIS IS AN ERROR  */+
       DO                                       /*   ISSUE ERROR MSG */
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PAPCOMPARE VALUE SPECIFIED            */
         /*----------------------------------------------------------*/
         SET &PAPCOM = &STR()                   /*   SET KEYWORD NULL*/
         SET &ERROR = 8                         /*   REMEMBER ERROR  */
         WRITE &M751 PAPCOMPARE VALUE &PAPCOMPARE
       END                                      /* END OF ERROR      */
    END                                     /*   PAPCOMPARE COMPLETE */
  ELSE                                      /* PAPCOMPARE IS NULL    */+
    SET &PAPCOM = &STR()                    /*   SET KEYWORD NULL    */
  /*******************************************************************/
  /*                                                                 */
  /*               PSYSTIMESENSITIVE KEYWORD OPTION                  */
  /*                                                                 */
  /*  INDICATE SYSTIMESENSITIVE OPTION FOR BIND PACKAGE              */
  /*  PARMS:   blank, NO, or YES                                     */
  /*  DEFAULT: blank                                                 */
  /*******************************************************************/
  IF &STR(&PSYSTIMESENSITIVE) ^= &STR() THEN/* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CK PSYSTIMESENSITIVE*/
      IF &SUBSTR(1,&PSYSTIMESENSITIVE)= N THEN  /* SPECIFY NO ?      */+
        SET &PSTSEN = &STR(SYSTIMESENSITIVE(NO))  /* SET NO          */
      ELSE IF &SUBSTR(1,&PSYSTIMESENSITIVE) = Y THEN /* SPECIFY YES ?*/+
        SET &PSTSEN = &STR(SYSTIMESENSITIVE(YES))    /*   SET WARN   */
      ELSE                                      /* THIS IS AN ERROR  */+
       DO                                       /*   ISSUE ERROR MSG */
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PSYSTIMESENSITIVE VALUE SPECIFIED     */
         /*----------------------------------------------------------*/
         SET &PSTSEN = &STR()                   /*   SET KEYWORD NULL*/
         SET &ERROR = 8                         /*   REMEMBER ERROR  */
         WRITE &M751 PSYSTIMESENSITIVE VALUE &PSYSTIMESENSITIVE
       END                                      /* END OF ERROR      */
    END                                     /*   PSYSTIMESENSITIVE CP*/
  ELSE                                      /* PSYSTIMESENSITIVE NULL*/+
    SET &PSTSEN = &STR()                    /*   SET KEYWORD NULL    */
  /*******************************************************************/
  /*                                                                 */
  /*               PBUSTIMESENSITIVE KEYWORD OPTION                  */
  /*                                                                 */
  /*  INDICATE BUSTIMESENSITIVE OPTION FOR BIND PACKAGE              */
  /*  PARMS:   blank, NO, or YES                                     */
  /*  DEFAULT: blank                                                 */
  /*******************************************************************/
  IF &STR(&PBUSTIMESENSITIVE) ^= &STR() THEN/* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CK PBUSTIMESENSITIVE*/
      IF &SUBSTR(1,&PBUSTIMESENSITIVE)= N THEN  /* SPECIFY NO ?      */+
        SET &PBTSEN = &STR(BUSTIMESENSITIVE(NO))  /* SET NO          */
      ELSE IF &SUBSTR(1,&PBUSTIMESENSITIVE) = Y THEN /* SPECIFY YES ?*/+
        SET &PBTSEN = &STR(BUSTIMESENSITIVE(YES))    /*   SET WARN   */
      ELSE                                      /* THIS IS AN ERROR  */+
       DO                                       /*   ISSUE ERROR MSG */
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PBUSTIMESENSITIVE VALUE SPECIFIED     */
         /*----------------------------------------------------------*/
         SET &PBTSEN = &STR()                   /*   SET KEYWORD NULL*/
         SET &ERROR = 8                         /*   REMEMBER ERROR  */
         WRITE &M751 PBUSTIMESENSITIVE VALUE &PBUSTIMESENSITIVE
       END                                      /* END OF ERROR      */
    END                                     /*   PBUSTIMESENSITIVE CP*/
  ELSE                                      /* PBUSTIMESENSITIVE NULL*/+
    SET &PBTSEN = &STR()                    /*   SET KEYWORD NULL    */
  /*******************************************************************/
  /*                                                                 */
  /*               PARCHIVESENSITIVE KEYWORD OPTION                  */
  /*                                                                 */
  /*  INDICATE ARCHIVESENSITIVE OPTION FOR BIND PACKAGE              */
  /*  PARMS:   blank, NO, or YES                                     */
  /*  DEFAULT: blank                                                 */
  /*******************************************************************/
  IF &STR(&PARCHIVESENSITIVE) ^= &STR() THEN/* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CK PARCHIVESENSITIVE*/
      IF &SUBSTR(1,&PARCHIVESENSITIVE)= N THEN  /* SPECIFY NO ?      */+
        SET &PARSEN = &STR(ARCHIVESENSITIVE(NO))  /* SET NO          */
      ELSE IF &SUBSTR(1,&PARCHIVESENSITIVE) = Y THEN /* SPECIFY YES ?*/+
        SET &PARSEN = &STR(ARCHIVESENSITIVE(YES))    /*   SET WARN   */
      ELSE                                      /* THIS IS AN ERROR  */+
       DO                                       /*   ISSUE ERROR MSG */
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PARCHIVESENSITIVE VALUE SPECIFIED     */
         /*----------------------------------------------------------*/
         SET &PARSEN = &STR()                   /*   SET KEYWORD NULL*/
         SET &ERROR = 8                         /*   REMEMBER ERROR  */
         WRITE &M751 PARCHIVESENSITIVE VALUE &PARCHIVESENSITIVE
       END                                      /* END OF ERROR      */
    END                                     /*   PARCHIVESENSITIVE CP*/
  ELSE                                      /* PARCHIVESENSITIVE NULL*/+
    SET &PARSEN = &STR()                    /*   SET KEYWORD NULL    */
  /*******************************************************************/
  /*                                                                 */
  /*               PAPPLCOMPAT KEYWORD OPTION                        */
  /*                                                                 */
  /*  INDICATE APPLCOMPAT OPTION FOR BIND PACKAGE                    */
  /*  PARMS:   blank, V10R1, or V11R1                                */
  /*  DEFAULT: blank                                                 */
  /*******************************************************************/
  IF &STR(&PAPPLCOMPAT) ^= &STR() THEN      /* KEYWORD SPECIFIED ?   */+
    DO                                      /*   CHECK PAPPLCOMPAT   */
      IF &STR(&PAPPLCOMPAT) = V10R1 THEN        /* SPECIFY V10R1 ?   */+
        SET &PAPCPT = &STR(APPLCOMPAT(V10R1))   /*   SET V10R1       */
      ELSE IF &STR(&PAPPLCOMPAT) = V11R1 THEN   /* SPECIFY V11R1 ?   */+
        SET &PAPCPT = &STR(APPLCOMPAT(V11R1))   /*   SET V11R1       */
      ELSE                                      /* THIS IS AN ERROR  */+
       DO                                       /*   ISSUE ERROR MSG */
         /*----------------------------------------------------------*/
         /* DSNH751I: ERROR IN PAPPLCOMPAT VALUE SPECIFIED           */
         /*----------------------------------------------------------*/
         SET &PAPCPT = &STR()                   /*   SET KEYWORD NULL*/
         SET &ERROR = 8                         /*   REMEMBER ERROR  */
         WRITE &M751 PAPPLCOMPAT VALUE &PAPPLCOMPAT
       END                                      /* END OF ERROR      */
    END                                     /*   PAPPLCOMPAT COMPLETE*/
  ELSE                                      /* PAPPLCOMPAT NULL      */+
    SET &PAPCPT = &STR()                    /*   SET KEYWORD NULL    */
                                                               /*>@10*/
    /*****************************************************************/
    /*                                                               */
    /*                  END OF PACKAGE KEYWORDS                      */
    /*                                                               */
    /*****************************************************************/
    /*****************************************************************/
    /*                                                               */
    /*               ADD APOSTROPHIES (') TO KEYWORDS                */
    /*                                                               */
    /* ADD APOSTROPHES ON ANY KEYWORD PARAMETERS THAT MUST CONTINUE  */
    /* TO BE ENCLOSED IN APOSTROPHIES THROUGH CALLS TO OTHER TSO OR  */
    /* CLIST FUNCTIONS                                               */
    /*                                                               */
    /*****************************************************************/
    IF &SUBSTR(1,&CCMSGS) EQ &STR(') THEN    /* IF 1 APOST           */+
       SET &QCMSGS = &STR(''&CCMSGS'')       /* ADD APOSTROPHES      */
      ELSE SET &QCMSGS = &STR(&CCMSGS)       /* ASSIGN VALUE         */
    IF &SUBSTR(1,&CCSLIB) EQ &STR(') THEN    /* IF 1 APOST           */+
       SET &QCSLIB = &STR(''&CCSLIB'')       /* ADD APOSTROPHES      */
      ELSE SET &QCSLIB = &STR(&CCSLIB)       /* ASSIGN VALUE         */
    IF &SUBSTR(1,&CICSCLIB) EQ &STR(') THEN  /* IF 1 APOST    KEW0324*/+
       SET &QCICSCLIB = &STR(''&CICSCLIB'')  /* ADD APOSTROPHEKEW0324*/
    ELSE SET &QCICSCLIB = &STR(&CICSCLIB)    /* OR JUST ASSIGNKEW0324*/
    IF &SUBSTR(1,&CICSPLIB) EQ &STR(') THEN  /* IF 1 APOST    KEW0324*/+
       SET &QCICSPLIB = &STR(''&CICSPLIB'')  /* ADD APOSTROPHEKEW0324*/
    ELSE SET &QCICSPLIB = &STR(&CICSPLIB)    /* OR JUST ASSIGNKEW0324*/
    IF &SUBSTR(1,&CLIB) EQ &STR(') THEN      /* IF 1 APOST           */+
       SET &QCLIB = &STR(''&CLIB'')          /* ADD APOSTROPHES      */
    ELSE SET &QCLIB = &STR(&CLIB)            /* OR JUST ASSIGN VALUE */
    /*---------------------------------------------------*/
    /* IF COMPILER OPTIONS HAVE IMBEDDED APOSTROPHES     */
    /* THAT ARE NOT ALREADY DOUBLED, DOUBLE THEM KDB2036 */
    /*---------------------------------------------------*/
    SET &CLEN = &LENGTH(&NRSTR(&COPTION))
    SET &CNT  = 2
    SET &APOSTPOS = 1
    IF &SUBSTR(1:1,&COPTION) NE &STR(') THEN +
     DO WHILE &CNT LT &CLEN AND &APOSTPOS NE 0
      SET &APOSTPOS = &SYSINDEX(&STR('),&STR(&COPTION),&CNT)    /*@39*/
      IF &APOSTPOS NE 0 THEN                                    /*@01*/+
        IF &APOSTPOS EQ &CLEN THEN                              /*@01*/+
          DO                                                    /*@01*/
            SET &COPTION = &COPTION&STR(')                      /*@01*/
            SET &CLEN = &CLEN + 1                               /*@01*/
            SET &CNT  = &APOSTPOS + 2                           /*@01*/
          END                                                   /*@01*/
        ELSE IF &APOSTPOS LT &CLEN AND                          /*@01*/+
         &SUBSTR(&APOSTPOS+1,&COPTION) NE &STR(') THEN +
          DO
            SET &COPTION = &SUBSTR(1:&APOSTPOS,+
             &COPTION)&STR(')+
             &SUBSTR(&APOSTPOS+1:&CLEN,&COPTION)
            SET &CLEN = &CLEN + 1
            SET &CNT  = &APOSTPOS + 2
          END
     END                                     /* END OF KDB2036       */
    IF &SUBSTR(1,&COPTION) EQ &STR(') THEN   /* IF 1 APOST           */+
       SET &QCOPTION = &STR(''&COPTION'')    /* ADD APOSTROPHES      */
    ELSE SET &QCOPTION = &STR('&COPTION')    /* ASSIGN VALUE         */
    IF &SUBSTR(1,&C2LIB) EQ &STR(') THEN     /* IF 1 APOST           */+
       SET &QC2LIB = &STR(''&C2LIB'')        /* ADD APOSTROPHES      */
    ELSE SET &QC2LIB = &STR(&C2LIB)          /* JUST ASSIGN VALUE    */
    IF &SUBSTR(1,&C3LIB) EQ &STR(') THEN     /* IF 1 APOST           */+
       SET &QC3LIB = &STR(''&C3LIB'')        /* ADD APOSTROPHES      */
    ELSE SET &QC3LIB = &STR(&C3LIB)          /* JUST ASSIGN VALUE    */
    IF &SUBSTR(1,&C4LIB) EQ &STR(') THEN     /* IF 1 APOST           */+
       SET &QC4LIB = &STR(''&C4LIB'')        /* ADD APOSTROPHES      */
    ELSE SET &QC4LIB = &STR(&C4LIB)          /* JUST ASSIGN VALUE    */
    IF &SUBSTR(1,&PRECIN) EQ &STR(') THEN    /* IF 1 APOST           */+
       SET &QPRECIN = &STR(''&PRECIN'')      /* ADD APOSTROPHES      */
    ELSE SET &QPRECIN = &STR(&PRECIN)        /* ASSIGN VALUE         */
    IF &SUBSTR(1,&TERM) EQ &STR(') THEN      /* IF 1 APOST           */+
       SET &QTERM = &STR(''&TERM'')          /* ADD APOSTROPHES      */
      ELSE SET &QTERM = &STR(&TERM)          /* ASSIGN VALUE         */
    IF &SUBSTR(1,&ASMLIB) EQ &STR(') THEN    /* IF 1 APOST           */+
       SET &QASML = &STR(''&ASMLIB'')        /* ADD APOSTROPHES      */
      ELSE SET &QASML = &STR(&ASMLIB)        /* ASSIGN VALUE         */
    IF &SUBSTR(1,&ASMLOAD) EQ &STR(') THEN   /* IF 1 APOST           */+
       SET &QASM = &STR(''&ASMLOAD'')        /* ADD APOSTROPHES      */
      ELSE SET &QASM = &STR(&ASMLOAD)        /* ASSIGN VALUE         */
    IF &SUBSTR(1,&COBLOAD) EQ &STR(') THEN   /* IF 1 APOST           */+
       SET &QCOB = &STR(''&COBLOAD'')        /* ADD APOSTROPHES      */
      ELSE SET &QCOB = &STR(&COBLOAD)        /* ASSIGN VALUE         */
    IF &SUBSTR(1,&COB2LOAD) EQ &STR(') THEN  /* IF 1 APOST           */+
       SET &QCOB2 = &STR(''&COB2LOAD'')      /* ADD APOSTROPHES      */
      ELSE SET &QCOB2 = &STR(&COB2LOAD)      /* ASSIGN VALUE         */
    IF &SUBSTR(1,&FORTLOAD) EQ &STR(') THEN  /* IF 1 APOST           */+
       SET &QFORT = &STR(''&FORTLOAD'')      /* ADD APOSTROPHES      */
      ELSE SET &QFORT = &STR(&FORTLOAD)      /* ASSIGN VALUE         */
    IF &SUBSTR(1,&PLILOAD) EQ &STR(') THEN   /* IF 1 APOST           */+
       SET &QPLI = &STR(''&PLILOAD'')        /* ADD APOSTROPHES      */
      ELSE SET &QPLI = &STR(&PLILOAD)        /* ASSIGN VALUE         */
    IF &SUBSTR(1,&CCLOAD) EQ &STR(') THEN    /* IF 1 APOST           */+
       SET &QCLOAD = &STR(''&CCLOAD'')       /* ADD APOSTROPHES      */
      ELSE SET &QCLOAD = &STR(&CCLOAD)       /* ASSIGN VALUE         */
    IF &SUBSTR(1,&COBICOMP) EQ &STR(') THEN  /* IF 1 APOST      LI319*/+
       SET &QCOBOO = &STR(''&COBICOMP'')     /* ADD APOSTROPHES LI319*/
      ELSE SET &QCOBOO = &STR(&COBICOMP)     /* ASSIGN VALUE    LI319*/
    IF &SUBSTR(1,&CPPUTIL) EQ &STR(') THEN   /* IF 1 APOST      LI319*/+
       SET &QCPUTIL = &STR(''&CPPUTIL'')     /* ADD APOSTROPHES LI319*/
      ELSE SET &QCPUTIL = &STR(&CPPUTIL)     /* ASSIGN VALUE    LI319*/
    IF &SUBSTR(1,&CPPCSLIB) EQ &STR(') THEN  /* IF 1 APOST      LI319*/+
       SET &QCPCSLIB = &STR(''&CPPCSLIB'')   /* ADD APOSTROPHES LI319*/
      ELSE SET &QCPCSLIB = &STR(&CPPCSLIB)   /* ASSIGN VALUE    LI319*/
    IF &SUBSTR(1,&CPPSLIB) EQ &STR(') THEN   /* IF 1 APOST      LI319*/+
       SET &QCPSLIB = &STR(''&CPPSLIB'')     /* ADD APOSTROPHES LI319*/
      ELSE SET &QCPSLIB = &STR(&CPPSLIB)     /* ASSIGN VALUE    LI319*/
    /*****************************************************************/
    /*                                                               */
    /*               VALIDATE DSNH KEYWORD PARAMETERS                */
    /*                                                               */
    /* VALIDATE DSNH KEYWORD PARAMETERS FOR CONSISTENCY, AND DO      */
    /* NOT PERMIT THE BYPASSING OF INTERMEDIATE STEPS IN THE         */
    /* DSNH PROCESS                                                  */
    /*                                                               */
    /*****************************************************************/
    IF (&MACRO EQ YES AND &SUFF = PLI AND                              +
        &PRECOMP EQ NO)  THEN                                          +
       DO                           /* CORRECT THE SITUATION         */
        /*-----------------------------------------------------------*/
        /* DSNH741I: PRECOMP(NO) IMPLIES COMPILE CANNOT BE RUN       */
        /*-----------------------------------------------------------*/
         SET &COMPILE = NO          /* DON'T ALLOW THE COMPILE       */
         IF &ERROR LT 4 THEN SET &ERROR = 4     /* WARNING FLAG      */
         WRITE DSNH741I PRECOMP(NO) IMPLIES THAT COMPILE CANNOT BE RUN
       END
    IF (&PRECOMP EQ YES AND &CICSXLAT = NO AND                 +
        &COMPILE EQ YES AND &ATTACH = CICS    )  THEN          +
       DO                           /* CORRECT THE SITUATION         */
         /*----------------------------------------------------------*/
         /* DSNH741I: CICSXLAT(NO) IMPLIES COMPILE CANNOT BE RUN     */
         /*----------------------------------------------------------*/
         SET &COMPILE = NO          /* DON'T ALLOW THE COMPILE       */
         IF &ERROR LT 4 THEN SET &ERROR = 4  /* WARNING FLAG         */
         WRITE DSNH741I CICSXLAT(NO) IMPLIES THAT COMPILE CANNOT BE RUN
       END
    IF (&PRECOMP EQ YES AND &COMPILE = NO AND                          +
        &LINK EQ YES) THEN                                             +
       DO                           /* CORRECT THE SITUATION         */
         /*----------------------------------------------------------*/
         /* DSNH741I: COMPILE(NO) IMPLIES LINK CANNOT BE RUN         */
         /*----------------------------------------------------------*/
         SET &LINK = NO             /* DON'T ALLOW THE LINK          */
         IF &ERROR LT 4 THEN SET &ERROR = 4  /* WARNING FLAG         */
         WRITE DSNH741I COMPILE(NO) IMPLIES THAT LINK CANNOT BE RUN
       END                          /* CORRECT THE SITUATION         */
    IF (&PRECOMP EQ YES AND &COMPILE = NO AND                          +
        &RUN EQ YES) THEN                                              +
       DO                           /* CORRECT THE SITUATION         */
         /*----------------------------------------------------------*/
         /* DSNH741I: COMPILE(NO) IMPLIES RUN CANNOT BE DONE         */
         /*----------------------------------------------------------*/
         SET &RUN  = NO             /* DON'T ALLOW THE RUN           */
         IF &ERROR LT 4 THEN SET &ERROR = 4  /* WARNING FLAG         */
         WRITE DSNH741I COMPILE(NO) IMPLIES THAT RUN CANNOT BE DONE
       END
    IF (&COMPILE EQ YES AND &LINK = NO AND                             +
        &RUN EQ YES) THEN                                              +
       DO                           /* CORRECT THE SITUATION         */
         /*----------------------------------------------------------*/
         /* DSNH741I: LINK(NO) IMPLIES RUN CANNOT BE DONE            */
         /*----------------------------------------------------------*/
         SET &RUN  = NO             /* DON'T ALLOW THE RUN           */
         IF &ERROR LT 4 THEN SET &ERROR = 4  /* WARNING FLAG         */
         WRITE DSNH741I LINK(NO) IMPLIES THAT RUN CANNOT BE DONE
       END
    IF ((&PRECOMP EQ YES AND (&BIND = NO AND &PBIND = NO) AND          +
        &RUN EQ YES)) THEN                                             +
       DO                           /* CORRECT THE SITUATION         */
         /*----------------------------------------------------------*/
         /* DSNH741I: BIND(NO) IMPLIES RUN CANNOT BE DONE            */
         /*----------------------------------------------------------*/
         SET &RUN  = NO             /* DON'T ALLOW THE RUN           */
         IF &ERROR LT 4 THEN SET &ERROR = 4  /* WARNING FLAG         */
         WRITE DSNH741I BIND(NO) IMPLIES THAT RUN CANNOT BE DONE
       END
  IF &ERROR GE &RCTERM THEN         /* IF MAX RET CODE EXCEEDED      */+
    DO                              /* ISSUE MESSAGE AND EXIT        */
      /*-------------------------------------------------------------*/
      /* DSNH759I: CLIST TERMINATING DUE TO ERRORS                   */
      /*-------------------------------------------------------------*/
      WRITE &M759 CLIST CHECKING RC = &ERROR
      EXIT CODE(&ERROR)             /* EXIT FROM CLIST, SYNTAX       */
    END                             /* OF ERROR HANDLING             */
  /*******************************************************************/
  /*  SAVE USERS ENVIRONMENT OF SYSPRINT, SYSTERM, SYSIN     @BA44366*/
  /*******************************************************************/
  SET MODPRINT =                    /*                       @BA44366*/
  SET MODTERM  =                    /*                       @BA44366*/
  SET MODSYSIN =                    /*                       @BA44366*/
  LISTDSI SYSPRINT FILE             /*                       @BA44366*/
  SET &SAVECC = &LASTCC             /*                       @BA44366*/
  IF (&SAVECC = 0) AND (&SYSDSORG = PS) THEN /*              @BA44366*/+
    DO                                  /*                   @BA44366*/
       SET &SAVEPRINT = &STR('&SYSDSNAME') /*                @BA44366*/
       SET MODPRINT = MOD           /*                       @BA44366*/
    END                                 /*                   @BA44366*/
  ELSE                              /*                       @BA44366*/+
    SET &SAVEPRINT = &STR(*)        /*                       @BA44366*/
  LISTDSI SYSTERM FILE              /*                       @BA44366*/
  SET &SAVECC = &LASTCC             /*                       @BA44366*/
  IF (&SAVECC = 0) AND (&SYSDSORG = PS) THEN /*              @BA44366*/+
    DO                                  /*                   @BA44366*/
       SET &SAVETERM = &STR('&SYSDSNAME')   /*               @BA44366*/
       SET MODTERM  = MOD           /*                       @BA44366*/
    END                                 /*                   @BA44366*/
  ELSE                              /*                       @BA44366*/+
    SET &SAVETERM  = &STR(*)        /*                       @BA44366*/
  LISTDSI SYSIN FILE                /*                       @BA44366*/
  SET &SAVECC = &LASTCC             /*                       @BA44366*/
  IF (&SAVECC = 0) AND (&SYSDSORG = PS) THEN /*              @BA44366*/+
    DO                                  /*                   @BA44366*/
       SET &SAVESYSIN = &STR('&SYSDSNAME')     /*            @BA44366*/
       SET MODSYSIN = MOD           /*                       @BA44366*/
    END                                 /*                   @BA44366*/
  ELSE                              /*                       @BA44366*/+
    SET &SAVESYSIN = &STR(*)        /*                       @BA44366*/
  /*******************************************************************/
  /*                                                                 */
  /*                 INVOKE PLI MACRO PROCESSOR                      */
  /*                                                                 */
  /* INVOKED ROUTINE: DSNHC                                          */
  /*******************************************************************/
  IF &SUFF = PLI AND                /* PLI LANGUAGE                  */+
     &MACRO = YES THEN              /* MACRO PASS REQUESTED          */+
    DO                              /* INVOKE PLI PREPROCESSOR       */
      /*-------------------------------------------------------------*/
      /*          INVOKE PLI MACRO PROCESSOR                         */
      /*-------------------------------------------------------------*/
             &DSNHC                                         /*KEW0324*/+
           ATTACH(&ATTACH)                                  /*KEW0324*/+
           CICSCLIB(&QCICSCLIB) CICSPLIB(&QCICSPLIB)        /*KEW0324*/+
           CLIB(&QCLIB)                                     /*KEW0324*/+
           CONTROL(&CONTROL) COPTION(&QCOPTION) C2LIB(&QC2LIB)         +
           C3LIB(&QC3LIB) C4LIB(&QC4LIB) DELIMIT(&DELIMIT)             +
           FLAG(&FLAG) HOST(&HOST) LINECOUNT(&LINECOUNT)               +
           MACIN(&QPRECIN) OUTNAME(&OUTNAME) PRINT(&PRINT)             +
           PSPACE(&PSPACE) PSECSPAC(&PSECSPAC) SOURCE(&SOURCE)         +
           SPACEUN(&SPACEUN) TERM(&QTERM) WORKUNIT(&WORKUNIT)          +
           WSECSPAC(&WSECSPAC) WSPACE(&WSPACE) XREF(&XREF)             +
           ASMLIB(&QASML)                                              +
           ASMLOAD(&QASM) COBLOAD(&QCOB) COB2LOAD(&QCOB2)              +
           COBICOMP(&QCOBOO)                                 /* LI319*/+
           FORTLOAD(&QFORT) PLILOAD(&QPLI)                             +
           CCSLIB(&QCSLIB) CCLOAD(&QCLOAD) CCMSGS(&QCMSGS)             +
           CPPUTIL(&QCPUTIL) CPPSLIB(&QCPSLIB)               /* LI319*/+
           CPPCSLIB(&QCPCSLIB)                               /* LI319*/
      SET &DERROR = &LASTCC               /* IF DSNHC WORKED @BA18169*/
      IF &ERROR LT &DERROR THEN SET &ERROR = &DERROR /* SAVE RETCODE */
      IF &WALLF = YES THEN                /* IF PRINT NAME TO BE ADDE*/+
        SET &WALL4 = &STR(.LIST &WALLB)   /* PRINT DATA SET          */
      /*-------------------------------------------------------------*/
      /* DSNH740I: PLI MACRO PASS WALL MESSAGE                       */
      /*-------------------------------------------------------------*/
      WRITE &WALL1 PLI MACRO PASS &WALL2 &DERROR &WALL3.&WALL4
      IF &ERROR GE &RCTERM THEN           /* IF MAX RET CODE EXCEEDED*/+
        DO
          /*---------------------------------------------------------*/
          /* DSNH759I: PLI MACRO PASS ERROR                          */
          /*---------------------------------------------------------*/
          WRITE &M759 PLI MACRO PASS RC = &ERROR
          EXIT CODE(&ERROR)               /* EXIT FROM CLIST         */
        END                               /* OF ERROR HANDLING       */
      SET &PRECIN = &OUTNAME..DECK        /* INPUT FOR PRECOMPILER   */
    END                                   /* OF PLI MACRO PHASE      */
  /*******************************************************************/
  /*                                                                 */
  /*                 SETUP FOR PRECOMPILER INVOCATION                */
  /*                                                                 */
  /*******************************************************************/
  IF &PRECOMP = YES THEN         /* PRECOMPILE REQUESTED             */+
    DO                           /* INVOKE PRECOMPILER               */
      /*-------------------------------------------------------------*/
      /* DETERMINE HOST LANGUAGE, SETUP SPECIFIED KEYWORD VARIABLES, */
      /* ALLOCATE REQUIRED DATA SETS                                 */
      /*-------------------------------------------------------------*/
      IF &HOST = COB2            /* PC HOST PARM MUST BE: FORTRAN,   */+
        THEN SET &TEMPSUFF = COB2   /* COB2, COBOL, PLI OR ASM       */
        ELSE SET &TEMPSUFF = &SUFF
      /* TAKE LINECOUNT AND FLAG OUT OF STATEMENT BELOW AND PASS @27 */
      /* THEM ONLY IF THEY DO NOT HAVE THE DEFAULT VALUES.       @27 */
      /* USE THE ABBREVIATED FORM OF LINECOUNT (LC).             @27 */
      SET &OPT = HOST(&TEMPSUFF) &DATE &DECIMAL &SQL +
                 &GRAPHIC &TIME &CONNECT +
                 &FLOAT                                         /*@06*/
      IF &LINECOUNT NE 60 THEN SET &OPT = &OPT LC(&LINECOUNT)
      IF &FLAG NE I THEN SET &OPT = &OPT FLAG(&FLAG)
      IF &DECARTH NE DEFAULT THEN SET &OPT = &OPT &DECARTH
      IF &DELIMIT NE DEFAULT THEN SET &OPT = &OPT &DELIMIT
      IF &SQLDELIM NE DEFAULT THEN SET &OPT = &OPT &SQLDELIM
      IF &STDSQL NE NO THEN SET &OPT = &OPT STDSQL(&STDSQL)
      IF &CCSID NE DEFAULT THEN SET &OPT = &OPT CCSID(&CCSID)   /*@05*/
      IF &NEWFUN NE DEFAULT THEN SET &OPT = &OPT NEWFUN(&NEWFUN) /*@05*/
      IF &NOFOR  NE NO THEN SET &OPT = &OPT &NOFOR
      IF &PASS NE DEFAULT THEN SET &OPT = &OPT &PASS.PASS
      IF &OPTIONS = NO THEN SET &OPT = &OPT NOOPTIONS
      IF &SOURCE NE NO THEN SET &OPT = &OPT SOURCE
      IF &XREF NE NO THEN SET &OPT = &OPT XREF
      IF &ATTACH EQ CAF OR &ATTACH EQ RRSAF THEN                /*@06*/+
        SET &OPT = &OPT ATTACH(&ATTACH)                         /*@06*/
      /*-------------------------------------------------------------*/
      /* ALL ADDITIONS TO &OPT THAT REQUIRE &NRSTR SHOULD BE PLACED  */
      /* HERE. NO NON-&NRSTR VARIABLES SHOULD BE ADDED TO &OPT ONCE  */
      /* A &NRSTR VARIABLE HAS BEEN ADDED.                           */
      /*-------------------------------------------------------------*/
      IF &NRSTR(&BVERSION) ^= THEN +
         SET &OPT = &SYSNSUB(2,&OPT &NRSTR(&BVERSION))
      ALLOCATE DDNAME(SYSIN) SHR DSNAME(&PRECIN) REUSE
      IF &STR(&DBRMINP) = DEFAULT THEN /* DEFAULT THE DBRMLIB        */+
        DO                       /* ALLOCATE THE DBRMLIB             */
          /*---------------------------------------------------------*/
          /* DBRMLIB: ALLOCATE DBRMLIB DATA SET                      */
          /*---------------------------------------------------------*/
          IF &CONTROL = NONE THEN   /* IF NO MESSAGES USED           */+
            CONTROL NOMSG        /* AVOID DELETE MESSAGES            */
          DELETE &OUTNAME..DBRM  /* DELETE THE DATA SET              */
          FREE DDNAME(DBRMLIB) DSN(&OUTNAME..DBRM)    /* FREE        */
          CONTROL MSG            /* ALLOW MESSAGES AGAIN             */
          ALLOCATE DD(DBRMLIB) NEW SPACE(&WSPACE &WSECSPAC) +
            &SPACEUN DSNAME(&DBRMNAME) DIR(5) REUSE &WORKU
        END                      /* ALLOCATE THE DBRMLIB             */
      ELSE                       /* USE PROVIDED DBRMLIB             */+
        ALLOCATE DDNAME(DBRMLIB) DSNAME(&DBRMNAME) OLD REUSE
      /*-------------------------------------------------------------*/
      /* ALLOCATE INTERMEDIATE DATA SETS                             */
      /*-------------------------------------------------------------*/
      SET &PONL =
      IF &PLIB NE NONE THEN SET &PONL = &STR(&PLIB)
      IF &P2LIB NE NONE THEN SET &PONL = &STR(&PONL &P2LIB)
      IF &P3LIB NE NONE THEN SET &PONL = &STR(&PONL &P3LIB)
      IF &P4LIB NE NONE THEN SET &PONL = &STR(&PONL &P4LIB)
      IF &PONL NE      THEN      /* IF ALLOCATION REQUESTED          */+
        ALLOCATE DDNAME(SYSLIB) DSNAME(&PONL) SHR REUSE
      /*-------------------------------------------------------------*/
      /* ALLOCATE SYSUT1                                        LI319*/
      /*-------------------------------------------------------------*/
      ALLOCATE DDNAME(SYSUT1) NEW SPACE(&WSPACE &WSECSPAC)             +
         REUSE &SPACEUN &WORKU   /* ALLOCATE SYSUT1 ALWAYS           */
      /*-------------------------------------------------------------*/
      /* ALLOCATE SYSUT2 FOR: (COBOL, COB2, IBMCOB), FORTRAN    LI319*/
      /*-------------------------------------------------------------*/
      IF &SUFF = COBOL OR        /* SYSUT2 IS FOR COBOL, COB2   LI319*/+
         &SUFF = IBMCOB OR       /* SYSUT2 IS FOR IBMCOB        LI319*/+
         &SUFF = FORTRAN THEN    /* OR  FORTRAN                      */+
          ALLOCATE DD(SYSUT2) NEW SPACE(&WSPACE &WSECSPAC) +
             REUSE &SPACEUN &WORKU  /* ALLOCATE SYSUT2               */
      IF &CONTROL = NONE THEN    /* IF NO MESSAGES USED              */+
        CONTROL NOMSG            /* AVOID FREE, DEL MESSAGES         */
      SET &PCSUFF = &SUFF        /* SET THE NORMAL SUFFIX            */
      IF &ATTACH   = CICS THEN   /* CICS XLATE USEFUL THEN           */+
         SET &PCSUFF = CICSIN    /* NOTE THIS IS CICS INPUT          */
      FREE DDNAME(SYSCIN) ATTR(DSNHF80)   /* FREE DDNAME,ATTR        */
      DELETE &OUTNAME..&PCSUFF   /* DELETE OUTPUT DATA SET           */
      CONTROL MSG                /* ALLOW MESSAGES AGAIN             */
      /*-------------------------------------------------------------*/
      /* DSNHF80: DEFINE DCB ATTRIBUTES                              */
      /*-------------------------------------------------------------*/
      ATTRIB DSNHF80 LRECL(80) RECFM(F B) BLKSIZE(4000)  /* SETUP DCB*/
      ALLOCATE DDNAME(SYSCIN) NEW &SPACEUN &WORKU +
         SPACE(&WSPACE &WSECSPAC) REUSE           +
         USING(DSNHF80) DSNAME(&OUTNAME..&PCSUFF)        /* PC OUTPUT*/
      IF &CONTROL = NONE THEN    /* IF NO MESSAGES USED              */+
        CONTROL NOMSG            /* AVOID FREE MESSAGES              */
      IF &PRINT NE LEAVE THEN    /* IF ALLOCATION REQUESTED          */+
        FREE DDNAME(SYSPRINT)    /* FREE THE DDNAME                  */
      IF &TERM  NE LEAVE THEN    /* IF ALLOCATION REQUESTED          */+
        FREE DDNAME(SYSTERM)     /* FREE THE DDNAME                  */
      CONTROL MSG                /* ALLOW MESSAGES AGAIN             */
      IF &PRINT NE NONE AND      /* IF ALLOCATION REQUESTED          */+
         &PRINT NE LEAVE THEN    /* IF ALLOCATION REQUESTED          */+
        DO                       /* ALLOCATE DATA SET (OLD)          */
          /*---------------------------------------------------------*/
          /* ALLOCATE SYSPRINT TO TERMINAL                           */
          /*---------------------------------------------------------*/
          IF &PRINT = TERM THEN  /* IF TERM OUTPUT RQSTD             */+
            ALLOCATE DDNAME(SYSPRINT) DA(*)  /* DO TERM ALLOC        */
          ELSE                   /* ALLOCATE A DATA SET              */+
            DO                   /* DELETE, THEN ALLOC DATA          */
              /*-----------------------------------------------------*/
              /* ALLOCATE SYSPRINT TO DATA SET                       */
              /*-----------------------------------------------------*/
              IF &CONTROL = NONE THEN  /* IF NO MESSAGES             */+
                CONTROL NOMSG          /* AVOID DELETE MESSAGES      */
              DELETE &PRINT..PCLIST    /* DELETE OUTPUT DATA SET     */
              FREE DDNAME(SYSPRINT)    /* FREE DDNAME                */
              CONTROL MSG              /* ALLOW MESSAGES AGAIN       */
              ALLOCATE DDNAME(SYSPRINT) DSNAME(&PRINT..PCLIST) NEW +
                SPACE(&PSPACE &PSECSPAC) &SPACEUN &WORKU
            END                        /* DELETE, THEN ALLOC DATA    */
        END                            /* SYSPRINT IS ALLOCATED      */
      IF &PRINT = NONE   THEN          /* IF NO PRINT   REQUESTED    */+
        ALLOCATE DDNAME(SYSPRINT) DUMMY   /* SET DUMMY FOR IT        */
      IF &TERM NE NONE AND             /* IF ALLOCATION REQUESTED    */+
         &TERM  NE LEAVE THEN          /* IF ALLOCATION REQUESTED    */+
        DO                             /* ALLOCATE A DATA SET (OLD)  */
          /*---------------------------------------------------------*/
          /* ALLOCATE SYSTERM TO TERMINAL                            */
          /*---------------------------------------------------------*/
          IF &TERM = TERM THEN         /* IF TERMINAL OUTPUT REQUESTD*/+
            ALLOCATE DDNAME(SYSTERM) DA(*)   /* DO TERM ALLOC        */
          ELSE                         /* ALLOCATE A DATA SET        */+
            DO                         /* DELETE, THEN ALLOC DATA    */
              /*-----------------------------------------------------*/
              /* ALLOCATE SYSTERM TO DATA SET                        */
              /*-----------------------------------------------------*/
              IF &CONTROL = NONE THEN  /* IF NO MESSAGES             */+
                CONTROL NOMSG          /* AVOID DELETE MESSAGES      */
              DELETE &TERM..PCTERM     /* DELETE OUTPUT DATA SET     */
              FREE DDNAME(SYSTERM)     /* FREE DDNAME                */
              CONTROL MSG              /* ALLOW MESSAGES AGAIN       */
              ALLOCATE DDNAME(SYSTERM) DSNAME(&TERM..PCTERM)   +
                SPACE(&PSPACE &PSECSPAC) &SPACEUN NEW &WORKU
            END                        /* DELETE, THEN ALLOC DATA    */
        END                            /* SYSTERM IS ALLOCATED       */
      IF &TERM = NONE THEN             /* IF NO TERM OUTPUT  @BA25449*/+
        ALLOCATE DDNAME(SYSTERM) DUMMY /* SET DUMMY FOR IT   @BA25449*/
  /*******************************************************************/
  /*                                                                 */
  /*                 INVOKE DB2 PRECOMPILER                          */
  /*                                                                 */
  /* INVOKED ROUTINE: PCLOAD KEYWORD                                 */
  /* DEFAULT: DSNHPC                                                 */
  /*******************************************************************/
      CALL &PCLOAD  '&NRSTR(&OPT)'  /* CALL PRECOMPILER PROGRAM      */
      SET &DERROR = &LASTCC      /* IF PRECOMPILE WORKED     @BA18169*/
      IF &ERROR LT &DERROR THEN SET &ERROR = &DERROR /* SAVE RETCODE */
      IF &CONTROL = NONE THEN    /* IF NO MESSAGES WANTED            */+
        CONTROL NOMSG            /* AVOID FREE MESSAGES              */
      /*-------------------------------------------------------------*/
      /* FREE INTERMEDIATE DATA SETS                                 */
      /*-------------------------------------------------------------*/
      FREE DDNAME(SYSIN,DBRMLIB,SYSUT1,SYSCIN)                         +
           ATTR(DSNHF80)         /* FREE ATTRIBUTE           @BA25449*/
      IF &PONL NE      THEN      /* IF ALLOCATION REQUESTED          */+
        FREE DDNAME(SYSLIB)      /* FREE THE SYSLIB                  */
      IF &SUFF = COBOL OR        /* SYSUT2 IS FOR COBOL, COB2   LI319*/+
         &SUFF = IBMCOB OR       /* OR IBMCOB                   LI319*/+
         &SUFF = FORTRAN THEN    /* OR FORTRAN                  LI319*/+
        FREE DDNAME(SYSUT2)      /* FREE THE SYSUT2 IF ALLOCATED     */
      IF &TERM NE LEAVE THEN     /* IF SYSTERM IS A DATA SET         */+
        FREE DDNAME(SYSTERM)     /* FREE FILE FOR REUSE              */
      IF &PRINT NE LEAVE THEN    /* IF SYSPRINT IS A DATA SET        */+
        FREE DDNAME(SYSPRINT)    /* FREE FILE FOR REUSE              */
      CONTROL MSG                /* ALLOW MESSAGES AGAIN             */
      /*-------------------------------------------------------------*/
      /* DSNH740I: PRECOMPILER PASS WALL MESSAGE                     */
      /*-------------------------------------------------------------*/
      IF &WALLF = YES THEN       /* IF PRINT NAME TO BE ADDED        */+
        SET &WALL4 = &STR(.PCLIST &WALLB) /* PRINT DATA SET          */
      WRITE &WALL1 PRECOMPILER &WALL2 &DERROR &WALL3.&WALL4
      IF &ERROR GE &RCTERM THEN  /* IF MAX RET CODE EXCEEDED         */+
        DO                       /* EXIT THE CLIST, MESSAGE          */
          /*---------------------------------------------------------*/
          /* DSNH759I: PRECOMPILER ERROR                             */
          /*---------------------------------------------------------*/
          WRITE &M759 PRECOMPILER RC = &ERROR
          EXIT CODE(&ERROR)      /* EXIT THE CLIST                   */
        END                      /* OF ERROR PROCESSING              */
    END                          /* INVOKE PRECOMPILER               */
  /*******************************************************************/
  /*                                                                 */
  /*                 SETUP FOR CICS COMMAND TRANSLATION              */
  /*                                                                 */
  /*******************************************************************/
  IF &CICSXLAT = YES AND         /* CICS XLATE REQUESTED             */+
     &ATTACH   = CICS THEN       /* CICS XLATE USEFUL THEN           */+
    DO                           /* DETERMINE CICS TRANSLATOR        */
      /*-------------------------------------------------------------*/
      /* DETERMINE HOST LANGUAGE, SETUP CORRESPONDING TRANSLATOR     */
      /*-------------------------------------------------------------*/
      IF &SUFF = PLI AND &CICSPRE = &STR() THEN  /*LANGUAGE PLI      */+
        DO
          SET &CICSXLT = &STR('&CICSLLIB.(DFHEPP1$)')
        END
      ELSE +
        IF &SUFF = PLI THEN                                          +
          DO
            SET &CICSXLT = &STR('&CICSPRE..&CICSLOAD.(DFHEPP1$)')
          END
                                                 /*LANGUAGE ASSEM   */
      IF &SUFF = ASM AND &CICSPRE = &STR() THEN  /*OLD CICSPRE PARM?*/+
        DO                                       /* YES, USE IT     */
          SET &CICSXLT = &STR('&CICSLLIB.(DFHEAP1$)')
        END
      ELSE                                       /*NO, USE NEW LIB  */+
        IF &SUFF = ASM THEN                                           +
          DO
            SET &CICSXLT = &STR('&CICSPRE..&CICSLOAD.(DFHEAP1$)')
          END
                                                  /*LANGUAGE COBOL  */
      IF &SUFF = COBOL AND &CICSPRE = &STR() THEN /*OLD CICSPRE PRM?*/+
        DO                                        /* YES, USE IT    */
          SET &CICSXLT = &STR('&CICSLLIB.(DFHECP1$)')
        END
      ELSE                                        /* NO, USE NEW LIB*/+
        IF &SUFF = COBOL THEN                                         +
          DO
            SET &CICSXLT = &STR('&CICSPRE..&CICSLOAD.(DFHECP1$)')
          END
      IF &SUFF = IBMCOB AND &CICSPRE = &STR() THEN /*OLD CICSPRE PM?*/+
        DO                                        /* USE IT      BCM*/
          SET &CICSXLT = &STR('&CICSLLIB.(DFHECP1$)')
        END                                       /* COMPLETE    BCM*/
      ELSE                                        /* USE NEW LIB BCM*/+
        IF &SUFF = IBMCOB THEN                    /* IBM COBOL   BCM*/+
          DO                                      /* SETUP CICS  BCM*/
            SET &CICSXLT = &STR('&CICSPRE..&CICSLOAD.(DFHECP1$)')
          END                                     /* COMPLETE    BCM*/
      IF &CONTROL = NONE THEN    /* IF NO MESSAGES WANTED            */+
        CONTROL NOMSG            /* AVOID FREE, DEL MESSAGES         */
      FREE DDNAME(SYSPUNCH) ATTR(DSNHF80) /* FREE DDNAME,ATTR        */
      DELETE &OUTNAME..&SUFF     /* DELETE OUTPUT DATA SET           */
      CONTROL MSG                /* ALLOW MESSAGES AGAIN             */
      /*-------------------------------------------------------------*/
      /* DSNHF80: DEFINE DCB ATTRIBUTES                              */
      /*-------------------------------------------------------------*/
      ATTRIB DSNHF80 LRECL(80) RECFM(F B) BLKSIZE(4000) /* SET UP DCB*/
      /*-------------------------------------------------------------*/
      /* ALLOCATE SYSPUNCH DATA SET                                  */
      /*-------------------------------------------------------------*/
      ALLOCATE DDNAME(SYSPUNCH) NEW &SPACEUN &WORKU                    +
         SPACE(&WSPACE &WSECSPAC) REUSE                                +
         USING(DSNHF80) DSNAME(&OUTNAME..&SUFF)         /* PC OUT    */
      IF &CONTROL = NONE THEN    /* IF NO MESSAGES WANTED            */+
        CONTROL NOMSG            /* AVOID FREE MESSAGES              */
      IF &PRINT NE LEAVE THEN    /* IF ALLOCATION REQUESTED          */+
        FREE DDNAME(SYSPRINT)    /* FREE THE DDNAME                  */
      CONTROL MSG                /* ALLOW MESSAGES AGAIN             */
      IF &PRINT NE NONE AND      /* IF ALLOCATION REQUESTED          */+
         &PRINT NE LEAVE THEN    /* IF ALLOCATION REQUESTED          */+
        DO                       /* ALLOCATE DATA SET (OLD)          */
          /*---------------------------------------------------------*/
          /* ALLOCATE SYSPRINT TO TERMINAL                           */
          /*---------------------------------------------------------*/
          IF &PRINT = TERM THEN  /* IF TERM OUTPUT RQSTD             */+
            ALLOCATE DDNAME(SYSPRINT) DA(*)  /* DO TERM ALLOC        */
          ELSE                   /* ALLOCATE A DATA SET              */+
            DO                   /* DELETE, THEN ALLOC DATA          */
              /*-----------------------------------------------------*/
              /* ALLOCATE SYSPRINT TO DATA SET                       */
              /*-----------------------------------------------------*/
              IF &CONTROL = NONE THEN  /* IF NO MESSAGES             */+
                CONTROL NOMSG          /* AVOID DELETE MESSAGES      */
              DELETE &PRINT..CXLIST    /* DELETE OUTPUT DATA SET     */
              FREE DDNAME(SYSPRINT)    /* FREE DDNAME                */
              FREE ATTR(DSNHFBA)       /* FREE ATTRIBUTE             */
              CONTROL MSG              /* ALLOW MESSAGES AGAIN       */
              /*-----------------------------------------------------*/
              /* DSNHFBA: DEFINE DCB ATTRIBUTES                      */
              /*-----------------------------------------------------*/
              ATTR DSNHFBA RECFM(F B A) LRECL(121) BLKSIZE(3630)
              ALLOCATE DDNAME(SYSPRINT) DSNAME(&PRINT..CXLIST) NEW     +
                SPACE(&PSPACE &PSECSPAC) &SPACEUN USING(DSNHFBA)   +
                &WORKU                           /* @BA04731*/
              FREE ATTR(DSNHFBA)       /* FREE ATTRIBUTE             */
            END                        /* DELETE, THEN ALLOC DATA    */
        END                            /* SYSPRINT IS ALLOCATED      */
      IF &PRINT = NONE   THEN          /* IF NO PRINT REQUESTED      */+
        ALLOCATE DDNAME(SYSPRINT) DUMMY   /* SET DUMMY FOR IT        */
      IF &SUFF = ASM THEN              /* IF THIS IS ASM             */+
         DO                            /* SET UP PARMS FOR ASM XLAT  */
            /*-------------------------------------------------------*/
            /* SETUP TRANSLATOR OPTION FOR ASM                       */
            /*-------------------------------------------------------*/
            SET &CXPARM = &STR(OPTIONS)
            IF &OPTIONS = NO THEN      /* IF OPTIONS ARE SET NO      */+
               SET &CXPARM = &STR(NOOPTIONS)
            IF &CICSOPT NE NONE THEN   /* IF PARMS WERE SET          */+
               SET &CXPARM = &STR(&CXPARM,&CICSOPT)
         END                           /* SET UP PARMS FOR ASM XLAT  */
      IF &SUFF = COBOL                 /* IF THIS IS COB OR COB2     */+
      OR &SUFF = IBMCOB THEN           /* OR IF THIS IS IBMCOB    @04*/+
         DO                            /* SET UP PARMS FOR COB XLAT  */
            /*-------------------------------------------------------*/
            /* SETUP TRANSLATOR OPTION FOR COBOL                     */
            /*-------------------------------------------------------*/
            SET &CXPARM = &STR(OP,FLAG(&FLAG))
            IF &OPTIONS = NO THEN      /* IF OPTIONS ARE SET NO      */+
                SET &CXPARM = &STR(NOP,FLAG(&FLAG))
            SET &CXPARM = &STR(&CXPARM,LC(&LINECOUNT))
            IF &DELIMIT NE DEFAULT THEN   /* IF DELIM APOST OR QUOTE */+
                SET &CXPARM = &STR(&CXPARM,&DELIMIT)
            IF &SOURCE = NO THEN          /* IF SOURCE IS SET NO     */+
                SET &CXPARM = &STR(&CXPARM,NOSOURCE)
              ELSE                        /* IF SOURCE IS SET TO YES */+
                SET &CXPARM = &STR(&CXPARM,SOURCE)
            IF &HOST = COB2 THEN          /* IF COBOL2, TELL CICS    */+
                SET &CXPARM = &STR(&CXPARM,COBOL2)
            IF &HOST = IBMCOB THEN        /* IF IBM COB TELL CICS @04*/+
              SET &CXPARM = &STR(&CXPARM,COBOL3)
            IF &CICSOPT NE NONE THEN      /* IF PARMS WERE SET       */+
                SET &CXPARM = &STR(&CXPARM,&CICSOPT)
         END                              /* SETUP PARMS FOR COB XLAT*/
      IF &SUFF = PLI THEN                 /* IF THIS IS PLI          */+
         DO                               /* SETUP PARMS FOR PLI XLAT*/
            /*-------------------------------------------------------*/
            /* SETUP TRANSLATOR OPTION FOR PLI                       */
            /*-------------------------------------------------------*/
            SET &CXPARM = &STR(OP,FLAG(&FLAG))
            IF &OPTIONS = NO THEN         /* IF OPTIONS ARE SET NO   */+
               SET &CXPARM = &STR(NOP,FLAG(&FLAG))
            SET &CXPARM = &STR(&CXPARM,LC(&LINECOUNT))
            IF &SOURCE = NO THEN          /* IF SOURCE IS SET NO     */+
               SET &CXPARM = &STR(&CXPARM,NOSOURCE)
            ELSE                          /* IF SOURCE IS SET TO YES */+
               SET &CXPARM = &STR(&CXPARM,SOURCE)
            IF &CICSOPT NE NONE THEN      /* IF PARMS WERE SET       */+
               SET &CXPARM = &STR(&CXPARM,&CICSOPT)
         END                              /* SETUP PARMS FOR PLI XLAT*/
      /*-------------------------------------------------------------*/
      /* ALLOCATE SYSIN DATA SET                                     */
      /*-------------------------------------------------------------*/
      ALLOCATE DDNAME(SYSIN) SHR REUSE                                 +
               DSNAME(&OUTNAME..CICSIN)
  /*******************************************************************/
  /*                                                                 */
  /*                 INVOKE CICS COMMAND TRANSLATOR                  */
  /*                                                                 */
  /* INVOKED ROUTINE: BASED UPON HOST LANGUAGE:                      */
  /*             PLI  - DFHEPP1$                                     */
  /*             ASM  - DFHEAP1$                                     */
  /*           COBOL  - DFHECP1$                                     */
  /*******************************************************************/
      CALL &CICSXLT '&CXPARM'
      SET &DERROR = &LASTCC      /* IF CICSXLT WORKED        @BA18169*/
      IF &ERROR LT &DERROR THEN SET &ERROR = &DERROR /* SAVE RETCODE */
      IF &CONTROL = NONE THEN    /* IF NO MESSAGES                   */+
        CONTROL NOMSG            /* AVOID FREE MESSAGES              */
      FREE DDNAME(SYSIN,SYSPUNCH)                                      +
           ATTR(DSNHF80)         /* FREE ATTRIBUTE           @BA25449*/
      IF &PRINT NE LEAVE THEN    /* IF SYSPRINT IS A DATA SET        */+
        FREE DDNAME(SYSPRINT)    /* FREE FILE FOR REUSE              */
      CONTROL MSG                /* ALLOW MESSAGES AGAIN             */
      /*-------------------------------------------------------------*/
      /* DSNH740I: CICSXLAT PASS WALL MESSAGE                        */
      /*-------------------------------------------------------------*/
      IF &WALLF = YES THEN       /* IF PRINT NAME TO BE ADDED        */+
        SET &WALL4 = &STR(.CXLIST &WALLB) /* PRINT DATA SET          */
      SET &WALLX =&STR(CICS COMMAND TRANSLATION)
      WRITE &WALL1 &WALLX &WALL2 &DERROR &WALL3.&WALL4
      IF &ERROR GE &RCTERM THEN  /* IF MAX RET CODE EXCEEDED         */+
        DO                       /* EXIT THE CLIST, MESSAGE          */
          /*---------------------------------------------------------*/
          /* DSNH759I: CICSXLAT ERROR                                */
          /*---------------------------------------------------------*/
          WRITE &M759 &WALLX RC = &ERROR
          EXIT CODE(&ERROR)      /* EXIT THE CLIST                   */
        END                      /* OF ERROR PROCESSING              */
    END                          /* INVOKE THE TRANSLATOR            */
  SET &DSNTRC =                  /* DEFAULT TO NO TRACING            */
  IF &SUBSTR(1,&CONTROL) EQ C OR /* TRACE IF DSNH TRACE IS           */+
     &SUBSTR(1,&CONTROL) EQ S THEN  /* CONLIST OR SYMLIST            */+
    SET &DSNTRC = &STR(TEST(123))   /* PARAMETER TO TRACE DSN        */
  /*******************************************************************/
  /*                                                                 */
  /*                 INVOKE DB2 BIND PACKAGE SUBCOMMAND              */
  /*                                                                 */
  /* INVOKED ROUTINES:                                               */
  /*              DSN - COMMAND PROCESSOR:                           */
  /*                    SYSTEM KEYWORD (SUBSYSTEM NAME)              */
  /*                    CONTROL KEYWORD (CONTROL-OPTION)             */
  /*             BIND - BIND PACKAGE SUBCOMMAND                      */
  /*******************************************************************/
  IF &PBIND = YES THEN              /* IF BIND PACKAGE IS REQUESTED  */+
    DO                              /* INVOKE BIND                   */
      IF &NRSTR(&POWNER) = NONE           /* SET UP OWNER PARAMETER  */+
         THEN SET &PBINDOWN = &STR()        /* CLEAR IT             */
         ELSE SET &PBINDOWN = &NRSTR(OWNER(&POWNER)) /* SET IT       */
      /*-------------------------------------------------------------*/
      /* IF NO PRIMARY DBRM MEMBER (PDMEM), IGNORE DBRM LIBRARY      */
      /* (PDBRMLIB)                                                  */
      /*-------------------------------------------------------------*/
      IF &NRSTR(&PDMEM) = NONE THEN       /* SPECIFY MEMBER NAME ?   */+
        DO                                /* NO DBRM MEMBER NAME     */
          SET &BPKGMBR = &STR()           /* INDICATE NO DBRM MEMBER */
          SET &BPKGLIB = &STR()           /* AND NO DBRM LIBRARY     */
        END                               /* DBRM COMPLETE           */
      /*-------------------------------------------------------------*/
      /* INVOKE DSN COMMAND PROCESSOR                                */
      /*-------------------------------------------------------------*/
      DSN SYSTEM(&SYSTEM) &DSNTRC         /* INVOKE DSN COMMAND      */
      SET &DERROR = &LASTCC               /* IF DSN SUCCEEDED        */
      IF &DERROR > &ERROR THEN            /* IF NEW ERROR IS LARGER  */+
        SET &ERROR = &DERROR              /* NOTE THE MOST SEVERE ERR*/
      IF &DERROR = 0 THEN                 /* IF DSN SUCCEEDED        */+
        DO                                /* INVOKE  BIND SUBCOMMAND */
          /*---------------------------------------------------------*/
          /* INVOKE BIND PACKAGE SUBCOMMAND                          */
          /*---------------------------------------------------------*/
          BIND PACKAGE(&BPACKAGE)                                      +
          &PBEXPLAIN &PBSQLERROR                                       +
          &PBVALIDATE &PBISOLATION                                     +
          &PDEFR &PNDEFR &PROPT                             /*KFD0005*/+
          &PBDYNAMICRULES                                   /*KEP0478*/+
          &PBKEEPDYNAMIC                                    /*PQ20086*/+
          &PBCURRDATA &PBDEGREE                                        +
          ACTION(&PACTION) FLAG(&PFLAGB)                               +
          &PBRELEASE                                                   +
          &BCOPYOPS                                         /*PQ03427*/+
          &PDBPRO                                           /*  LI350*/+
          &NRSTR(&PQYOPT.)                                  /*  LI375*/+
          &BPPATHS                                          /*  LI333*/+
          &PBINDOWN &BCOPY &NRSTR(&BCOPYVER.) &NRSTR(&BREPLVER.)       +
          &PBQUALF &PBIMSBMP &PBIMSMPP &PBENABL &PBDISABL              +
          &PBCICS &PBDLIBATC &BREMOTE                                  +
          &STR(&PENCOD)                                         /*@10*/+
          &STR(&PIMWRI)                                         /*@10*/+
          &STR(&PAPREU)                                         /*@10*/+
          &STR(&PAPCOM)                                         /*@10*/+
          &STR(&PSTSEN)                                         /*@10*/+
          &STR(&PBTSEN)                                         /*@10*/+
          &STR(&PARSEN)                                         /*@10*/+
          &STR(&PAPCPT)                                         /*@10*/+
          &BPKGMBR &BPKGLIB            /* INVOKE BIND PACKAGE SUBCMD */
          DATA                         /* AVOID USING 'END' AS CLIST */
          END                          /* OF DSN COMMAND             */
          ENDDATA                      /* OF DATA BLOCK              */
          SET &DERROR = &LASTCC        /* IF BIND WORKED             */
          IF &ERROR LT &DERROR THEN SET &ERROR = &DERROR /* RETCODE  */
        END                            /* INVOKE THE BIND SUBCOMMAND */
      IF &CONTROL = NONE THEN          /* IF NO MESSAGES             */+
        CONTROL NOMSG                  /* AVOID FREE MESSAGES        */
      /*-------------------------------------------------------------*/
      /* DBRMLIB: FREE DBRMLIB DATA SET                              */
      /*-------------------------------------------------------------*/
      FREE DSNAME(&PDBRMLIB)           /* FREE FILE FOR OTHERS       */
      CONTROL MSG                      /* ALLOW MESSAGES AGAIN       */
      /*-------------------------------------------------------------*/
      /* DSNH740I: BIND PACKAGE PASS WALL MESSAGE                    */
      /*-------------------------------------------------------------*/
      WRITE &WALL1 BIND PACKAGE &WALL2 &DERROR &WALLB
      IF &ERROR GE &RCTERM THEN        /* IF MAX RET CODE EXCEEDED   */+
        DO                             /* ERROR MESSAGE, EXIT CLIST  */
          /*---------------------------------------------------------*/
          /* DSNH759I: BIND PACKAGE ERROR                            */
          /*---------------------------------------------------------*/
          WRITE &M759 BIND PACKAGE RC = &ERROR
          EXIT CODE(&ERROR)            /* EXIT THE CLIST             */
        END                            /* OF SEVERE ERROR HANDLING   */
    END                                /* OF BIND PACKAGE INVOCATION */
  /*******************************************************************/
  /*                                                                 */
  /*                 INVOKE DB2 BIND PLAN SUBCOMMAND                 */
  /*                                                                 */
  /* INVOKED ROUTINES:                                               */
  /*              DSN - COMMAND PROCESSOR:                           */
  /*                    SYSTEM KEYWORD (SUBSYSTEM NAME)              */
  /*                    CONTROL KEYWORD (CONTROL-OPTION)             */
  /*             BIND - BIND SUBCOMMAND                              */
  /*******************************************************************/
  IF &BIND = YES THEN               /* IF BIND IS REQUESTED          */+
    DO                              /* INVOKE BIND                   */
      /*-------------------------------------------------------------*/
      /* SETUP ADDITIONAL DBRM LIBRARIES (BCON,B2LIB...B8LIB)        */
      /*-------------------------------------------------------------*/
      SET &BCON =                   /* NO EXTRA LIBRARIES NOW        */
      IF &STR(&BLIB) NE NONE THEN   /* IF NOT THE NULL KEYWORD       */+
         SET &BCON = &STR(&BLIB)    /* ADD THIS LIBRARY TO LIST      */
      IF &STR(&B2LIB) NE NONE THEN  /* IF NOT THE NULL KEYWORD       */+
         SET &BCON = &STR(&BCON &B2LIB)   /* ADD LIB TO LIST         */
      IF &STR(&B3LIB) NE NONE THEN        /* IF NOT THE NULL KEYWORD */+
         SET &BCON = &STR(&BCON &B3LIB)   /* ADD LIB TO LIST         */
      IF &STR(&B4LIB) NE NONE THEN        /* IF NOT THE NULL KEYWORD */+
         SET &BCON = &STR(&BCON &B4LIB)   /* ADD LIB TO LIST         */
      IF &STR(&B5LIB) NE NONE THEN        /* IF NOT THE NULL KEYWORD */+
         SET &BCON = &STR(&BCON &B5LIB)   /* ADD LIB TO LIST         */
      IF &STR(&B6LIB) NE NONE THEN        /* IF NOT THE NULL KEYWORD */+
         SET &BCON = &STR(&BCON &B6LIB)   /* ADD LIB TO LIST         */
      IF &STR(&B7LIB) NE NONE THEN        /* IF NOT THE NULL KEYWORD */+
         SET &BCON = &STR(&BCON &B7LIB)   /* ADD LIB TO LIST         */
      IF &STR(&B8LIB) NE NONE THEN        /* IF NOT THE NULL KEYWORD */+
         SET &BCON = &STR(&BCON &B8LIB)   /* ADD LIB TO LIST         */
      IF &STR(&B9LIB) NE &STR() THEN      /* IF NOT THE NULL KEYWORD */+
         SET &BCON = &STR(&BCON &B9LIB)   /* ADD LIB TO LIST         */
      /*-------------------------------------------------------------*/
      /* ADD ALL ADDITIONAL DBRM LIBRARIES (BLIB, B2LIB...B8LIB)     */
      /* TO PRIMARY DBRM LIBRARY (BDBRMLIB).                         */
      /*                     * * *                                   */
      /* IF NO PRIMARY DBRMLIB (BDBRMLIB), IGNORE ALL ADDITIONAL     */
      /* DBRM LIBRARIES (BLIB, B2LIB...B8LIB)                        */
      /*-------------------------------------------------------------*/
      IF &STR(&BPLNLIB) ^= THEN           /* IF PRIMARY LIBRARY      */+
        SET BPLNLIB = &STR(LIBRARY(&BPLNLIB &BCON))
      /*-------------------------------------------------------------*/
      /* IF NO PRIMARY DBRM MEMBER (BDMEM), IGNORE ALL ADDITIONAL    */
      /* DBRM MEMBERS (BMEM) AND DBRM LIBRARIES (BDBRMLIB AND        */
      /* BLIB, B2LIB...B8LIB)                                        */
      /*-------------------------------------------------------------*/
      IF &NRSTR(&BMEM) = NONE THEN        /* NO EXTRA MEMBERS        */+
        SET &BMEM =                       /* CLEAR IT                */
      IF &NRSTR(&BDMEM) = NONE THEN       /* SPECIFY MEMBER NAME ?   */+
        DO                                /* NO DBRM MEMBER NAME     */
          /*---------------------------------------------------------*/
          /* INDICATE NO BDMEM AND BDBRMLIB                          */
          /*---------------------------------------------------------*/
          SET &BPLNMBR = &STR()           /* INDICATE NO DBRM MEMBER */
          SET &BPLNLIB = &STR()           /* AND NO DBRM LIBRARY     */
        END                               /* DBRM COMPLETE           */
      ELSE                                /* MEMBER SPECIFIED        */+
        SET &BPLNMBR = &NRSTR(MEMBER(&BDMEM &BMEM)) /* SET MEMBER    */
      IF &NRSTR(&OWNER) = NONE            /* SET UP OWNER PARAMETER  */+
         THEN SET &BINDOWN = &STR()          /* CLEAR IT             */
         ELSE SET &BINDOWN = &NRSTR(OWNER(&OWNER))   /* SET IT       */
      /*-------------------------------------------------------------*/
      /* INVOKE DSN COMMAND PROCESSOR                                */
      /*-------------------------------------------------------------*/
      DSN SYSTEM(&SYSTEM) &DSNTRC         /* INVOKE DSN COMMAND      */
      SET &DERROR = &LASTCC               /* IF DSN SUCCEEDED        */
      IF &DERROR > &ERROR THEN            /* IF NEW ERROR IS LARGER  */+
        SET &ERROR = &DERROR              /* NOTE THE MOST SEVERE ERR*/
      IF &DERROR = 0 THEN                 /* IF DSN SUCCEEDED        */+
        DO                                /* INVOKE  BIND SUBCOMMAND */
          /*---------------------------------------------------------*/
          /* INVOKE BIND PLAN SUBCOMMAND                             */
          /*---------------------------------------------------------*/
          BIND &NRSTR(PLAN(&PLAN)) EXPLAIN(&EXPLAIN)                   +
          VALIDATE(&VALIDATE) ISOLATION(&ISOLATION)                    +
          DYNAMICRULES(&DYNAMICRULES)                       /*KEP0478*/+
          KEEPDYNAMIC(&KEEPDYNAMIC)                         /*  D9028*/+
          ACTION(&ACTION) &RETAINKY FLAG(&FLAGB)                       +
          CURRENTDATA(&CURRENTDATA) DEGREE(&DEGREE)                    +
          SQLRULES(&SQLRULES) DISCONNECT(&DISCONNECT)                  +
          ACQUIRE(&ACQUIRE) RELEASE(&RELEASE)                          +
          &BINDOWN &BDEFR &BNDEFR &ROPT                     /*KFD0005*/+
          &BDBPRO                                           /*  LI350*/+
          &NRSTR(&BQYOPT.)                                  /*  LI375*/+
          &BENCOD                                               /*@10*/+
          &BIMWRI                                               /*@10*/+
          &BPRAUT                                               /*@10*/+
          &BPATHS                                           /*  LI333*/+
          &BPKLIST &BQUALF &BIMSBMP &BIMSMPP &BENABL &BDISABL          +
          &BCICS &BCACHSZ &BDLIBATC &BCURRSRV                          +
          &BPLNMBR &BPLNLIB            /* INVOKE BIND PLAN SUBCMD    */
          DATA                         /* AVOID USING 'END' AS CLIST */
          END                          /* OF DSN COMMAND             */
          ENDDATA                      /* OF DATA BLOCK              */
          SET &DERROR = &LASTCC        /* IF BIND WORKED     @BA18169*/
          IF &ERROR LT &DERROR THEN SET &ERROR = &DERROR /* RETCODE  */
        END                            /* INVOKE THE BIND SUBCOMMAND */
      IF &CONTROL = NONE THEN          /* IF NO MESSAGES             */+
        CONTROL NOMSG                  /* AVOID FREE MESSAGES        */
      /*-------------------------------------------------------------*/
      /* DBRMLIB: FREE DBRMLIB DATA SET                              */
      /*-------------------------------------------------------------*/
      FREE DSNAME(&DBRMLIB)            /* FREE FILE FOR OTHERS       */
      CONTROL MSG                      /* ALLOW MESSAGES AGAIN       */
      /*-------------------------------------------------------------*/
      /* DSNH740I: BIND PLAN PASS WALL MESSAGE                       */
      /*-------------------------------------------------------------*/
      WRITE &WALL1 BIND PLAN &WALL2 &DERROR &WALLB
      IF &ERROR GE &RCTERM THEN        /* IF MAX RET CODE EXCEEDED   */+
        DO                             /* ERROR MESSAGE, EXIT CLIST  */
          /*---------------------------------------------------------*/
          /* DSNH759I: BIND PLAN ERROR                               */
          /*---------------------------------------------------------*/
          WRITE &M759 BIND PLAN RC = &ERROR
          EXIT CODE(&ERROR)            /* EXIT THE CLIST             */
        END                            /* OF SEVERE ERROR HANDLING   */
    END                                /* OF BIND PLAN INVOCATION    */
  /*******************************************************************/
  /*                                                                 */
  /*                 INVOKE COMPILER OR ASSEMBLER                    */
  /*                                                                 */
  /* INVOKED ROUTINE: DSNHC                                          */
  /*                                                                 */
  /*******************************************************************/
  IF &COMPILE = YES THEN               /* IF COMPILE IS REQUESTED    */+
    DO                                 /* INVOKE DSNHC CLIST TO DO   */
      /*-------------------------------------------------------------*/
      /* INVOKE DSNHC CLIST TO COMPILE OR ASSEMBLE                   */
      /*-------------------------------------------------------------*/
             &DSNHC                                 /*KEW0324*/+
           ATTACH(&ATTACH)                          /*KEW0324*/+
           CICSCLIB(&QCICSCLIB) CICSPLIB(&QCICSPLIB) /*KEW0324*/+
           CLIB(&QCLIB)                             /*KEW0324*/+
           CONTROL(&CONTROL) COPTION(&QCOPTION) C2LIB(&QC2LIB) +
           C3LIB(&QC3LIB) C4LIB(&QC4LIB) DELIMIT(&DELIMIT)     +
           FLAG(&FLAG) HOST(&HOST) LINECOUNT(&LINECOUNT)       +
           MACIN(NONE) OUTNAME(&OUTNAME) PRINT(&PRINT)         +
           PSPACE(&PSPACE) PSECSPAC(&PSECSPAC) SOURCE(&SOURCE) +
           SPACEUN(&SPACEUN) TERM(&QTERM) WORKUNIT(&WORKUNIT)  +
           WSECSPAC(&WSECSPAC) WSPACE(&WSPACE) XREF(&XREF)     +
           ASMLIB(&QASML)                                      +
           ASMLOAD(&QASM) COBLOAD(&QCOB) COB2LOAD(&QCOB2)      +
           COBICOMP(&QCOBOO)                         /* LI319*/+
           FORTLOAD(&QFORT) PLILOAD(&QPLI)                     +
           CCSLIB(&QCSLIB) CCLOAD(&QCLOAD) CCMSGS(&QCMSGS)     +
           CPPUTIL(&QCPUTIL) CPPSLIB(&QCPSLIB)       /* LI319*/+
           CPPCSLIB(&QCPCSLIB)                       /* LI319*/+
           &NRSTR(MEMBER(&MEMBER))                   /* LI319*/
      SET &DERROR = &LASTCC            /* IF DSNHC WORKED    @BA18169*/
      IF &ERROR LT &DERROR THEN SET &ERROR = &DERROR /* SAVE RETCODE */
      /*-------------------------------------------------------------*/
      /* DSNH740I: COMPILE PASS WALL MESSAGE                         */
      /*-------------------------------------------------------------*/
      IF &WALLF = YES THEN             /* IF PRINT NAME TO BE ADDED  */+
        IF &HOST = C THEN              /* 'C' COMPILER ?        LI319*/+
          SET &WALL4 = &STR(.SYSCPRT.LIST &WALLB)   /* PRINT DATA SET*/
        ELSE                           /* NOT 'C' COMPILER      LI319*/+
          IF &HOST = CPP THEN          /* C++ COMPILER ?        LI319*/+
            DO                         /* SETUP FOR WALL        LI319*/
              SET &WALL3 = &STR(======= LISTING IN )
              SET &WALL4 =                                             +
                 &STR(&OUTNAME..&PCSUFF..LIST &WALLB)
            END                        /* SETUP COMPLETE        LI319*/
          ELSE                         /* OTHER COMPILERS       LI319*/+
            SET &WALL4 = &STR(.LIST &WALLB) /* PRINT DATA SET   LI319*/
      WRITE &WALL1 &HOST &WALL2 &DERROR &WALL3.&WALL4
      IF &HOST = CPP THEN              /* C++ COMPILER ?        LI319*/+
        SET &WALL3 = &STR(======= LISTING IN &PRINT) /* RESTORE LI319*/
      IF &ERROR GE &RCTERM THEN     /* IF OVER MAX RET CODE          */+
        DO                          /* WRITE ERROR MSG, EXIT         */
          /*---------------------------------------------------------*/
          /* DSNH759I: COMPILE ERROR                                 */
          /*---------------------------------------------------------*/
          WRITE &M759 &HOST RC = &ERROR
          EXIT CODE(&ERROR)         /* EXIT FROM CLIST               */
        END                         /* OF SEVERE ERROR HANDLING      */
    END                             /* OF COMPILER INVOCATION        */
  /*******************************************************************/
  /*                                                                 */
  /*                 INVOKE PRE-LINKEDIT                             */
  /*   BUILD PRE-LINKEDIT PARMS, ALLOCATE REQUIRED DATA SETS, AND    */
  /*   INVOKE 'C' PRE-LINKEDIT FUNCTION                              */
  /*                                                                 */
  /* PARMS:  POPTION KEYWORD VALUES                                  */
  /* INVOKED ROUTINE: CCLINK KEYWORD   (C)                      LI319*/
  /*                  CPPCLINK KEYWORD (C++)                    LI319*/
  /*                  COBIPLNK KEYWORD (OOCOBOL)                LI319*/
  /*                                                                 */
  /*******************************************************************/
  IF &HOST = CPP THEN               /* IF C++ COMPILER          LI319*/+
    SET &LKDSNAME = &OUTNAME..&SUFF..OBJ  /* DSN FOR LINKEDIT   LI319*/
  ELSE                              /* OTHER COMPILERS          LI319*/+
    SET &LKDSNAME = &OUTNAME..OBJ   /* DSN FOR LINKEDIT         LI319*/
  IF &PRELINK = YES AND             /* IF PRELINK REQUESTED AND LI319*/+
     &PLNKVD = YES THEN             /* PRELINK SUPPORTED        LI319*/+
    DO                              /* 'C/C++' PRE-LINKEDIT     LI319*/
      /*-------------------------------------------------------------*/
      /* SETUP SPECIFIED KEYWORD VARIABLES                           */
      /* FREE INTERMEDIATE DATA SETS                                 */
      /*-------------------------------------------------------------*/
      IF &CONTROL = NONE THEN       /* IF NO MESSAGES REQUESTED      */+
        CONTROL NOMSG               /* SUPPRESS MESSAGES             */
      ELSE                          /* CONTROL COMPLETE              */
      DELETE (&OUTNAME..PLK)        /* DELETE OUTNAME..PLK           */
      FREE DDNAME(SYSLIB)           /* FREE SYSLIB                   */
      FREE DDNAME(SYSMSGS)          /* FREE SYSMSGS                  */
      FREE DDNAME(SYSIN)            /* FREE SYSIN                    */
      FREE DDNAME(SYSMOD)           /* FREE SYSMOD                   */
      CONTROL MSG                   /* ALLOW MESSAGES AGAIN          */
      SET &LKDSNAME = &OUTNAME..PLK /* INPUT DSNAME FOR LINKEDIT     */
      /*-------------------------------------------------------------*/
      /* ALLOCATE SYSMSGS DATA SETS:                            LI319*/
      /*    CCPMSG KEYWORD   (C)                                LI319*/
      /*    CPPPMSGS KEYWORD (C++)                              LI319*/
      /*    COBIPMSG KEYWORD (OOCOBOL)                          LI319*/
      /*    PLIPMSG KEYWORD (Enterprise PL/I)                     @02*/
      /*-------------------------------------------------------------*/
      ALLOCATE DDNAME(SYSMSGS) SHR REUSE +
               DSNAME(&CSYSM)       /* PRE-LINKEDIT MSGS        LI319*/
      /*-------------------------------------------------------------*/
      /* ALLOCATE SYSIN DATA SETS                               LI319*/
      /*-------------------------------------------------------------*/
      IF &HOST = CPP THEN           /* IF C++ COMPILER          LI319*/+
        ALLOCATE DDNAME(SYSIN) SHR REUSE +
                 DSNAME(&OUTNAME..&SUFF..OBJ) /* COMPILE OUTPUT LI319*/
      ELSE IF &HOST = IBMCOB THEN   /* ELSE IF IBMCOB COMPILER  D9200*/+
        DO                          /*                          D9200*/
          SET &CONL = &STR()        /* INITIALIZE SYSIN         D9200*/
          SET &CONL = &STR(&OUTNAME..OBJ) /* COMPILER OUTOUT    D9200*/
          IF &SOMDLLI ^= &STR() THEN      /* IF SOM DLL IMP LIB D9200*/+
            SET &CONL = &STR(&CONL &SOMDLLI) /* ADD IT TO SYSIN D9200*/
          ALLOCATE DDNAME(SYSIN) SHR REUSE +
                  DSNAME(&CONL)     /* OUTPUT FROM COMPILE      D9200*/
        END                         /*                          D9200*/
      ELSE                          /* OTHER COMPILERS          LI319*/+
        ALLOCATE DDNAME(SYSIN) SHR REUSE +
                 DSNAME(&OUTNAME..OBJ) /* OUTPUT FROM COMPILE        */
      /*-------------------------------------------------------------*/
      /* ALLOCATE SYSMOD DATA SETS                              LI319*/
      /*-------------------------------------------------------------*/
      ALLOCATE DD(SYSMOD) NEW &WORKU REUSE +
               RECFM(F B) LRECL(80) BLKSIZE(3200) +
               &SPACEUN SPACE(&WSPACE,&WSECSPAC) +
               DSNAME(&LKDSNAME)    /* PRE-LINKEDIT OUTPUT           */
      /*-------------------------------------------------------------*/
      /* OOCOBOL REQUIRES: SYSDEFSD                             LI319*/
      /*-------------------------------------------------------------*/
      IF &HOST = IBMCOB THEN        /* IF IBMCOB SPECIFIED      LI319*/+
        DO                          /* ALLOCATE SYSDEFSD          BCM*/
          IF &CONTROL = NONE THEN   /* IF NO MESSAGES USED           */+
            CONTROL NOMSG        /* AVOID DELETE MESSAGES            */
          FREE DDNAME(SYSDEFSD)     /* INSURE DD IS FREE          BCM*/
          ALLOCATE DDNAME(SYSDEFSD) DUMMY /* DUMMY FOR NOW      LI319*/
          CONTROL MSG            /* ALLOW MESSAGES AGAIN             */
        END                         /* SYSDEFSD COMPLETE          BCM*/
      /*-------------------------------------------------------------*/
      /* ALLOCATE SYSLIB DATA SETS                              LI319*/
      /*-------------------------------------------------------------*/
      SET &CONL = &STR()            /* INITIALIZE SYSLIB        LI319*/
      IF &STR(&HOST) = C AND        /* IF C PROGRAM COMPILER    LI319*/+
         &CCOLIB NE &STR(NONE) THEN /* AND CCOLIB SPECIFIED     LI319*/+
        SET &CONL = &STR(&CONL &CCOLIB) /* ADD TO SYSLIB        LI319*/
      IF &HOST = CPP THEN           /* IF C++ COMPILER          LI319*/+
        DO                          /* ALLOCATE SYSLIB          LI319*/
          SET &CONL = &STR(&CONL &CPPLLIB) /* ADD TO SYSLIB     LI319*/
          SET &CONL = &STR(&CONL &CPPCLASS) /* ADD TO SYSLIB    LI319*/
        END                         /* SYSLIB COMPLETE          LI319*/
      IF  &HOST = IBMCOB            /* IF IBMCOB SPECIFIED      LI319*/+
       OR &HOST = PLI    THEN       /* IF PLI SPECIFIED           @03*/+
        SET &CONL = &STR('NULLFILE')    /* NO SYSLIB FOR OO COB D9200*/
      IF &CONL = &STR() THEN        /* IF NO SYSLIB DSN SPEC'D    @05*/+
        SET &CONL = &STR('NULLFILE')    /* USE NULLFILE           @05*/
      ALLOCATE DDNAME(SYSLIB) SHR REUSE +
               DSNAME(&CONL)        /* INCLUDE PRELINK LIB(S)   LI319*/
      IF &PRINT NE NONE AND         /* IF ALLOCATION REQUESTED       */+
         &PRINT NE LEAVE THEN       /* AND NOT SPECIFIED PRINT       */+
        DO                          /* ALLOCATE DATA SET (OLD)       */
          /*---------------------------------------------------------*/
          /* ALLOCATE SYSPRINT, SYSOUT TO TERMINAL                   */
          /*---------------------------------------------------------*/
          IF &PRINT = TERM THEN     /* IF TERMINAL REQUESTED         */+
            DO                      /* ALLOCATE TO TERMINAL          */
              ALLOCATE DDNAME(SYSPRINT) DA(*) /* DO TERM ALLOC       */
              FREE DDNAME(SYSOUT)   /* FREE SYSOUT                @03*/
              ALLOCATE DDNAME(SYSOUT) DA(*) /* DO TERM ALLOC         */
            END                     /* ALLOCATION COMPLETE           */
          ELSE                      /* ALLOCATE A DATA SET           */+
            DO                      /* ALLOCATE TO SYSPRINT          */
              /*-----------------------------------------------------*/
              /* ALLOCATE SYSPRINT TO DATA SET                       */
              /*-----------------------------------------------------*/
              IF &CONTROL = NONE THEN /* IF NO MESSAGES REQUESTED    */+
                CONTROL NOMSG       /* SUPPRESS MESSAGES             */
              ELSE                  /* CONTROL COMPLETE              */
              DELETE &PRINT..PRELLIST /* DELETE OUTPUT DATA SET      */
              FREE DDNAME(SYSPRINT) /* FREE SYSPRINT                 */
              FREE ATTR(DSNHFBA)    /* FREE ATTRIBUTE                */
              CONTROL MSG           /* ALLOW MESSAGES AGAIN          */
              /*-----------------------------------------------------*/
              /* DSNHFBA: DEFINE DCB ATTRIBUTES                      */
              /*-----------------------------------------------------*/
              ATTR DSNHFBA RECFM(F B A) LRECL(121) BLKSIZE(3630)
              ALLOCATE DDNAME(SYSPRINT) DSNAME(&PRINT..PRELLIST) +
              NEW SPACE(&PSPACE &PSECSPAC) &SPACEUN +
              USING(DSNHFBA) &WORKU
              FREE ATTR(DSNHFBA)    /* FREE ATTRIBUTE                */
              /*-----------------------------------------------------*/
              /* ALLOCATE SYSOUT TO DATA SET                         */
              /*-----------------------------------------------------*/
              IF &CONTROL = NONE THEN /* IF NO MESSAGES REQUESTED    */+
                CONTROL NOMSG       /* SUPPRESS MESSAGES             */
              ELSE                  /* CONTROL COMPLETE              */
              DELETE &PRINT..SYSOUT.PRELLIST /* DELETE DATA SET      */
              FREE DDNAME(SYSOUT)   /* FREE SYSOUT                   */
              FREE ATTR(DSNHFB)     /* FREE ATTRIBUTE                */
              CONTROL MSG           /* ALLOW MESSAGES AGAIN          */
              /*-----------------------------------------------------*/
              /* DSNHFBA: DEFINE DCB ATTRIBUTES                      */
              /*-----------------------------------------------------*/
              ATTR DSNHFB RECFM(F B) LRECL(80) BLKSIZE(3600)
              ALLOCATE DDNAME(SYSOUT) +
              DSNAME(&PRINT..SYSOUT.PRELLIST) +
              NEW SPACE(&PSPACE &PSECSPAC) &SPACEUN +
              USING(DSNHFB) &WORKU
              FREE ATTR(DSNHFB)     /* FREE ATTRIBUTE                */
            END                     /* ALLOCATION COMPLETE           */
        END                         /* SYSPRINT IS ALLOCATED         */
      ELSE                          /* BYPASS ALLOCATION             */+
        IF &PRINT EQ NONE THEN      /* IF NO SYSPRINT                */+
          DO                        /* ALLOCATION TO DUMMY           */
            /*-------------------------------------------------------*/
            /* ALLOCATE SYSPRINT, SYSOUT TO DUMMY                    */
            /*-------------------------------------------------------*/
            ALLOCATE DDNAME(SYSPRINT) DUMMY /* ALLOCATE DUMMY        */
            ALLOCATE DDNAME(SYSOUT) DUMMY /* ALLOCATE DUMMY          */
          END                       /* ALLOCATION COMPLETE           */
        ELSE                        /* SYSOUT COMPLETE               */
      /*-------------------------------------------------------------*/
      /* INVOKE COMPILER PRE-LINKEDIT ROUTINE (&PLINK)               */
      /*-------------------------------------------------------------*/
      CALL &PLINK '&POPTION'        /* CALL PRELINK UTILITY     LI319*/
      SET &DERROR = &LASTCC         /* SAVE PRELINK RETURN CODE      */
      IF &ERROR LT &DERROR THEN     /* DETERMINE HIGHEST ERROR       */+
         SET &ERROR = &DERROR       /* SAVE HIGHEST RETURN CODE      */
      ELSE                          /* ERROR COMPLETE                */
      /*-------------------------------------------------------------*/
      /* FREE ALLOCATED DATA SETS, AND SYSPRINT                      */
      /*-------------------------------------------------------------*/
      IF &CONTROL = NONE THEN       /* IF NO MESSAGES REQUESTED      */+
        CONTROL NOMSG               /* SUPPRESS MESSAGES             */
      ELSE                          /* CONTROL COMPLETE              */
      FREE DDNAME(SYSLIB)           /* FREE SYSLIB                   */
      FREE DDNAME(SYSMSGS)          /* FREE SYSMSGS                  */
      FREE DDNAME(SYSIN)            /* FREE SYSIN                    */
      FREE DDNAME(SYSMOD)           /* FREE SYSMOD                   */
      IF &PRINT NE LEAVE THEN       /* IF PRINT ALLOCATED            */+
        DO                          /* FREE SYSPRINT, SYSOUT         */
          /*---------------------------------------------------------*/
          /* FREE SYSPRINT AND SYSOUT                                */
          /*---------------------------------------------------------*/
          FREE DDNAME(SYSPRINT)     /* FREE SYSPRINT                 */
          FREE DDNAME(SYSOUT)       /* FREE SYSOUT                   */
        END                         /* FREE COMPLETE                 */
      ELSE                          /* PRINT COMPLETE                */
      CONTROL MSG                   /* ALLOW MESSAGES AGAIN          */
      /*-------------------------------------------------------------*/
      /* DSNH740I: PRE-LINKEDIT PASS WALL MESSAGE                    */
      /*-------------------------------------------------------------*/
      IF &WALLF = YES THEN          /* MESSAGE DSNH740I              */+
        SET &WALL4 = &STR(.SYSOUT.PRELLIST &WALLB)
      WRITE &WALL1 PRELINK &WALL2 &DERROR &WALL3.&WALL4
      /*-------------------------------------------------------------*/
      /* CHECK PRE-LINKEDIT RETURN CODE                              */
      /* IF SEVERE ERROR, THEN EXIT DSNH CLIST                       */
      /*-------------------------------------------------------------*/
      IF &ERROR GE &RCTERM THEN     /* GREATER THAN MAXIMUM ?        */+
        DO                          /* WRITE ERROR MSG, EXIT         */
          /*---------------------------------------------------------*/
          /* DSNH759I: PRELINK ERROR                                 */
          /*---------------------------------------------------------*/
          WRITE &M759 PRELINK RC = &ERROR
          EXIT CODE(&ERROR)         /* EXIT DSNH CLIST               */
        END                         /* SEVERE ERROR ENCOUNTERED      */
      ELSE                          /* RETURN CODE COMPLETE          */
    END                             /* PRE-LINKEDIT COMPLETE         */
  ELSE                              /* PRE-LINKEDIT COMPLETE         */
  /*******************************************************************/
  /*                                                                 */
  /*                        LINK                                     */
  /*                 INVOKE LINKAGE EDITOR                           */
  /*                                                                 */
  /*   INVOCATION OF THE LINKEDIT STEP                               */
  /*                                                                 */
  /* INVOKED ROUTINE: TSO LINK COMMAND                               */
  /*                                                                 */
  /* FOLLOWING BASED UPON HOST LANGUAGE AND EXECUTION ENVIRONMENT:   */
  /*                                                                 */
  /* DSNHINCL: MODULES INCLUDED IN LINKEDIT STEP FROM INCLIB         */
  /* ENTRY:    ENTRY NAME FOR LINKAGE EDITOR FROM ENTRY KEYWORD      */
  /*                                                                 */
  /* LANGUAGE INTERFACE MODULES:                                     */
  /*          DSNHLI ENTRY POINT IS RESOLVED DURING LINKEDIT  TU2390A*/
  /*          TO INCLUDE THE APPROPRIATE LANGUAGE INTERFACE   TU2390A*/
  /*          (LI) MODULE AS FOLLOWS:                         TU2390A*/
  /*                                                          TU2390A*/
  /*          TSO  - DSNELI: DEFAULT IS ALIAS OF ELI FOR HLI  TU2390A*/
  /*                         IN DB2 LIBRARIES, THEREFORE NO   TU2390A*/
  /*                         NEED TO INCLUDE SPECIFICALLY.    TU2390A*/
  /*          CAF  - DSNALI: MUST SPECIFICALLY INCLUDE TO     TU2390A*/
  /*                         AVOID DEFAULT OF TSO.            TU2390A*/
  /*                         REPLACE DSNHLI: PREVENT IEW0241  TU2390A*/
  /*                         FOR CAF/APPL WITH DUMMY DSNHLI   TU2390A*/
  /*          IMS  - DFSLI000: HAS ALIAS OF HLI IN IMS        TU2390A*/
  /*                         LIBRARIES, THEFORE NO NEED TO    TU2390A*/
  /*                         INCLUDE SPECIFICALLY.            TU2390A*/
  /*          CICS - DSNCLI: NO SPECIFIC ALIAS, THEREFORE     TU2390A*/
  /*                         MUST INCLUDE DSNCLI.             TU2390A*/
  /*         RRSAF - DSNRLI: MUST SPECIFICALLY INCLUDE TO    TU35332I*/
  /*                         AVOID DEFAULT OF TSO.           TU35332I*/
  /*******************************************************************/
  IF &LINK    = YES THEN            /* IF LINK IS REQUESTED THEN     */+
    DO                              /* INVOKE THE LINKAGE EDITOR     */
      /*-------------------------------------------------------------*/
      /* SETUP LIBRARY KEYWORD VARIABLES BASED ON HOST LANGUAGE      */
      /*-------------------------------------------------------------*/
      SET &ILIB = &STR(&XLIB)       /* NOTE THE LIBRARIES NEEDED     */
      IF &HOST = C THEN             /* IF THIS IS A C PROGRAM        */+
        DO                          /* DETERMINE C LIBRARIES    LI319*/
          /*---------------------------------------------------------*/
          /* HOST LANGUAGE IS C:                                LI319*/
          /*   USE CCLLIB. ADD CCPLIB IF NOT (NONE)             LI319*/
          /*---------------------------------------------------------*/
          SET &ILIB = &STR(&ILIB &CCLLIB)              /* ADD LIB    */
          IF &STR(&CCPLIB) ^= NONE THEN /* CCPLIB SPECIFIED ?   LI319*/+
            SET &ILIB = &STR(&ILIB &CCPLIB) /* ADD CCPLIB       LI319*/
        END                         /* C LIBRARIES COMPLETE     LI319*/
      IF &HOST = CPP THEN           /* IF THIS IS A C++ PROGRAM LI319*/+
         SET &ILIB = &STR(&ILIB &CPPCLLIB)           /* ADD LIB LI319*/
      IF &HOST = IBMCOB THEN        /* IF OOCOBOL PROGRAM       LI319*/+
         SET &ILIB = &STR(&ILIB &COBILINK)           /* ADD LIB LI319*/
      IF &HOST = COBOL   THEN       /* IF THIS IS A COBOL PROGRAM    */+
         SET &ILIB = &STR(&ILIB &COBLIB)              /* ADD LIB     */
      IF &HOST = COB2 AND           /* IS THIS A COB2 PROG   @BA26814*/+
         &ATTACH = CICS  THEN       /* AND ATTACH IS CICS    @BA26814*/+
         SET &ILIB = &STR(&ILIB &COB2CICS)    /* ADD LIB     @BA26814*/
      IF &HOST = COB2    THEN       /* IF THIS IS A COB2 PROGRAM     */+
         SET &ILIB = &STR(&ILIB &COB2LIB)             /* ADD LIB     */
      IF &SUFF = PLI     THEN       /* IF THIS IS A PLI PROG         */+
         SET &ILIB = &STR(&ILIB &PLILIB)              /* ADD LIB     */
      IF &SUFF = PLI AND            /* IF THIS IS A PLI PROG    D7053*/+
         &STR(&PLI2LIB) NE NONE THEN      /* IF NOT NULL KEYWD  D7053*/+
         SET &ILIB = &STR(&ILIB &PLI2LIB) /* ADD LIB TO LIST    D7053*/
      /* NEXT 16 LINES DELETED BY KEW0324                            */
      IF &SUFF = FORTRAN THEN       /* IF THIS IS A FORTRAN PROG     */+
         SET &ILIB = &STR(&ILIB &FORTLIB)             /* ADD LIB     */
      IF &ATTACH  = IMS THEN        /* IF THIS IS IMS PROGRAM        */+
         SET &ILIB = &STR('&IMSPRE..RESLIB' &ILIB)    /* ADD LIB     */
      IF &ATTACH  = CICS THEN       /* IF THIS IS CICS PROGRAM       */+
         DO
           IF &CICSPRE = &STR() THEN +
               SET &ILIB = &STR(&ILIB '&CICSLLIB.')
           ELSE  +
               SET &ILIB = &STR(&ILIB '&CICSPRE..&CICSLOAD.')
         END
      IF &CONTROL = NONE THEN       /* IF NO MESSAGES                */+
        CONTROL NOMSG               /* NO MESSAGES - DELETE,FREE     */
      DELETE &OUTNAME..DATA         /* DELETE THE LKED INPUT         */
      FREE DDNAME(DSNHINCL, INCLIB)                            +
        ATTR(DSNHF80)               /* FREE DDNAMES, ATTRIBUTES      */
      CONTROL MSG                   /* RESUME MESSAGES               */
      /*-------------------------------------------------------------*/
      /* DSNHF80: DEFINE DCB ATTRIBUTES                              */
      /*-------------------------------------------------------------*/
      ATTRIB DSNHF80 LRECL(80) RECFM(F B)                              +
         BLKSIZE(80)                /* SET THE DCB ATTRIBUTES        */
      /*-------------------------------------------------------------*/
      /* DSNHINCL: ALLOCATE AND OPEN DATA SET                        */
      /*-------------------------------------------------------------*/
      ALLOCATE DDNAME(DSNHINCL) USING(DSNHF80) NEW TRACK               +
        &WORKU SPACE(1 1) DSNAME(&OUTNAME..DATA)   /* NEW DS         */
      OPENFILE DSNHINCL OUTPUT      /* OPEN THE FILE                 */
      /*-------------------------------------------------------------*/
      /* DETERMINE LINKEDIT MODULE INCLUDES BASED ON HOST LANGUAGE,  */
      /* AND EXECUTION ENVIRONMENT                                   */
      /*-------------------------------------------------------------*/
      IF &ATTACH = TSO OR           /* ATTACH IS TSO OR       TU2390A*/+
         &ATTACH = CAF OR           /* ATTACH IS CAF         TU35332I*/+
         &ATTACH = RRSAF THEN       /* ATTACH IS RRSAF       TU35332I*/+
         DO                         /* TSO/CAF ATTACH INCLUDES       */
            /*-------------------------------------------------------*/
            /* EXECUTION IN TSO OR CAF                        TU2390A*/
            /*-------------------------------------------------------*/
            IF &ATTACH = CAF THEN   /* ATTACH IS CAF          TU2390A*/+
              DO                    /* BUILD FORTRAN INCLUDE  TU2390A*/
                /*---------------------------------------------------*/
                /* INCLUDE CAF LANGUAGE INTERFACE (DSNALI)    TU2390A*/
                /*---------------------------------------------------*/
                SET &DSNHINCL = &STR(  INCLUDE INCLIB(DSNALI))
                PUTFILE DSNHINCL    /* OUTPUT THE INCLUDE     TU2390A*/
                SET &DSNHINCL = &STR(  REPLACE DSNHLI)
                PUTFILE DSNHINCL    /* OUTPUT THE REPLACE     TU2390A*/
              END                   /* INTEFRACE COMPLETE     TU2390A*/
            ELSE                    /* CHECK TSO OR RRSAF    TU35332I*/+
              IF &ATTACH = RRSAF THEN  /* ATTACH IS RRSAF ?  TU35332I*/+
                DO                  /* RRSAF INCLUDES        TU35332I*/
                  /*-------------------------------------------------*/
                  /* INCLUDE RRSAF LANG INTERFACE (DSNRLI)   TU35332I*/
                  /*-------------------------------------------------*/
                  SET &DSNHINCL = &STR(  INCLUDE INCLIB(DSNRLI))
                  PUTFILE DSNHINCL  /* OUTPUT THE INCLUDE    TU35332I*/
                  SET &DSNHINCL = &STR(  REPLACE DSNHLI)
                  PUTFILE DSNHINCL  /* OUTPUT THE REPLACE    TU35332I*/
                END               /* INTEFRACE COMPLETE      TU35332I*/
            /*-------------------------------------------------------*/
            /* ALWAYS INCLUDE DSNHOBJ                        TU35332I*/
            /*-------------------------------------------------------*/
            SET &DSNHINCL = &STR(  INCLUDE DSNHOBJ)
            PUTFILE DSNHINCL        /* OUTPUT THE INCLUDE            */
            /*-------------------------------------------------------*/
            /* CHECK FOR HOST FORTRAN                        TU35332I*/
            /*-------------------------------------------------------*/
            IF &HOST = FORTRAN THEN /* BUILD INCLUDE                 */+
               DO                   /* BUILD FORTRAN INCLUDE         */
                 IF &ATTACH = CAF OR   /* ATTACH IS CAF       TU2390A*/+
                    &ATTACH = RRSAF THEN /* ATTACH IS RRSAF  TU35332I*/+
                   DO               /* OVERIDE DSNELI INCLUDE TU2390A*/
                     /*----------------------------------------------*/
                     /* REPLACE TSO DSNELI IF CAF OR RRSAF   TU35332I*/
                     /*----------------------------------------------*/
                     SET &DSNHINCL = &STR(  REPLACE DSNELI)
                     PUTFILE DSNHINCL /* OUTPUT THE REPLACE   TU2390A*/
                   END              /* FORTRAN COMPLETE       TU2390A*/
                 /*--------------------------------------------------*/
                 /* CREATE INCLUDES FOR FORTRAN LANGUAGE (DSNHFT)    */
                 /*--------------------------------------------------*/
                 SET &DSNHINCL = &STR(  INCLUDE INCLIB(DSNHFT))
                 PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE            */
               END                  /* OF IF FORTRAN                 */
         END                        /* INCLUDES COMPLETE      TU2390A*/
      IF &ATTACH = IMS   THEN       /* SET UP INCLUDES FOR IMS       */+
         DO                         /* IMS   ATTACH INCLUDES         */
            /*-------------------------------------------------------*/
            /* EXECUTION IN IMS/ATTACH                               */
            /*-------------------------------------------------------*/
            SET &DSNHINCL = &STR(  INCLUDE DSNHOBJ)
            PUTFILE DSNHINCL        /* OUTPUT THE INCLUDE            */
         END                        /* IMS ATTACH INCLUDES           */
      IF &ATTACH = CICS  THEN       /* SET UP INCLUDES FOR CICS      */+
         DO                         /* CICS  ATTACH INCLUDES         */
            /*-------------------------------------------------------*/
            /* EXECUTION IN CICS/ATTACH                              */
            /*-------------------------------------------------------*/
            IF &HOST = ASM  THEN    /* IF THIS IS ASM                */+
               DO                   /* BUILD ASM INCLUDE             */
                 /*--------------------------------------------------*/
                 /* CREATE INCLUDES FOR ASM LANGUAGES                */
                 /*--------------------------------------------------*/
                 SET &DSNHINCL = &STR(  INCLUDE INCLIB(DFHEAI))
                 PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE            */
               END                  /* OF IF ASM                     */
            IF &HOST = COB2 OR      /* IF THIS IS COBOL OR COB2      */+
               &HOST = COBOL THEN   /* ADD INCLUDE STATEMENT         */+
               DO                   /* BUILD COBOL   INCLUDE         */
                 /*--------------------------------------------------*/
                 /* CREATE INCLUDES FOR COB2/COBOL LANGUAGES         */
                 /*--------------------------------------------------*/
                 IF &COB370 = NO THEN  /* ADD CICS COBOL LIB  KES0005*/+
                   SET &DSNHINCL = &STR(  INCLUDE INCLIB(DFHECI))
                 ELSE                  /* ADD LE/370 LIB      KES0005*/+
                   SET &DSNHINCL = &STR(  INCLUDE INCLIB(DFHELII))
                 PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE            */
               END                  /* OF IF COBOL                   */
            IF &HOST = IBMCOB THEN  /* OR THIS IS IBM COBOL       BCM*/+
               DO                   /* SETUP FOR IBM COBOL        BCM*/
                 SET &DSNHINCL = &STR(  INCLUDE INCLIB(CEESTART))
                 PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE            */
                 SET &DSNHINCL = &STR(  INCLUDE INCLIB(DFHELII))
                 PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE            */
               END                  /* IBM COBOL COMPLETE         BCM*/
            IF &HOST = C OR         /* IF THIS IS C COMPILER    LI319*/+
               &HOST = CPP THEN     /* IF THIS IS C++ COMPILER  LI319*/+
               DO                   /* BUILD C370 INCLUDE     KYL1174*/
                 /*--------------------------------------------------*/
                 /* CREATE INCLUDES FOR 'C/C++'                 LI319*/
                 /*--------------------------------------------------*/
                 SET &DSNHINCL = &STR(  INCLUDE INCLIB(DFHELII))
                 PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE       D6197*/
               END                  /* OF IF COBOL              D6197*/
            IF &HOST = PLI THEN     /* IF THIS IS PLI           D6197*/+
               DO                   /* BUILD PLI INCLUDE             */
                 /*--------------------------------------------------*/
                 /* CREATE INCLUDES FOR PLI LANGUAGES                */
                 /*--------------------------------------------------*/
                IF &PLITYPE = NO THEN    /* LINK FOR OS PL/I     @02 */+
                 DO                                        /*KES0005 */
                  SET &DSNHINCL = &STR(  INCLUDE INCLIB(DFHPL1OI))
                  PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE           */
                  SET &DSNHINCL = &STR(  INCLUDE INCLIB(DFHEPI))
                  PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE           */
                  SET &DSNHINCL = &STR(  REPLACE PLISTART)
                  PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE           */
                 END                                       /*KES0005 */
                ELSE                /* LINK FOR PL/I 370     KES0005 */+
                 DO                                        /*KES0005 */
                  SET &DSNHINCL = &STR(  INCLUDE INCLIB(DFHELII))
                  PUTFILE DSNHINCL   /* OUTPUT THE INCLUDE           */
                 END                                       /*KES0005 */
               END                  /* OF IF PLI                     */
            /*-------------------------------------------------------*/
            /* DSNHINCL: PUTFILE FOR SELECTED MODULES TO BE INCLUDED */
            /*-------------------------------------------------------*/
            SET &DSNHINCL = &STR(  INCLUDE DSNHOBJ)
            PUTFILE DSNHINCL        /* OUTPUT THE INCLUDE            */
            SET &DSNHINCL = &STR(  INCLUDE INCLIB(DSNCLI))
            PUTFILE DSNHINCL        /* OUTPUT THE INCLUDE            */
         END                        /* CICS  ATTACH INCLUDES         */
      /*-------------------------------------------------------------*/
      /* DETERMINE ENTRY NAME BASED ON HOST LANGUAGE, AND EXECUTION  */
      /* ENVIRONMENT                                                 */
      /*-------------------------------------------------------------*/
      IF &ENTRY = DEFAULT THEN      /* IF ENTRY STMT IS NEEDED       */+
         DO                         /* SET UP THE ENTRY STMT         */
            /*-------------------------------------------------------*/
            /* SETUP ENTRY NAME BASED ON DEFAULT                     */
            /*-------------------------------------------------------*/
            SET &ENT = &STR(DEFAULT)      /* ENTRY NAME              */
            IF &ATTACH ^= CICS AND        /* IF THIS NOT CICS BUT    */+
               &HOST    = PLI  THEN       /* IS PLI          @BA04716*/+
             DO                                            /*KES0005 */
              IF &PLITYPE  = NO THEN       /* NOT PLI/370         @02*/+
               SET &ENT = &STR(PLISTART)  /* ENTRY NAME              */
              ELSE                        /* PLI/370          KES0005*/+
               SET &ENT = &STR(CEESTART)  /* ENTRY NAME       KES0005*/
             END                                            /*KES0005*/
            IF &ATTACH = IMS THEN         /* IF THIS IS IMS, SET UP  */+
              DO                                            /*KES0005*/
               SET &ENT = &STR(DLIT&SUFF) /* ENT NAME         PL00008*/
               IF &HOST = PLI THEN        /* THIS IS PLI      PL00008*/+
                DO                                          /*KES0005*/
                 IF &PLITYPE = NO THEN     /* THIS IS OS/PLI      @02*/+
                  SET &ENT = &STR(PLISTART) /* ADD ENT        KYW2226*/
                 ELSE  SET &ENT = &STR(CEESTART) /* ADD ENT   KES0005*/
                END                                         /*KES0005*/
               IF &SUFF = COBOL OR &SUFF = IBMCOB THEN      /*PQ36839*/+
                 SET &ENT = &STR(DLITCBL)   /* ENTRY NAME     PL00008*/
              END                                           /*KES0005*/
            IF &ENT NE DEFAULT THEN       /* IF ENTRY STMT NEED      */+
               DO                         /* SET UP THE ENTRY STMT   */
                  /*-------------------------------------------------*/
                  /* DSNHINCL: PUTFILE FOR ENTRY NAME                */
                  /*-------------------------------------------------*/
                  SET &DSNHINCL = &STR(  ENTRY &ENT)
                  PUTFILE DSNHINCL        /* OUTPUT THE ENTRY STMT   */
               END               /* SET UP THE ENTRY STMT            */
         END                     /* SET UP THE ENTRY STMT            */
      IF &ENTRY NE DEFAULT AND   /* IF ENTRY STMT IS NEEDED          */+
         &ENTRY NE NONE THEN     /* IF ENTRY STMT IS NEEDED          */+
         DO                      /* SET UP THE ENTRY STMT            */
            /*-------------------------------------------------------*/
            /* DSNHINCL: PUTFILE FOR ENTRY NAME SPECIFIED            */
            /*-------------------------------------------------------*/
            SET &DSNHINCL = &STR(  ENTRY &ENTRY)
            PUTFILE DSNHINCL     /* OUTPUT THE ENTRY STMT            */
         END                     /* SET UP THE ENTRY STMT            */
      /*-------------------------------------------------------------*/
      /* DSNHINCL: CLOSE FILE                                        */
      /*-------------------------------------------------------------*/
      CLOSFILE DSNHINCL          /* CLOSE THE FILE                   */
      /*-------------------------------------------------------------*/
      /* ALLOCATE INCLIB, DSNHOBJ, DATA SET NAME                     */
      /*-------------------------------------------------------------*/
      ALLOCATE DDNAME(INCLIB) DSNAME(&ILIB) SHR REUSE
      ALLOCATE DDNAME(DSNHOBJ) SHR REUSE DSNAME(&LKDSNAME)
      IF &PRINT = TERM OR        /* SEE IF PRINT TO TERMINAL         */+
         &PRINT = LEAVE THEN     /* OR PRINT TO CURRENT              */+
        SET &LOPTION = &NRSTR(&LOPTION) &STR(PRINT(*))
      ELSE                       /* PRINT ISN'T TERM                 */+
        IF &PRINT NE NONE AND &PRINT NE LEAVE THEN   /* IF NEED ALLOC*/+
          DO                        /* DELETE, THEN ALLOC    @BA18169*/
            /*-------------------------------------------------------*/
            /* ALLOCATE SYSPRINT TO DATA SET                         */
            /*-------------------------------------------------------*/
            IF &CONTROL = NONE THEN /* IF NO MESSAGES        @BA18169*/+
              CONTROL NOMSG         /* AVOID DELETE MESSAGES @BA18169*/
            DELETE &PRINT..LINKLIST /* DEL OUTPUT DATA SET   @BA18169*/
            FREE DDNAME(SYSPRINT)   /* FREE DDNAME           @BA18169*/
            CONTROL MSG             /* ALLOW MESSAGES AGAIN  @BA18169*/
            ALLOCATE DDNAME(SYSPRINT) DSNAME(&PRINT..LINKLIST) NEW     +
              SPACE(&PSPACE &PSECSPAC) &SPACEUN &WORKU
            SET &LOPTION = &STR(&NRSTR(&LOPTION) PRINT(&PRINT))
          END                    /* DELETE, THEN ALLOC DATA  @BA18169*/
      IF &TERM  = NONE THEN      /* IF TERM IS NONE, NO MSGS         */+
        SET &LOPTION = &STR(&NRSTR(&LOPTION) NOTERM)
      IF &PRINT NE NONE THEN     /* IF PRINT IS WANTED, GET IT       */+
        SET &LOPTION = &STR(&NRSTR(&LOPTION) LIST MAP)
      IF &XREF  NE NO   THEN     /* IF XREF IS WANTED, GET IT        */+
        SET &LOPTION = &STR(&NRSTR(&LOPTION) XREF)
      SET &LONL =
      /*-------------------------------------------------------------*/
      /* SETUP LIBRARY KEYWORD VARIABLES                             */
      /*-------------------------------------------------------------*/
      IF &LLIB NE NONE THEN SET &LONL = &STR(&LLIB)
      IF &L2LIB NE NONE THEN SET &LONL = &STR(&LONL &L2LIB)
      IF &L3LIB NE NONE THEN SET &LONL = &STR(&LONL &L3LIB)
      IF &L4LIB NE NONE THEN SET &LONL = &STR(&LONL &L4LIB)
      /***************************************************************/
      /* INVOKE TSO LINK COMMAND                                     */
      /***************************************************************/
      LINK (&OUTNAME..DATA) LOAD(&LOADIT) &LOPTION               +
           LIB(&ILIB &LONL)      /* LINKEDIT THE MODULE              */
      SET &DERROR = &LASTCC      /* IF LINK WORKED           @BA18169*/
      IF &ERROR LT &DERROR THEN SET &ERROR = &DERROR /* SAVE RETCODE */
      IF &CONTROL = NONE THEN    /* IF NO MESSAGES WANTED            */+
        CONTROL NOMSG            /* NO MESSAGES FOR FREE CMD         */
      /*-------------------------------------------------------------*/
      /* FREE INTERMEDIATE DATA SETS                                 */
      /*-------------------------------------------------------------*/
      FREE DDNAME(DSNHINCL, INCLIB) DSNAME(&LKDSNAME &ILIB             +
      &LONL &LOAD) ATTR(DSNHF80) /*                                  */
      IF &PRINT NE TERM AND      /* SEE IF PRINT TO TERMINAL @BA18169*/+
         &PRINT NE LEAVE AND     /* OR PRINT TO CURRENT      @BA18169*/+
         &PRINT NE NONE THEN     /* OR PRINT TO NONE         @BA25449*/+
        FREE DDNAME(SYSPRINT)    /* FREE SYSPRINT            @BA18169*/
      CONTROL MSG                /* RESUME MESSAGES                  */
      /*-------------------------------------------------------------*/
      /* DSNH740I: LINK PASS WALL MESSAGE                            */
      /*-------------------------------------------------------------*/
      IF &WALLF = YES THEN       /* IF PRINT NAME TO BE ADDED, ADD   */+
        SET &WALL4 = &STR(.LINKLIST &WALLB)  /* PRINT DATA SET NAME  */
      WRITE &WALL1 LINK &WALL2 &DERROR &WALL3.&WALL4
      IF &ERROR GE &RCTERM THEN  /* IF MAX RETCODE EXCEEDED          */+
        DO                       /* WRITE ERROR MESSAGE, EXIT        */
          /*---------------------------------------------------------*/
          /* DSNH759I: LINK ERROR                                    */
          /*---------------------------------------------------------*/
          WRITE &M759 LINK RC = &ERROR
          EXIT CODE(&ERROR)      /* EXIT FROM THIS CLIST             */
        END                      /* OF SEVERE ERROR HANDLING         */
    END                          /* OF LINKAGE EDITOR INVOCATION     */
  /*******************************************************************/
  /*                                                                 */
  /*                        RUN                                      */
  /*                 INVOKE COMPILED PROGRAM                         */
  /*                                                                 */
  /*   INVOCATION OF THE COMPILED PROGRAM IN THE TSO ENVIRONMENT     */
  /*   BASED UPON THE SUCCESSFUL COMPLETION OF THE PRIOR JOB STEPS.  */
  /*   EXECUTION ENVIRONMENT BASED ON RUN KEYWORD.                   */
  /*                                                                 */
  /* INVOKED ROUTINE: COMPILED PROGRAM                               */
  /*                                                                 */
  /* INPUT PARAMETERS: PARMS KEYWORD - PARAMETERS TO BE PASSED TO    */
  /*                   INVOKED PROGRAM:                              */
  /*             NOTE: DSN/RUN ONLY, CAF DOES NOT SUPPORT     TU2390A*/
  /*                   USE OF PARMS FOR CALLER                TU2390A*/
  /* INPUT:  RUNIN KEYWORD - STANDARD DDNAME INPUT                   */
  /* OUTPUT: RUNOUT KEYWORD - STANDARD DDNAME OUTPUT                 */
  /*                                                                 */
  /* EXECUTION:                                               TU2390A*/
  /*            DSN - COMMAND PROCESSOR:                             */
  /*             |    SYSTEM KEYWORD (SUBSYSTEM NAME)                */
  /*             |    CONTROL KEYWORD (CONTROL-OPTION)               */
  /*             |                                                   */
  /*             *--->RUN - PROGRAM NAME                             */
  /*                        PLAN NAME                                */
  /*                        LIBRARY NAME                             */
  /*                        PARAMETERS                               */
  /*          - OR  -                                         TU2390A*/
  /*                                                          TU2390A*/
  /*            CAF - CALL ATTACHMENT FACILITY:               TU2390A*/
  /*             |    SUBSYSTEM NAME - DEFAULT                TU2390A*/
  /*             *--->CALL (PROGRAM NAME)                     TU2390A*/
  /*                                                                 */
  /*******************************************************************/
  IF &RUN = YES THEN             /* IF RUN WAS REQUESTED             */+
    DO                           /* INVOKE DSN AND RUN PROG          */
      /*-------------------------------------------------------------*/
      /* DEFINE INPUT/OUTPUT DATA SETS                               */
      /*-------------------------------------------------------------*/
      SET &RUNOUTDD = SYSPRINT   /* SET STANDARD DDNAME PRINT        */
      SET &RUNINDD  = SYSIN      /* SET STANDARD DDNAME INPUT        */
      IF &HOST EQ FORTRAN THEN   /* IF THE LANGUAGE IS FORTRAN       */+
        DO                       /* SET FORTRAN DDNAMES              */
          /*---------------------------------------------------------*/
          /* DEFINE DD NAMES FOR FORTRAN                             */
          /*---------------------------------------------------------*/
          SET &RUNOUTDD = FT06F001  /* STD FORTRAN PRINT             */
          SET &RUNINDD  = FT05F001  /* STD FORTRAN INPUT             */
        END                      /* SET FORTRAN DDNAMES              */
      IF &RUNIN EQ NONE THEN     /* IF NO RUN INPUT                  */+
        ALLOCATE DDNAME(&RUNINDD) DUMMY REUSE      /* ALLOC DUMMY    */
      IF &RUNIN NE NONE THEN     /* IF ALLOCATION REQUESTED          */+
        DO                       /* ALLOCATE A DATA SET (OLD)        */
          /*---------------------------------------------------------*/
          /* DEFINE INPUT TO TERMINAL OR DATA SET                    */
          /*---------------------------------------------------------*/
          IF &RUNIN = TERM THEN  /* IF TERMINAL OUTPUT REQUEST       */+
            ALLOCATE DDNAME(&RUNINDD) DA(*) REUSE  /* ALLOC TERMINAL */
          ELSE                   /* ALLOCATE A DATA SET              */+
            ALLOCATE DDNAME(&RUNINDD) DSNAME(&RUNIN) SHR REUSE
        END                      /* SYSTERM IS ALLOCATED             */
      IF &RUNOUT EQ NONE THEN    /* IF NO RUN OUTPUT                 */+
        DO                       /* ALLOCATE TO DUMMY                */
          /*---------------------------------------------------------*/
          /* DEFINE OUTPUT TO DUMMY                                  */
          /*---------------------------------------------------------*/
          ALLOCATE DDNAME(&RUNOUTDD) DUMMY REUSE /* ALLOC TO DUMMY   */
          IF &HOST EQ C THEN     /* IF THE LANGUAGE IS 'C'           */+
            ALLOCATE DDNAME(CEEDUMP) DUMMY REUSE /* ALLOC TO DUMMY   */
        END                      /* ALLOCATION COMPLETE              */
      IF &RUNOUT NE NONE AND     /* IF ALLOCATION REQUESTED          */+
         &RUNOUT NE LEAVE THEN   /* NOT JUST LEFT FROM BEFORE        */+
        DO                       /* ALLOCATE DATA SET (OLD)          */
          /*---------------------------------------------------------*/
          /* DEFINE OUTPUT TO TERMINAL OR DATA SET                   */
          /*---------------------------------------------------------*/
          IF &RUNOUT = TERM THEN /* IF TERM OUTPUT REQUEST TERMINAL  */+
            DO                   /* ALLOCATE TO TERMINAL             */
              /*-----------------------------------------------------*/
              /* DEFINE OUTPUT TO TERMINAL                           */
              /*-----------------------------------------------------*/
              ALLOCATE DDNAME(&RUNOUTDD) DA(*) REUSE
              IF &HOST EQ C THEN /* IF THE LANGUAGE IS 'C'           */+
                ALLOCATE DDNAME(CEEDUMP) DA(*) REUSE
            END                  /* ALLOCATION COMPLETE              */
          ELSE                   /* ALLOCATE A DATA SET              */+
            DO                   /* DELETE, THEN ALLOC DATA          */
              /*-----------------------------------------------------*/
              /* ALLOCATE OUTPUT DATA SET                            */
              /*-----------------------------------------------------*/
              IF &CONTROL = NONE THEN  /* IF NO MESSAGES             */+
                CONTROL NOMSG    /* AVOID DELETE MESSAGES            */
              DELETE &RUNOUT     /* DELETE OUTPUT DATA SET           */
              FREE DDNAME(&RUNOUTDD) ATTR(DSNHF133) /* FREE DD       */
              CONTROL MSG        /* ALLOW MESSAGES AGAIN             */
              /*-----------------------------------------------------*/
              /* DSNHF133: DEFINE DCB ATTRIBUTES                     */
              /*-----------------------------------------------------*/
              ATTRIB DSNHF133 LRECL(133) RECFM(F B A) BLKSIZE(3990)
              ALLOCATE DDNAME(&RUNOUTDD) DSNAME(&RUNOUT) NEW           +
                SPACE(&PSPACE &PSECSPAC) &SPACEUN USING(DSNHF133)      +
                &WORKU                           /* @BA04731*/
              IF &HOST EQ C THEN /* IF THE LANGUAGE IS 'C'           */+
                DO               /* ALLOCATE CEEDUMP TO DATA SET     */
                  /*-------------------------------------------------*/
                  /* ALLOCATE CEEDUMP TO DATA SET                    */
                  /*-------------------------------------------------*/
                  IF &CONTROL = NONE THEN /* IF NO MSGS WANTED       */+
                    CONTROL NOMSG  /* SUPPRESS MESSAGES              */
                  DELETE &PRINT..CEEDUMP.RUN /* DELETE DATA SET      */
                  FREE DDNAME(CEEDUMP) /* BE SURE DDNAME FREE        */
                  FREE ATTR(DSNHFBA)   /* FREE ATTRIBUTE             */
                  CONTROL MSG    /* ALLOW MESSAGES                   */
                  /*-------------------------------------------------*/
                  /* DSNHFBA: DEFINE DCB ATTRIBUTES                  */
                  /*-------------------------------------------------*/
                  ATTR DSNHFBA RECFM(F B A) LRECL(121) BLKSIZE(3630)
                  ALLOCATE DDNAME(CEEDUMP) +
                    DSNAME(&PRINT..CEEDUMP.RUN) +
                    NEW SPACE(&PSPACE &PSECSPAC) &SPACEUN &WORKU +
                    USING(DSNHFBA)
                  FREE ATTR(DSNHFBA)   /* FREE ATTRIBUTE             */
                END              /* ALLOCATE COMPLETE                */
            END                  /* DELETE, THEN ALLOC DATA          */
        END                      /* SYSPRINT IS ALLOCATED            */
      IF &ATTACH = TSO THEN      /* EXECUTE UNDER TSO ?       TU2390A*/+
        DO                       /* EXECUTE PROGRAM           TU2390A*/
          /*---------------------------------------------------------*/
          /* DETERMINE PARAMETERS TO BE PASSED TO PROGRAM            */
          /*---------------------------------------------------------*/
          IF &STR(&PARMS) EQ NONE THEN  /* IF NO RUN PARMS THEN      */+
            SET &PARMS =         /* BLANK THE SETTING                */
          ELSE                   /* ADD KEYWORD                      */+
            DO                   /* ADD KEYWORD, PULL APOSTS         */
              /*-----------------------------------------------------*/
              /* SETUP FOR USER SUPPLIED PARAMETERS                  */
              /*-----------------------------------------------------*/
              IF &SUBSTR(1,&PARMS) ^= &STR(') THEN   /* IF NO APOSTS*/+
                SET &PARMS = &STR(')&NRSTR(&PARMS)&STR(')
              SET &PARMS = &STR(PARMS(&NRSTR(&PARMS)))
            END                  /* PARMS COMPLETE                   */
          /***********************************************************/
          /* INVOKE DSN COMMAND PROCESSOR                            */
          /***********************************************************/
          DSN SYSTEM(&SYSTEM) &DSNTRC   /* INVOKE DSN COMMAND        */
          SET &DERROR = &LASTCC      /* GET RETURN CODE FROM DSN     */
          IF &DERROR > &ERROR THEN   /* IF NEW ERROR IS LARGER       */+
            SET &ERROR = &DERROR     /* NOTE THE MOST SEVERE ERROR   */
          IF &DERROR = 0 THEN        /* IF DSN SUCCEEDED             */+
            DO                       /* INVOKE THE RUN SUBCOMMAND    */
              /*******************************************************/
              /* INVOKE PROGRAM UNDER RUN SUBCOMMAND                 */
              /*******************************************************/
              RUN PROGRAM(&LMEM) PLAN(&PLAN) LIBRARY(&LOAD)            +
                  &STR(&PARMS)
              DATA                   /* AVOID USING DATA AS CLIST    */
              END                    /* OF DSN COMMAND               */
              ENDDATA                /* OF DATA BLOCK                */
            END                      /* INVOKE THE RUN SUBCOMMAND    */
        END                      /* EXECUTION COMPLETE        TU2390A*/
      ELSE                       /* EXECUTE UNDER CAF         TU2390A*/+
        DO                       /* EXECUTE PROGRAM           TU2390A*/
          /***********************************************************/
          /* CALL PROGRAM DIRECTLY USING CAF                  TU2390A*/
          /***********************************************************/
          CALL &LOADIT           /* CALL PROGRAM DIRECTLY     TU2390A*/
        END                      /* EXECUTE PROGRAM           TU2390A*/
      SET &DERROR = &LASTCC      /* IF RUN WORKED            @BA18169*/
      IF &ERROR LT &DERROR THEN SET &ERROR = &DERROR /* RETCODE      */
      IF &CONTROL = NONE THEN    /* IF NO MESSAGES WANTED            */+
        CONTROL NOMSG            /* AVOID FREE   MESSAGES            */
      FREE DDNAME(&RUNINDD) ATTR(DSNHF133) /* FREE UP NAMES          */
      IF &RUNOUT NE LEAVE THEN   /* NOT JUST LEFT FROM BEFORE        */+
        DO                       /* FREE OUTPUT DATA SETS            */
          /*---------------------------------------------------------*/
          /* FREE OUTPUT DATA SETS                                   */
          /*---------------------------------------------------------*/
          FREE DDNAME(&RUNOUTDD) /* THEN FREE THE FILE               */
          IF &HOST EQ C THEN     /* IF THE LANGUAGE IS 'C'           */+
            FREE DDNAME(CEEDUMP) /* THEN FREE PL1DUMP                */
        END                      /* FREE COMPLETE                    */
      CONTROL MSG                /* ALLOW MESSAGES AGAIN             */
      SET &WALL3 = &STR(=============================)
      SET &WALL4 = &STR(=============================)
      IF &RUNOUT NE NONE AND &RUNOUT NE LEAVE +
        AND &RUNOUT NE TERM THEN +
        DO                       /* SET UP A LISTING NAME            */
          /*---------------------------------------------------------*/
          /* SETUP WALL MESSAGE VARIABLES BASED ON OUTPUT            */
          /*---------------------------------------------------------*/
          SET &WALL3 = &STR(======= LISTING IN &RUNOUT)
          SET &WALL4 = &STR(&WALLB) /* PRINT DATA SET                */
        END                      /* SET UP A LISTING NAME            */
      /*-------------------------------------------------------------*/
      /* DSNH740I: RUN PASS WALL MESSAGE                             */
      /*-------------------------------------------------------------*/
      WRITE &WALL1 RUN &WALL2 &DERROR &WALL3.&WALL4
      IF &ERROR GE &RCTERM THEN  /* IF MAX RET CODE EXCED            */+
        DO                       /* ISSUE ERROR MESSAGE, EXIT        */
          /*---------------------------------------------------------*/
          /* DSNH759I: RUN ERROR                                     */
          /*---------------------------------------------------------*/
          WRITE &M759 RUN RC = &ERROR
          EXIT CODE(&ERROR)      /* EXIT FROM THIS CLIST             */
        END                      /* OF SEVERE ERROR HANDLING         */
     END                         /* END OF RUN               @BA18169*/
  /*******************************************************************/
  /*  RESTORE USERS ENVIRONMENT OF SYSPRINT, SYSTERM, SYSIN  @BA44366*/
  /*******************************************************************/
  IF &STR(&SAVEPRINT) NE &STR() THEN /* SYSPRINT SPECIFIED ? @BA44366*/+
    ALLOCATE DDNAME(SYSPRINT) &MODPRINT DSNAME(&SAVEPRINT) REUSE
  IF &STR(&SAVETERM) NE &STR() THEN  /* SYSTERM SPECIFIED ?  @BA44366*/+
    ALLOCATE DDNAME(SYSTERM) &MODTERM DSNAME(&SAVETERM) REUSE
  IF &STR(&SAVESYSIN) NE &STR() THEN /* SYSIN SPECIFIED ?    @BA44366*/+
    ALLOCATE DDNAME(SYSIN) &MODSYSN DSNAME(&SAVESYSIN) REUSE
  EXIT CODE(&ERROR)              /* EXIT FROM THIS CLIST     @BA18169*/
  END                            /* OF DSNH CLIST            @BA18169*/
++
//DSNTIVB.SYSUT2 DD DISP=(NEW,CATLG),
#if ( ${VOLSDEVT} != "" )
//             UNIT=${VOLSDEVT},
#end
#if ( ${DATACLS2} != "" )
//             DATACLAS=${DATACLS2},
#end
#if ( ${MGMTCLS2} != "" )
//             MGMTCLAS=${MGMTCLS2},
#end
#if ( ${STORCLS2} != "" )
//             STORCLAS=${STORCLS2},
#end
#if ( ${VOLSDAT2} != "" )
//             VOL=SER=${VOLSDAT2},
#end
//             SPACE=(3120,(400,100,5)),
//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3120)
//DSNTIV2 EXEC DSNTIVB,CLIST=DSNHC    PRECOMPILE
//DSNTIVB.SYSUT1 DD DATA,DLM='++'
  PROC 0  +
     ASMLIB('''SYS1.MACLIB''') +
     ASMLOAD('''SYS1.LINKLIB(ASMA90)''') +
     ATTACH(TSO) /*KEW0324*/ +
     CLIB(NONE) +
     CICSCLIB('''CICSTS.SDFHCOB''')                        /* F10178 */+
     CICSPLIB('''CICSTS.SDFHPL1''')                        /* F10178 */+
     CCLLIB('''#getLib("${LELKED}","CEE.V!R!M!.SCEELKED")''') +
     CCLOAD('''#getCcload("${CCOMP}","${CPROG}")''') +
     CCMSGS('''#getLib("${CMSGS}","EDC.V!R!M!.SEDCDMSG")(EDCMSGE)''') +
     CCPLIB(NONE) +
     CCSLIB('''#getLib("${CHDRS}","CEE.V!R!M!.SCEEH.H")''') +
     COBICOMP('''#getIcobcomp("${ICOBCOMP}")(IGYCRCTL)''') +
     COBLOAD('''SYS1.LINKLIB(IKFCBL00)''') +
     COB2LOAD('''SYS1.V1R3.COB2COMP(IGYCRCTL)''') +
     CONTROL(NONE) +
     COPTION(NONE) +
     CPPUTIL('''#getLib("${CPPPROC}","CBC.SCCNUTL")(CXX)''') +
     CPPCSLIB('''#getLib("${CHDRS}","CEE.V!R!M!.SCEEH.H")''') +
     CPPSLIB('''#getLib("${CPPHDRS}","CBC.SCLBH.H")''') +
     C2LIB(NONE) +
     C3LIB(NONE) +
     C4LIB(NONE) +
     DELIMIT(DEFAULT) +
     FLAG(I) +
     FORTLOAD('''SYS1.VSF2COMP(FORTVS2)''') +
     HOST(IBMCOB)                                               /*@02*/+
     LINECOUNT(60) +
     MACIN(NONE) +
     MEMBER(DEFAULT) +
     OUTNAME(TEMP) +
     PLILOAD('''SYS1.LINKLIB(IBMZPLI)''') +
     PRINT(NONE) +
     PSECSPAC(20) +
     PSPACE(20) +
     SOURCE(NO) +
     SPACEUN(TRACK) +
     TERM(TERM) +
     WORKUNIT(DEFAULT) +
     WSECSPAC(20) +
     WSPACE(20) +
     XREF(NO)
  /*******************************************************************/
  /* MODULE NAME = DSNHC                                             */
  /* DESCRIPTIVE NAME = COMPILER INVOCATION FOR DSNH CLIST           */
  /*   LICENSED MATERIALS - PROPERTY OF IBM                          */
  /*   5650-DB2                                                      */
  /*   (C) COPYRIGHT 1982, 2016 IBM CORP.  ALL RIGHTS RESERVED.      */
  /*                                                                 */
  /*   STATUS = VERSION 12                                           */
  /* FUNCTION    = THE DSNHC CLIST ALLOWS ONE TO REQUEST             */
  /*               A COMPILATION.                                    */
  /* NOTES       =                                                   */
  /*    DEPENDENCIES = NONE                                          */
  /*    RESTRICTIONS = 1) THE OUTNAME PARAMETER IS USED TO           */
  /*                      GENERATE SEVERAL DATA SET NAMES,           */
  /*                      SO IT MUST NOT CONTAIN SPECIAL             */
  /*                      CHARACTERS.                                */
  /*                   3) NONE IS A RESERVED NAME FOR MACIN,         */
  /*                      CLIB, C2LIB, C3LIB, C4LIB,                 */
  /*                      COPTION, TERM, AND PRINT PARMS.            */
  /*                      LEAVE AND TERM ARE ALSO RESERVED           */
  /*                      FOR PRINT AND TERM PARMS.                  */
  /*                      DEFAULT IS RESERVED FOR DELIMIT            */
  /*                      AND WORKUNIT PARMS.                        */
  /*                   4) THE BUF AND SIZE PARAMETERS                */
  /*                      PASSED TO THE COBOL COMPILER,              */
  /*                      MAY NEED TO BE CHANGED.                    */
  /*                   5) THE PRINT PARAMETER IS USED TO             */
  /*                      GENERATE SEVERAL DATA SET NAMES,           */
  /*                      SO IT MUST NOT CONTAIN SPECIAL             */
  /*                      CHARACTERS.                                */
  /* MODULE TYPE = CLIST OR TSO COMMAND PROCEDURE                    */
  /* ENTRY POINT = DSNHC                                             */
  /*    PURPOSE      = THE DSNH CLIST INVOKES COMPILERS FOR          */
  /*                   VARIOUS HOST LANGUAGES.                       */
  /*    LINKAGE      = INVOCATION FROM DSNH CLIST.                   */
  /*    INPUT        = PARAMETERS PASSED ON DSNH INVOCATION.         */
  /*                   INPUT SOURCE DATA SET                         */
  /*                   OPTIONAL INPUT LIBRARIES                      */
  /*    OUTPUT       = OBJECT MODULES FROM COMPILE/ASSEMBLE          */
  /*                   PRINT LISTINGS ON TERMINAL/DATA SET           */
  /* EXIT-NORMAL = REQUESTED FUNCTIONS PERFORMED                     */
  /* EXIT-ERROR  = RETURN CODES PASSED FROM PROCESSORS               */
  /*    RETURN CODE  = SEE COMPILER RETURN CODES.                    */
  /*    MESSAGE ID   = NONE                                          */
  /*    ABEND CODES  = THIS CLIST ISSUES NO ABENDS, BUT              */
  /*                   INVOKED FUNCTIONS MAY ABEND, CAUSING          */
  /*                   ABEND MESSAGES.                               */
  /*    ERROR MESSAGES =                                             */
  /*                 = DSNH751I DSNHC ERROR IN &KEYWORD              */
  /*                            VALUE &VAL                           */
  /*                 = DSNH754I DSNHC OUTNAME PARAMETER              */
  /*                            &OUTNAME MUST NOT                    */
  /*                            CONTAIN SPECIAL CHARACTERS           */
  /*                 = DSNH756I DSNHC PRINT PARAMETER                */
  /*                            &PRINT MUST NOT CONTAIN              */
  /*                            SPECIAL CHARACTERS                   */
  /*                 = DSNH759I DSNHC TERMINATING, CLIST             */
  /*                            CHECKING RC = &ERROR                 */
  /*    ATTENTION HANDLING = NONE, TO ALLOW INVOKING FUNC-           */
  /*                         TIONS TO HANDLE ATTENTIONS.             */
  /* EXTERNAL REFERENCES =                                           */
  /*    ROUTINES/SERVICES =                                          */
  /*       ALLOCATE  = TSO ALLOCATION COMMAND                        */
  /*       CALL      = TSO PROGRAM INVOCATION                        */
  /*       DELETE    = TSO DATA SET DELETION                         */
  /*       FORTVS    = VS FORTRAN COMPILER                           */
  /*       FREE      = TSO UNALLOCATION COMMAND                      */
  /*       IEL0AA    = PLI    COMPILER                               */
  /*       ASMA90    = HIGH LEVEL ASSEMBLER                          */
  /*       IGYCRCTL  = VS COBOL II COMPILER                          */
  /*       IKFCBL00  = COBOL  COMPILER                               */
  /*       CBC310PP  = C++ COMPILER                             LI319*/
  /*    DDNAMES AND ATTRIBUTES                                       */
  /*       REQUIRED  = SYSGO    FOR ASSEMBLER XF OUTPUT              */
  /*                 = SYSIN    FOR COMPILER INPUT                   */
  /*                 = SYSLIN   FOR COMPILER OUTPUT                  */
  /*       OPTIONAL  = SYSPRINT FOR COMPILER LISTINGS                */
  /*                 = SYSPUNCH FOR COMPILER DECK OUTPUT             */
  /*                            USED ON PL/I MACRO PASS ONLY         */
  /*                 = SYSTERM  FOR COMPILER ERROR MSGS              */
  /*                 = SYSUT1   FOR COMPILER WORK FILE               */
  /*                 = SYSUT2   FOR COMPILER WORK FILE               */
  /*                 = SYSUT3   FOR COMPILER WORK FILE               */
  /*                 = SYSUT4   FOR COMPILER WORK FILE               */
  /*                 = SYSUT5   FOR COMPILER WORK FILE               */
  /*                 = SYSUT6   FOR COMPILER WORK FILE               */
  /*                 = SYSUT7   FOR COMPILER WORK FILE               */
  /*                 = SYSUT8   FOR COMPILER WORK FILE               */
  /*                 = SYSUT9   FOR COMPILER WORK FILE               */
  /*                 = SYSMSGS  C/C++ COMPILER MESSAGES FILE    LI319*/
  /*                 = SYSXMSGS C++ COMPILER MESSAGES FILE      LI319*/
  /*                 = SYSCPRT  C/C++ COMPILER WORK FILE        LI319*/
  /*                 = SYSUT10  C/C++ COMPILER WORK FILE        LI319*/
  /*                            REFERENCE KZW0295               LI319*/
  /*                            AND FOR COBOL 5                   @C5*/
  /*                 = SYSUT11  FOR COBOL 5 COMPILER WORK FILE    @C5*/
  /*                 = SYSUT12  FOR COBOL 5 COMPILER WORK FILE    @C5*/
  /*                 = SYSUT13  FOR COBOL 5 COMPILER WORK FILE    @C5*/
  /*                 = SYSUT14  FOR COBOL 5 COMPILER WORK FILE    @C5*/
  /*                 = SYSUT15  FOR COBOL 5 COMPILER WORK FILE    @C5*/
  /*                 = SYSMDECK FOR COBOL 5 COMPILER MDECK        @C5*/
  /*                 = SYSLIB   FOR COMPILER INCLUDES                */
  /*                 =          C/C++ COMPILER HEADERS          LI319*/
  /*                 = DSNHFBA  ATTRIBUTE FOR PRINT LIST             */
  /*                 = DSNHVBA  ATTRIBUTE FOR PRINT LIST             */
  /*    DATA SETS    =                                               */
  /*       REQUIRED  = MACIN DEFAULT IS NONE, NAME OF DATA           */
  /*                       SET FOR MACRO PASS INPUT.                 */
  /*                       NONE INDICATES THIS IS NOT MACRO.         */
  /*                 = OUTNAME.SUFF, OUTNAME DEFAULT IS TEMP         */
  /*                       SUFF IS ASM, PLI, COBOL, OR               */
  /*                       FORTRAN, DEPENDING ON HOST LANG.          */
  /*                       NAME OF SOURCE INPUT DATA SET             */
  /*                       FOR COMPILER. SHR                         */
  /*       OPTIONAL  = ASMLIB, SOURCE INCLUDE AND MACRO              */
  /*                       LIBRARY FOR HIGH LEVEL ASSEMBLER. SHR.    */
  /*                 = ASMLOAD, HIGH LEVEL ASSEMBLER PROGRAM LOAD    */
  /*                       MODULE NAME.            SHR.              */
  /*                 = CCLLIB, C PROGRAM LINKAGE EDITOR   (SYSLIB)   */
  /*                       LIBRARY FOR INCLUDES    SHR               */
  /*                 = CCLOAD, C COMPILER PROGRAM         (EXECUTE)  */
  /*                       LOAD MODULE NAME.       SHR.              */
  /*                 = CCMSGS, C/C++ COMPILER MESSAGES    (SYSMSGS)  */
  /*                 = CCPLIB, C PROGRAM LINKAGE EDITOR   (SYSLIB)   */
  /*                       LIBRARY FOR INCLUDES    SHR               */
  /*                 = CCSLIB, C COMPILER HEADERS   SHR.  (SYSLIB)   */
  /*                 = CICSCLIB, CICS COBOL SOURCE LIBRARY (SYSLIB)  */
  /*                       FOR INCLUDES, SHR.                        */
  /*                 = CICSPLIB, CICS PL/I SOURCE LIBRARY  (SYSLIB)  */
  /*                       FOR INCLUDES, SHR.                        */
  /*                 = CLIB, USER SPECIFIED NAME, COMPILER           */
  /*                       SOURCE LIBRARY FOR INCLUDES, SHR.         */
  /*                       SAME FOR C2LIB, C3LIB, C4LIB.             */
  /*                 = COBLOAD, VS COBOL COMPILER PROGRAM            */
  /*                       LOAD MODULE NAME.       SHR.              */
  /*                 = COB2LOAD, VS COBOL II COMPILER PROG           */
  /*                       LOAD MODULE NAME.       SHR.              */
  /*                 = CPPUTIL, C++ COMPILER REXX    (SYSPROC)  LI319*/
  /*                 = CPPCSLIB, C++ COMPILER HEADERS (SYSLIB)  LI319*/
  /*                       LOAD MODULE NAME.    SHR.            LI319*/
  /*                 = CPPSLIB, C++ COMPILER HEADER   (SYSLIB)  LI319*/
  /*                 = FORTLOAD, VS FORTRAN COMPILER PROGRAM         */
  /*                       LOAD MODULE NAME.       SHR.              */
  /*                 = OUTNAME.DECK, OUTPUT FROM COMPILER            */
  /*                       MACRO PASS AND INPUT TO                   */
  /*                       PRECOMPILER (PLI ONLY)                    */
  /*                 = OUTNAME.OBJ, OUTPUT FROM COMPILER,            */
  /*                       INPUT TO LINKAGE EDITOR. OLD/NEW          */
  /*                 = PLILOAD, PL/I OPTIMIZING COMPILER             */
  /*                       PROGRAM LOAD MODULE NAME. SHR.            */
  /*                 = PRINT.LIST, SYSPRINT OF COMPILERS.            */
  /*                       DEFAULT IS NONE (NO PRINT), MAY           */
  /*                       BE TERM (TERMINAL) OR                     */
  /*                       DATA SET NAME ABOVE, OLD/NEW              */
  /*                 = TERM.LIST, SYSTERM, ERROR, SUMMARY            */
  /*                       OF COMPILE.  DEFAULT IS TERM              */
  /*                       (TERMINAL OUTPUT), MAY ALSO BE            */
  /*                        LEAVE OR NONE.    OLD/NEW                */
  /* CHANGE ACTIVITY =                                               */
  /*  11/14/86 - TRUNCATED COMPILER OPTS                     @BA04697*/
  /*  11/18/86 - ADD &WORKU FOR TEMP DATASET @BA04731/KBF0038/KCF1141*/
  /*  11/11/87 - ADD C LANGUAGE SUPPORT                      R3TU157H*/
  /*  12/17/87 - ADD C LANGUAGE CMSGS PARM                    KCL2013*/
  /*  06/03/88 - MESSAGE DSNH751I ISSUED IN ERROR             KZF0921*/
  /*  10/25/88 - CHANGES TO C LANGUAGE SUPPORT                KZW0283*/
  /*  10/27/88 - SYSCPRT AND SYSOUT WALL MESSAGES AND DCBS    KZW0290*/
  /*  10/28/88 - OUTNAME..OBJ NOT ALLOCATED                   KZW0291*/
  /*  11/01/88 - SET SYSUT10 = SYSCPRT FOR C OPTION 'PPONLY'  KZW0295*/
  /*  03/10/89 - INCORRECT LRECL FOR COB2 SYSPRINT   KYF0316/@BA37636*/
  /*  12/13/89 - PLI(2.1) DOES NOT SUPPORT CS(60,EB) KYF0986/@BA53108*/
  /*             NNUM REMOVED, LET USER INSTALL DECIDE VALUE         */
  /*  07/06/90 - CHANGE SYSCPRT LRECL AND BLKSIZE    KYF1296/@BA62746*/
  /*  01/24/91 - UPDATE FORTLOAD TO V2R5 LEVEL          D6385/KYD0319*/
  /*  10/11/90 - SUPPORT CAF/APPC HLL                   LI239/TU2390A*/
  /*  03/05/91   REMOVE ATTACH KEYWORD, NOT EXTERNALIZED      KYL1174*/
  /*             UPDATE FORTLOAD TO V2R5 LEVEL                       */
  /*  05/11/93 - DOUBLE APOSTS W/IN COMPILER OPTIONS KEF0171  KDB2036*/
  /*  11/11/93 - MAKE COPTION PARAMETER OF SYSINDEX                  */
  /*             A STRING                         KEF0870/@39/PN46539*/
  /*  03/07/94 - REMOVE ASMH SUPPORT. MAKE ASM STAND FOR             */
  /*             HIGH LEVEL ASSEMBLER.                       TU2632HL*/
  /*  03/17/94 - DON'T SET SYSLIN, SYSUTN FOR HIGH LEVEL ASM KEW0154 */
  /*  06/28/94 - PUT CICS PL/I AND CICS COBOL LIBRARIES IN   KEW0324 */
  /*             COMPILER SYSLIB CONCATENATION                       */
  /*  07/07/95 - SUPPORT OOCOBOL=IBMCOB               TU3190TS/LI3190*/
  /*  10/30/95 - CHANGE CPPSLIB DEFAULT                      KFP0140 */
  /*  11/10/95 - SUPPORT C++=CPP                        KFW0112/LI319*/
  /*  12/05/95 - CLEANUP TO USE CXX REXX EXEC     KFD0022/D9031/LI319*/
  /*             DELETE: CPPLOAD, CPPMSGS, CPPCMSGS. ADD: CPPUTIL    */
  /*  10/22/96 - ADD RRSAF TO RUN TIME ENVIRONMENT           TU35332I*/
  /*  04/08/98 - INVALID CONTINUATION FOR SYSIN DD      D8751/PQ14738*/
  /*  06/26/98 - CICS 410 LOWEST LEVEL SUPPORT PROVIDED  DG136/F10178*/
  /*  09/21/98 - SET BLOCKSIZE FOR IBMCOB SYSPRINT  MARIONF    D12037*/
  /*  03/08/03 - FIX HANG CAUSED BY QUOTED COMPILER OPTS  PQ66361 @01*/
  /*  06/07/04 - FIX SUPPORT FOR ENTERPRISE PL/I          PQ88890 @03*/
  /*  10/16/13 - FIX SUPPORT FOR COBOL 5           PI13612 DM1812 @C5*/
  /*-----------------------------------------------------------------*/
  /* PSEUDOCODE      =                                               */
  /*       INITIALIZATION, CHECK KEYWORDS                            */
  /*       CHECK NAMES PASSED,                                       */
  /*       SET NAMES FOR LATER                                       */
  /*       PERFORM PARAMETER INITIALIZATION                          */
  /*       IF HOST IS ASSEMBLER THEN SET UP REQUIREMENTS             */
  /*       IF HOST IS ASSEMBLER H THEN SET UP REQUIREMENTS           */
  /*       IF HOST IS COBOL THEN SET UP REQUIREMENTS                 */
  /*       IF HOST IS VS COBOL II THEN SET UP REQUIREMENTS           */
  /*       IF HOST IS FORTRAN THEN SET UP REQUIREMENTS               */
  /*       IF HOST IS C THEN SET UP REQUIREMENTS                     */
  /*       IF HOST IS C++(CPP) THEN SET UP REQUIREMENTS         LI319*/
  /*       IF HOST IS OOCOBOL(IBMCOB) SET UP REQUIREMENTS       LI319*/
  /*       IF HOST IS PLI THEN SET UP REQUIREMENTS                   */
  /*       ALLOCATE DATA SETS FOR A COMPILE                          */
  /*       CALL THE COMPILER                                         */
  /*       FREE THE DATA SETS FROM COMPILE                           */
  /*******************************************************************/
  /* CLIST TO INVOKE COMPILERS FOR DB2 PROGRAM PREPARATION           */
  /*       INITIALIZATION, CHECK KEYWORDS                            */
  /*          SET THE CONTROL TRACING OPTIONS FOR THE CLIST          */
  SET &ERROR = 0                                /* FLAG FOR ERROR    */
  SET &M751 = &STR(DSNH751I DSNHC ERROR IN)     /* ERROR MSG TXT     */
  SET &M759 = &STR(DSNH759I DSNHC TERMINATING,) /* ERRMSG TXT        */
  /*          IF TRACE PARM IS NOT NONE                              */
  IF &SUBSTR(1,&CONTROL) ^= N THEN           /* NOT 'NONE' SO        */+
    DO                                       /* SET UP FOR TRACING   */
      IF &SUBSTR(1,&CONTROL) = L THEN        /* IS IT LIST?          */+
        CONTROL LIST                         /* TURN ON TRACING      */
      ELSE                                                             +
        DO                                   /* IS IT CONLIST?       */
          IF &SUBSTR(1,&CONTROL) = C THEN                              +
            CONTROL LIST CONLIST             /* TURN ON TRACING      */
          ELSE                                                         +
            DO                               /* IS IT SYMLIST?       */
              IF &SUBSTR(1,&CONTROL) = S THEN                          +
                CONTROL LIST CONLIST SYMLIST /* TURN ON TRACING      */
              ELSE                           /* NONE OF THE ABOVE    */+
                DO                           /* NOTE THE ERROR, MSG  */
                  SET &ERROR = 8             /* REMEMBER THE ERROR   */
                  WRITE &M751 CONTROL VALUE &CONTROL
                END
            END
        END
    END
  /*          CHECK SOURCE  KEYWORD                         */
  IF &SUBSTR(1,&SOURCE )= Y THEN /* IF SOURCE  IS YES THEN  */ +
    SET &SOURCE  = YES         /* BE SURE KEYWORD IS EXACT  */
  ELSE                         /* CHECK NO SOURCE           */ +
    IF &SUBSTR(1,&SOURCE )= N THEN /* IF SOURCE  IS NO  THEN*/ +
      SET &SOURCE  = NO        /* BE SURE KEYWORD IS EXACT  */
    ELSE                       /* THIS IS AN ERROR          */ +
      DO                       /* ISSUE THE ERROR MESSAGE   */
        SET &ERROR = 8         /* REMEMBER THE ERROR        */
        WRITE &M751 SOURCE VALUE &SOURCE
      END                      /* OF ERROR SETTING          */
  /*          CHECK XREF    KEYWORD                         */
  IF &SUBSTR(1,&XREF)= Y THEN  /* IF XREF IS YES THEN       */ +
    SET &XREF    = YES         /* BE SURE KEYWORD IS EXACT  */
  ELSE                         /* CHECK NO XREF             */ +
    IF &SUBSTR(1,&XREF   )= N THEN /* IF XREF    IS NO  THEN*/ +
      SET &XREF    = NO        /* BE SURE KEYWORD IS EXACT  */
    ELSE                       /* THIS IS AN ERROR          */ +
      DO                       /* ISSUE THE ERROR MESSAGE   */
        SET &ERROR = 8         /* REMEMBER THE ERROR        */
        WRITE &M751 XREF VALUE &XREF
      END                      /* OF ERROR SETTING          */
  /*          CHECK DELIMIT KEYWORD                         */
  IF &SUBSTR(1,&DELIMIT)= D THEN /* IF DELIMIT IS DEFAULT   */ +
    SET &DELIMIT = DEFAULT     /* BE SURE KEYWORD IS EXACT  */
  ELSE                         /* CHECK OTHER PASS'S        */ +
    IF &SUBSTR(1,&DELIMIT)= A THEN /* IF DELIMIT IS APOST   */ +
      SET &DELIMIT = APOST     /* BE SURE KEYWORD IS EXACT  */
    ELSE                       /* CHECK NO DELIMIT          */ +
      IF &SUBSTR(1,&DELIMIT)= Q THEN /* IF DELIMIT IS QUOTE */ +
        SET &DELIMIT = QUOTE   /* BE SURE KEYWORD IS EXACT  */
      ELSE                     /* THIS IS AN ERROR          */ +
        DO                     /* ISSUE THE ERROR MESSAGE   */
          SET &ERROR = 8       /* REMEMBER THE ERROR        */
          WRITE &M751 DELIMIT VALUE &DELIMIT
        END                    /* OF ERROR SETTING          */
  /*          CHECK SPACEUN KEYWORD                         */
  IF &SUBSTR(1,&SPACEUN)= T THEN /* IF SPACEUN IS TRACK     */ +
    SET &SPACEUN = TRACK       /* BE SURE KEYWORD IS EXACT  */
  ELSE                         /* CHECK NO SPACEUN          */ +
    IF &SUBSTR(1,&SPACEUN)= C THEN /* IF SPACEUN IS CYL     */ +
      SET &SPACEUN = CYL       /* BE SURE KEYWORD IS EXACT  */
    ELSE                       /* THIS IS AN ERROR          */ +
      DO                       /* ISSUE THE ERROR MESSAGE   */
        SET &ERROR = 8         /* REMEMBER THE ERROR        */
        WRITE &M751 SPACEUN VALUE &SPACEUN
      END                      /* OF ERROR SETTING          */
  /* CHECK HOST    KEYWORD                                  */
  IF &HOST = C THEN            /* IF HOST IS C LANGUAGE     */ +
      SET &HOST = C            /* NOP                       */
  ELSE                         /* CHECK OTHER HOSTS         */ +
    IF &HOST = COB2 THEN       /* IF VS COBOL II            */ +
      SET &HOST = COB2         /* NOP                       */
  ELSE                         /* CHECK OTHER HOSTS         */ +
    IF &HOST = COBO THEN       /* IF OS/VS COBOL            */ +
      SET &HOST = COBOL        /* BE SURE KEYWORD IS EXACT  */
  ELSE                         /* CHECK OTHER HOSTS         */ +
    IF &HOST = COBOL THEN      /* IF OS/VS COBOL            */ +
      SET &HOST = COBOL        /* NOP                       */
  ELSE                         /* CHECK OTHER HOSTS         */ +
    IF &LENGTH(&HOST) > 1 THEN /* AVOID SUBSTR ERRORS  LI319*/ +
      IF &SUBSTR(1:2,&STR(&HOST)) = CP THEN /* CPP ?   LI319*/ +
        DO                     /* PROCESS CPP          LI319*/
          /*------------------------------------------------*/
          /* INDICATE HOST LANGUAGE IS CPP             LI319*/
          /*------------------------------------------------*/
          SET &HOST = CPP      /* CPP PROGRAM COMPILER LI319*/
        END                    /* HOST COMPLETE        LI319*/
  ELSE                         /* CHECK OTHER HOSTS    LI319*/ +
    IF &SUBSTR(1,&STR(&HOST)) = I THEN /* IBMCOB ?     LI319*/ +
      DO                       /* PROCESS IBMCOB       LI319*/
        /*--------------------------------------------------*/
        /* INDICATE HOST LANGUAGE IS IBMCOB            LI319*/
        /*--------------------------------------------------*/
        SET &HOST = IBMCOB     /* IBMCOB COMPILER      LI319*/
      END                      /* PROCESSING COMPLETE  LI319*/
  ELSE                         /* CHECK OTHER HOSTS    LI319*/ +
    IF &SUBSTR(1,&HOST) = P THEN  /* IF HOST IS PLI         */ +
      SET &HOST = PLI          /* BE SURE KEYWORD IS EXACT  */
  ELSE                         /* CHECK ASM HOST            */ +
    IF &SUBSTR(1,&HOST)= A THEN/* IF HOST IS ASM            */ +
      SET &HOST = ASM          /* BE SURE KEYWORD IS EXACT  */
  ELSE                         /* CHECK FORTRAN HOST        */ +
    IF &SUBSTR(1,&HOST)= F THEN   /* IF HOST IS FORTRAN     */ +
      SET &HOST = FORTRAN      /* MAKE KEYWORD EXACT        */
  ELSE                         /* THIS IS AN ERROR          */ +
    DO                         /* ISSUE THE ERROR MESSAGE   */
      SET &ERROR = 8            /* REMEMBER THE ERROR       */
      WRITE &M751 HOST VALUE &HOST
    END                        /* OF ERROR SETTING          */
  SET &SUFF = &HOST            /* SET THE PROPER SUFFIX     */
  IF &HOST = COB2 THEN         /* IF HOST IS COB2           */ +
    SET &SUFF = COBOL          /* SET THE PROPER SUFFIX     */
  /*          CHECK COPTION KEYWORD                         */
  IF &NRSTR(&COPTION) = NONE THEN  /* IF COPTION IS NONE    */ +
    SET &COPTION =             /* REMOVE ALL TEXT           */
  /*          CHECK FLAG    KEYWORD                         */
  IF &FLAG ^= I AND            /* IF FLAG ISN'T INFORMATION */ +
     &FLAG ^= W AND            /* IF FLAG ISN'T WARNING     */ +
     &FLAG ^= E AND            /* IF FLAG ISN'T ERROR       */ +
     &FLAG ^= S THEN           /* IF FLAG ISN'T SEVERE      */ +
    DO                         /* ISSUE THE ERROR MESSAGE   */
      SET &ERROR = 8           /* REMEMBER THE ERROR        */
      WRITE &M751 FLAG VALUE &FLAG
    END                        /* OF ERROR SETTING          */
  SET &FLAGB = &FLAG           /* SET UP THE BIND FLAG      */
  IF &FLAG = S THEN            /* IF FLAG IS SEVERE         */ +
    SET &FLAGB = E             /* SET UP THE BIND FLAG      */
  /*          BE SURE OUTNAME HAS NO SPECIAL CHARACTERS     */
  SET &J = 1                   /* INIT THE INDEX            */
  DO WHILE &J LE &LENGTH(&STR(&OUTNAME)) /* LOOK AT INPUT   */ +
     AND &ERROR = 0            /* FIND AN ERROR             */
    IF &SUBSTR(&J,&OUTNAME) NE &STR(.) AND /* PERIOD IS OK  */ +
      &SUBSTR(&J,&OUTNAME) NE &STR($) AND /* DOLLAR IS OK   */ +
      &SUBSTR(&J,&OUTNAME) NE &STR(#) AND /* POUND IS OK    */ +
      &SUBSTR(&J,&OUTNAME) NE &STR(@) AND /* AT SIGN IS OK  */ +
      &SUBSTR(&J,&OUTNAME) < &STR(A) THEN /* OTHERWISE NOT  */ +
      DO                       /* YES, NOTE THE END         */
        SET &ERROR = 8         /* YES, NOTE THE ERROR       */
        SET &TEMP = &STR(MUST NOT CONTAIN SPECIAL CHARACTERS)
        WRITE DSNH754I DSNHC OUTNAME PARAMETER &OUTNAME &TEMP
      END                      /* YES, NOTE THE END         */
    SET &J = &J + 1            /* BUMP THE SUBSCRIPT        */
  END                          /* START  OF MEMBER IS SET   */
  /*          BE SURE PRINT   HAS NO SPECIAL CHARACTERS     */
  SET &J = 1                   /* INIT THE INDEX            */
  DO WHILE &J LE &LENGTH(&STR(&PRINT)) /* LOOK AT PRINT     */ +
     AND &ERROR = 0            /* FIND AN ERROR             */
    IF &SUBSTR(&J,&PRINT) NE &STR(.) AND /* PERIOD IS OK    */ +
      &SUBSTR(&J,&PRINT) NE &STR($) AND /* DOLLAR IS OK     */ +
      &SUBSTR(&J,&PRINT) NE &STR(#) AND /* POUND IS OK      */ +
      &SUBSTR(&J,&PRINT) NE &STR(@) AND /* AT SIGN IS OK    */ +
      &SUBSTR(&J,&PRINT) < &STR(A) THEN /* OTHERWISE NOT    */ +
      DO                       /* YES, NOTE THE END         */
        SET &ERROR = 8         /* YES, NOTE THE ERROR       */
        SET &TEMP = &STR(MUST NOT CONTAIN SPECIAL CHARACTERS)
        WRITE DSNH756I DSNHC PRINT PARAMETER &PRINT &TEMP
      END                      /* YES, NOTE THE END         */
    SET &J = &J + 1            /* BUMP THE SUBSCRIPT        */
  END                          /* LOOK AT PRINT NAME        */
  /*       SET NAMES FOR LATER                              */
    SET &WORKU =
    IF &WORKUNIT NE DEFAULT THEN /* NO A DEFAULT WORK SPACE */ +
       SET &WORKU = &STR(UNIT(&WORKUNIT)) /* SET UNIT PARM  */
  /* CHECK FOR PRIOR ERRORS, TERMINATE IF FOUND             */
  IF &ERROR GE  8      THEN    /* IF MAX RET CODE EXCEEDED  */ +
    DO                         /* ISSUE MESSAGE AND EXIT    */
      WRITE &M759 CLIST CHECKING RC = &ERROR
      EXIT CODE(&ERROR)        /* EXIT FROM CLIST           */
    END                        /* OF ERROR HANDLING         */
  /*       SET HOST LANGUAGE DEFAULTS, COMMON PROCESSING    */
  SET &SYSLIN = SYSLIN         /* SET SYSLIN DDNAME         */
  SET &SYSUTN = 1              /* NUMBER OF SYSUTN FILES    */
                               /* SET DEFAULT COMPILE PARMS */
  /**********************************************************/
  /* COMPILE OPTION: LINECOUNT                         LI319*/
  /**********************************************************/
  IF &HOST ^= C AND            /* NOT 'C' COMPILER AND LI319*/ +
     &HOST ^= CPP THEN         /* NOT 'C++' COMPILER   LI319*/ +
    SET &CPARM  = &STR(LINECOUNT(&LINECOUNT))
  /**********************************************************/
  /* COMPILE OPTION: OBJECT, NODECK                    LI319*/
  /* C++ LET COMPILER DEFAULT FOR OBJECT               LI319*/
  /**********************************************************/
  IF &MACIN  EQ NONE THEN      /* IF NO MACRO PASS INPUT    */ +
    DO                         /* SET COMPILER OPTIONS LI319*/
      IF &HOST ^= CPP THEN     /* NOT 'C++' COMPILER   LI319*/ +
        IF &CPARM = &STR() THEN /* NO CURRENT PARMS    LI319*/ +
          SET &CPARM = &STR(OBJECT,NODECK)
        ELSE                   /* ADD TO EXISTING      LI319*/ +
          SET &CPARM = &STR(&CPARM,OBJECT,NODECK)
    END                        /* OPTIONS COMPLETE     LI319*/
  ELSE                                                         +
    SET &CPARM = &STR(&CPARM,NOBJ,M,MD,NSYN)
  /**********************************************************/
  /* COMPILE OPTION:  TERM/NOTERM                      LI319*/
  /**********************************************************/
  IF &HOST ^= CPP THEN         /* IF HOST NOT C++      LI319*/ +
    DO                         /* PROCESS TERM         LI319*/
      IF &TERM NE NONE THEN    /* IF TERMINAL MSG REQUESTED */ +
        SET &CPARM = &STR(&CPARM,TERM) /* ADD TERM     LI319*/
      ELSE SET &CPARM = &STR(&CPARM,NOTERM) /* ADD     LI319*/
    END                        /* TERM COMPLETE        LI319*/
  /**********************************************************/
  /* IF HOST IS ASSEMBLER THEN GET READY                    */
  /**********************************************************/
  IF &HOST = ASM THEN          /* HOST IS ASSEMBLER         */ +
    DO                         /* SET ASSEMBLER XF OPTIONS  */
  /*  SET &SYSLIN = SYSGO DELETE THIS LINE          KEW0154 */
      SET &COMP   = &STR(&ASMLOAD) /* PGM                   */
  /*  SET &SYSUTN = 3     DELETE THIS LINE          KEW0154 */
      IF &XREF   = YES THEN    /* IF XREF WAS REQUESTED     */ +
        SET &CPARM = &STR(&CPARM,XREF) /* ADD TO COMPILE    */
      ELSE SET &CPARM = &STR(&CPARM,NOXREF) /* ADD PARM     */
    END                        /* OF ASSEMBLER REQUIREMENTS */
  /**********************************************************/
  /* IF HOST IS COBOL THEN SET COBOL REQUIREMENTS           */
  /**********************************************************/
  IF &HOST = COBOL THEN    /* HOST IS COBOL                 */ +
    DO       /* SET UP PARMS FOR COBOL PROGRAM AND          */
      SET &CPARM  = &STR(CNT(&LINECOUNT)) /* BEGIN PARM     */
      IF &XREF   = YES THEN    /* IF XREF WAS REQUESTED     */ +
        SET &CPARM = &STR(&CPARM,SXR) /* ADD TO COMPILE     */
      ELSE SET &CPARM = &STR(&CPARM,NOSXR) /* ADD PARM      */
      SET &CFLAG = LAGW       /* PRESET THE FLAG            */
      IF &FLAG = E OR &FLAG = S THEN /* EQUIV TO FLAGE      */ +
        SET &CFLAG = LAG /* ERRORS NOTED ONLY               */
      ELSE SET &CFLAG = LAGW /* NOTE WARNINGS AS WELL       */
      IF &DELIMIT EQ DEFAULT THEN /* DELIMIT IS DEFAULT     */ +
        SET &DELIMIT = QUO /* SET TO CLIST DEFAULT          */
      ELSE IF &DELIMIT EQ APOST THEN /* DELIMIT IS APOST    */ +
          SET &DELIMIT = APO      /* SET TO APOST           */
        ELSE SET &DELIMIT = QUO   /* SET TO QUOTE           */
      SET &CPARM = &STR(&CPARM,&CFLAG,&DELIMIT,LOA,+
          BUF(64000),SIZ(256000))  /* ALL COMPILE PARMS     */
      SET &COMP   = &STR(&COBLOAD) /* PGM NAME              */
      SET &SYSUTN = 4          /* SET NUMBER OF WORK FILES  */
      IF &SOURCE  = YES THEN       /* IF SOURCE REQUEST     */ +
        SET &CPARM = &STR(&CPARM,SOU)   /* ADD TO COMPILE   */
      ELSE SET &CPARM = &STR(&CPARM,NOSOU)   /* ADD PARM    */
      IF &TERM    = YES THEN       /* IF TERM REQUEST       */ +
        SET &CPARM = &STR(&CPARM,TER)      /* ADD TO COMP   */
      ELSE SET &CPARM = &STR(&CPARM,NOTER)  /* ADD PARM     */
    END                        /* COBOL PARMS ARE SET       */
  /**********************************************************/
  /* IF HOST IS VS COBOL II THEN SET COBOL II REQUIREMENTS  */
  /**********************************************************/
  IF &HOST = COB2 THEN     /* HOST IS VS COBOL II           */ +
    DO                     /* VS COBOL II DIFFERENCES       */
      SET &CPARM  = &STR(LC(&LINECOUNT))     /* PARM        */
      IF &XREF   = YES THEN     /* IF XREF WAS REQUESTED    */ +
        SET &CPARM = &STR(&CPARM,X)     /* ADD TO COMPILE   */
      ELSE SET &CPARM = &STR(&CPARM,NOX)     /* ADD PARM    */
      IF &DELIMIT EQ DEFAULT THEN     /* DELIM IS DEFAULT   */ +
        SET &DELIMIT = Q       /* SET TO CLIST DEFAULT      */
      ELSE IF &DELIMIT EQ APOST THEN     /* DEL IS APOST    */ +
          SET &DELIMIT = APOST     /* SET TO APOST          */
        ELSE SET &DELIMIT = Q      /* SET TO QUOTE          */
      SET &CPARM = &STR(&CPARM,F(&FLAG),&DELIMIT,+
          OBJ,NOD)             /* ALL COMPILE PARMS         */
      SET &COMP   = &STR(&COB2LOAD)     /* PGM NAME         */
      SET &SYSUTN = 7        /* SET NUMBER OF WORK FILES    */
                 /*  TEST FOR SOURCE AND TERM OPTIONS       */
      IF &SOURCE  = YES THEN       /* IF SOURCE REQUEST     */ +
        SET &CPARM = &STR(&CPARM,S)     /* ADD TO COMPILE   */
      ELSE SET &CPARM = &STR(&CPARM,NOS)     /* ADD PARM    */
      IF &TERM    = YES THEN       /* IF TERM REQUEST       */ +
        SET &CPARM = &STR(&CPARM,TERM)     /* ADD TO COMP   */
      ELSE SET &CPARM = &STR(&CPARM,NOTERM)  /* ADD PARM    */
    END                    /* VS COBOL II DIFFERENCES       */
          /* ALL COBOL COMPILER PARMS ARE SETUP             */
  /**********************************************************/
  /* IF HOST IS FORTRAN THEN SET FORTRAN REQUIREMENTS       */
  /**********************************************************/
  IF &HOST = FORTRAN THEN      /* HOST IS FORTRAN           */ +
    DO                         /* SET VS FORTRAN OPTIONS    */
      SET &COMP = &STR(&FORTLOAD) /* PGM NAME               */
      IF &XREF  = YES THEN     /* IF XREF WAS REQUESTED     */ +
        SET &CPARM = &STR(&CPARM,X) /* ADD TO COMPILE       */
      ELSE SET &CPARM = &STR(&CPARM,NOX)    /* ADD PARM     */
      IF &SOURCE = YES THEN    /* IF SOURCE WAS REQUESTED   */ +
        SET &CPARM = &STR(&CPARM,S)    /* ADD TO COMPILE    */
      ELSE SET &CPARM = &STR(&CPARM,NOS NOSF)      /*       */
      SET &SYSUTN = 0          /* SET NUMBER OF WORK FILES  */
    END                        /* OF VS FORTRAN  OPTIONS    */
  /**********************************************************/
  /* IF HOST IS C THEN SET C REQUIREMENTS                   */
  /**********************************************************/
  IF &HOST = C THEN               /* IF HOST IS C THEN      */ +
    DO                            /* SET C OPTIONS          */
      SET &COMP   = &STR(&CCLOAD) /* C COMPILER LOAD MODULE */
      SET &SYSUTN = 9             /* NUMBER OF WORK FILES   */
      SET &CPARM =                /* RESET TO NULL STRING   */
      IF &SOURCE = YES THEN       /* SOURCE REQUESTED       */ +
        IF &CPARM =               /* NO CURRENT PARMS       */ +
          THEN SET &CPARM = &STR(SO)  /* SET TO SOURCE      */
          ELSE SET &CPARM = &STR(&CPARM,SO) /* ADD SOURCE   */
      ELSE                        /* SOURCE NOT REQUESTED   */ +
        IF &CPARM =               /* NO CURRENT PARMS       */ +
          THEN SET &CPARM = &STR(NOSO) /* SET TO NOSOURCE   */
          ELSE SET &CPARM = &STR(&CPARM,NOSO) /*ADD NOSOURCE*/
      IF &XREF = YES THEN         /* XREF REQUESTED         */ +
        IF &CPARM =               /* NO CURRENT PARMS       */ +
          THEN SET &CPARM = &STR(XR)  /* SET TO XREF        */
          ELSE SET &CPARM = &STR(&CPARM,XR) /* ADD XREF     */
      ELSE                        /* XREF NOT REQUESTED     */ +
        IF &CPARM =               /* NO CURRENT PARMS       */ +
          THEN SET &CPARM = &STR(NOXR) /* SET TO NOXREF     */
          ELSE SET &CPARM = &STR(&CPARM,NOXR) /* ADD NOXREF */
      IF &TERM EQ NONE THEN       /* NOTERM REQUESTED, AND  */ +
        IF &CPARM =               /* NO CURRENT PARMS       */ +
          THEN SET &CPARM = &STR(NOTERM) /* SET NOTERM      */
          ELSE SET &CPARM = &STR(&CPARM,NOTERM) /*ADD NOTERM*/
      ELSE                        /* TERM REQUESTED         */ +
        IF &CPARM =               /* NO CURRENT PARMS       */ +
          THEN SET &CPARM = &STR(TERM) /* SET TO TERM       */
          ELSE SET &CPARM = &STR(&CPARM,TERM) /* ADD TERM   */
      ALLOCATE DDNAME(SYSMSGS) SHR REUSE +
               DSNAME(&CCMSGS)    /* COMPILER'S MSG LIBRARY */
      /*----------------------------------------------------*/
      /* ALLOCATE SYSCPRT                                   */
      /*----------------------------------------------------*/
      IF &PRINT NE NONE AND        /* IF PRINT REQUESTED    */ +
         &PRINT NE LEAVE THEN      /* AND NOT DATE SET      */ +
        DO                         /* ALLOCATE DATA SET     */
          IF &PRINT = TERM THEN    /* IF TERM SPECIFIED     */ +
            DO                     /* ALLOCATE TO TERMINAL  */
              /*--------------------------------------------*/
              /* ALLOCATE SYSCPRT AND SYSUT10 TO TERMINAL   */
              /*--------------------------------------------*/
              ALLOCATE DDNAME(SYSCPRT) DA(*) /* TERM ALLOC  */
              ALLOCATE DDNAME(SYSUT10) DA(*) /* TERM ALLOC  */
            END                    /* ALLOCATION COMPLETE   */
          ELSE                     /* ALLOCATE A DATA SET   */ +
            DO                     /* DELETE, THEN ALLOC    */
              /*--------------------------------------------*/
              /* ALLOCATE SYSCPRT AND SYSUT10 TO SAME       */
              /* SYSCPRT.LIST DATA SET                      */
              /*--------------------------------------------*/
              IF &CONTROL = NONE THEN /* IF NO MSGS WANTED  */ +
                CONTROL NOMSG      /* SUPPRESS MESSAGES     */
              DELETE &PRINT..SYSCPRT.LIST /* DELETE DATA SET*/
              FREE DDNAME(SYSCPRT) /* BE SURE DDNAME FREE   */
              FREE DDNAME(SYSUT10) /* BE SURE DDNAME FREE   */
              FREE ATTR(DSNHVBA)   /* FREE ATTRIBUTE        */
              CONTROL MSG          /* ALLOW MESSAGES        */
              /*--------------------------------------------*/
              /* ALLOCATE SYSCPRT DATA SET TO SYSCPRT.LIST  */
              /*--------------------------------------------*/
              ATTR DSNHVBA RECFM(V B A) LRECL(137) +
                BLKSIZE(4110)
              ALLOCATE DDNAME(SYSCPRT) +
                DSNAME(&PRINT..SYSCPRT.LIST) +
                NEW SPACE(&PSPACE &PSECSPAC) &SPACEUN &WORKU +
                USING(DSNHVBA)
              FREE ATTR(DSNHVBA)   /* FREE ATTRIBUTE        */
              /*--------------------------------------------*/
              /* ALLOCATE SYSUT10 DATA SET TO SYSCPRT.LIST  */
              /*--------------------------------------------*/
              ALLOCATE DDNAME(SYSUT10) +
                DSNAME(&PRINT..SYSCPRT.LIST)
            END                    /* DELETE, THEN ALLOC    */
        END                        /* ALLOCATE COMPLETE     */
      IF &PRINT EQ NONE THEN       /* IF BYPASS PRINT THEN  */ +
        DO                         /* ALLOCATE TO DUMMY     */
          /*------------------------------------------------*/
          /* ALLOCATE SYSCPRT AND SYSUT10 TO DUMMY          */
          /*------------------------------------------------*/
          ALLOCATE DDNAME(SYSCPRT) DUMMY /* ALLOCATE DUMMY  */
          ALLOCATE DDNAME(SYSUT10) DUMMY /* ALLOCATE DUMMY  */
        END                        /* ALLOCATION COMPLETE   */
    END                           /* C OPTIONS COMPLETE     */
  ELSE                                                         +
  /**********************************************************/
  /* IF HOST IS CPP THEN SET C++ REQUIREMENTS          LI319*/
  /**********************************************************/
  IF &HOST = CPP THEN             /* IF HOST IS C++    LI319*/ +
    DO                            /* SET IBM OPTIONS   LI319*/
      SET &COMP = &STR(&CPPUTIL)  /* REXX(CXX)         LI319*/
      SET &SYSUTN = 0             /* NO WORK FILES     LI319*/
      /*----------------------------------------------------*/
      /* PARM: XREF/NOXREF                             LI319*/
      /*----------------------------------------------------*/
      IF &XREF = YES THEN         /* XREF REQUESTED    LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(XREF)  /* SET XREF    LI319*/
          ELSE SET &CPARM = &STR(&CPARM,XREF) /* ADD   LI319*/
      ELSE                        /* NOT REQUESTED     LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(NOXREF) /* NOXREF     LI319*/
          ELSE SET &CPARM = &STR(&CPARM,NOXREF) /* ADD LI319*/
      /*------------------------------------------------------
      /* TRANSLATE DSNH SOURCE (&SOURCE) OPTION INTO   LI319*/
      /*           CXX  SOURCE OPTION                  LI319*/
      /* PARM: SOURCE/NOSOURCE                         LI319*/
      /*----------------------------------------------------*/
      IF &SOURCE = YES THEN       /* SOURCE REQUESTED  LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(SOURCE) /* SET SOURCE LI319*/
          ELSE SET &CPARM = &STR(&CPARM,SOURCE) /* ADD LI319*/
      ELSE                        /* NOT REQUESTED     LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(NOSOURCE) /* NOSOURCE LI319*/
          ELSE SET &CPARM = &STR(&CPARM,NOSOURCE)/*ADD LI319*/
      /*----------------------------------------------------*/
      /* TRANSLATE DSNH TERM (&TERM) OPTION INTO       LI319*/
      /*           CXX  TERM OPTION                    LI319*/
      /* PARM: TERMINAL, NOTERMINAL                    LI319*/
      /*----------------------------------------------------*/
      SET &TRM = &STR()        /* INITIALIZE TERM      LI319*/
      IF &TERM = TERM THEN     /* TERM SPECIFIED ?     LI319*/ +
        SET &TRM = &STR(TERMINAL) /* TERM TO TERM      LI319*/
      ELSE                     /* CONTINUE CHECK       LI319*/ +
        SET &TRM = &STR(NOTERMINAL) /* NOTERM          LI319*/
      IF &CPARM =               /* NO CURRENT PARMS    LI319*/ +
        THEN SET &CPARM = &STR(&TRM)  /* SET LIST      LI319*/
        ELSE SET &CPARM = &STR(&CPARM,&TRM) /* ADD     LI319*/
      /*----------------------------------------------------*/
      /* DSNH PRINT (&PRINT) OPTION NOT TRANSLATED     LI319*/
      /*----------------------------------------------------*/
    END                        /* OPTIONS COMPLETE     LI319*/
  ELSE                                                         +
  /**********************************************************/
  /* IF HOST IS IBMCOB THEN SET OOCOBOL REQUIREMENTS   LI319*/
  /**********************************************************/
  IF &HOST = IBMCOB THEN          /* IF HOST IBMCOB    LI319*/ +
    DO                            /* SET CPP OPTIONS   LI319*/
      SET &COMP   = &STR(&COBICOMP) /* LOAD MODULE     LI319*/
      SET &SYSUTN = 15            /* NUMBER WORK FILES   @C5*/
      /*------------------------------------------------------
      /* SETUP PARAMETERS FOR COMPILER                 LI319*/
      /* PARM: SOURCE/NOSOURCE                         LI319*/
      /*----------------------------------------------------*/
      IF &SOURCE = YES THEN       /* SOURCE REQUESTED  LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(SOURCE) /* SET SOURCE LI319*/
          ELSE SET &CPARM = &STR(&CPARM,SOURCE) /* ADD LI319*/
      ELSE                        /* NOT REQUESTED     LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(NOSOURCE) /* NOSOURCE LI319*/
          ELSE SET &CPARM = &STR(&CPARM,NOSOURCE)/*ADD LI319*/
      /*----------------------------------------------------*/
      /* PARM: XREF/NOXREF                             LI319*/
      /*----------------------------------------------------*/
      IF &XREF = YES THEN         /* XREF REQUESTED    LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(XREF)  /* SET XREF    LI319*/
          ELSE SET &CPARM = &STR(&CPARM,XREF) /* ADD   LI319*/
      ELSE                        /* NOT REQUESTED     LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(NOXREF) /* NOXREF     LI319*/
          ELSE SET &CPARM = &STR(&CPARM,NOXREF) /* ADD LI319*/
      /*----------------------------------------------------*/
      /* PARM: TERM/NOTERM                             LI319*/
      /*----------------------------------------------------*/
      IF &TERM EQ NONE THEN       /* NOTERM REQUESTED  LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(NOTERM) /* SET NOTERM LI319*/
          ELSE SET &CPARM = &STR(&CPARM,NOTERM) /*ADD  LI319*/
      ELSE                        /* TERM REQUESTED    LI319*/ +
        IF &CPARM =               /* NO CURRENT PARMS  LI319*/ +
          THEN SET &CPARM = &STR(TERM) /* SET TO TERM  LI319*/
          ELSE SET &CPARM = &STR(&CPARM,TERM) /* ADD   LI319*/
    END                           /* OPTIONS COMPLETE  LI319*/
  ELSE                                                         +
  /**********************************************************/
  /* IF HOST IS PLI THEN SET PLI REQUIREMENTS               */
  /**********************************************************/
  IF &HOST = PLI THEN          /* HOST IS PLI THEN          */ +
    DO                         /* SET PLI OPTIONS           */
      SET &COMP   = &STR(&PLILOAD) /* PGM NAME              */
      SET &CPARM  = &STR(LC(&LINECOUNT))  /* LINECOUNT      */
      IF &MACIN  EQ NONE THEN  /* IF NO MACRO PASS INPUT    */ +
        SET &CPARM = &STR(&CPARM,OBJ,ND) /* ADD OPTIONS     */
      ELSE SET &CPARM = &STR(&CPARM,NOBJ,M,MD,NSYN) /*      */
      IF &TERM NE NONE THEN  /* IF TERMINAL MSG REQUESTED   */ +
        SET &CPARM = &STR(&CPARM,TERM) /* ADD TO COMPILE    */
      ELSE SET &CPARM = &STR(&CPARM,NTERM)  /* ADD PARM     */
      IF &XREF   = YES THEN    /* IF XREF WAS REQUESTED     */ +
        SET &CPARM = &STR(&CPARM,X)  /* ADD TO COMPILE      */
      ELSE SET &CPARM = &STR(&CPARM,NX)   /* ADD PARM       */
      IF &SOURCE = YES THEN    /* IF SOURCE WAS REQUESTED   */ +
        SET &CPARM = &STR(&CPARM,S)    /* ADD TO COMPILE    */
      ELSE SET &CPARM = &STR(&CPARM,NS)     /* ADD PARM     */
  /**********************************************************/
  /* IF HOST LANGUAGE IS PLI AND MACRO PHASE NEEDED THEN    */
  /* ALLOCATE SYSPUNCH                                      */
  /**********************************************************/
      IF  &MACIN NE NONE  THEN /* MACRO PASS REQUESTED      */ +
        DO                     /* INVOKE PLI PREPROCESSOR   */
          IF &CONTROL = NONE THEN /* IF NO MSGS WANTED THEN */ +
            CONTROL NOMSG      /* AVOID DELETE MESSAGES     */
          FREE DDNAME(SYSPUNCH) /* BE SURE DDNAME IS FREE   */
          DELETE &OUTNAME..DECK /* DELETE PLI OUTPUT DATA   */
          CONTROL MSG          /* ALLOW MESSAGES AGAIN      */
          ALLOCATE DD(SYSPUNCH) NEW BLKSIZE(3200) REUSE        +
                   &SPACEUN SPACE(&WSPACE,&WSECSPAC) &WORKU    +
                   DSNAME(&OUTNAME..DECK) /* SYSPUNCH OUTPUT*/
        END                    /* OF PLI PREPROCESS INVOCATN*/
    END                        /* SET PLI OPTIONS           */
  /**********************************************************/
  /* ALLOCATE DATA SETS FOR A COMPILE                       */
  /**********************************************************/
  /* ALLOCATE SYSIN                                         */
  /**********************************************************/
  IF &MACIN EQ NONE THEN       /* IF NOT A MACRO PASS       */ +
    DO                         /* ALLOCATE SYSIN       LI319*/
      /*----------------------------------------------------*/
      /* C++: SET &CPPSIN TO SYSIN                          */
      /*----------------------------------------------------*/
      IF &HOST = CPP THEN      /* IF HOST IS C++       LI319*/ +
        SET &CPPSIN = &NRSTR(&OUTNAME..&SUFF) /*CPPSIN LI319*/
      ALLOCATE DDNAME(SYSIN) SHR REUSE                         +
        DSNAME(&OUTNAME..&SUFF) /* SYSIN FOR COMPILE        */
    END                        /* SYSIN COMPLETE     PQ14738*/
  ELSE                         /* THIS IS A MACRO PASS      */ +
     ALLOCATE DDNAME(SYSIN) SHR REUSE                          +
           DSNAME(&MACIN)      /* SYSIN FOR MACRO PASS      */
  /**********************************************************/
  /* ALLOCATE THE SYSLIB IF REQUESTED                       */
  /**********************************************************/
  SET &CONL =
  IF &CLIB  NE NONE THEN SET &CONL = &STR(&CLIB)
  IF &C2LIB NE NONE THEN SET &CONL = &STR(&CONL &C2LIB)
  IF &C3LIB NE NONE THEN SET &CONL = &STR(&CONL &C3LIB)
  IF &C4LIB NE NONE THEN SET &CONL = &STR(&CONL &C4LIB)
  IF &HOST EQ ASM THEN         /* IF THIS IS ASM            */ +
     SET &CONL = &STR(&CONL &ASMLIB) /* SET THE DEFAULT LIB */
  IF &HOST EQ C THEN           /* IF THIS IS 'C' LANGUAGE   */ +
     SET &CONL = &STR(&CONL &CCSLIB) /* SET THE DEFAULT LIB */
  IF &HOST EQ CPP THEN         /* 'C++' LANGUAGE ?     LI319*/ +
    DO                         /* SETUP SYSLIB         LI319*/
     SET &CONL = &STR(&CONL &CPPSLIB) /* ADD HEADER    LI319*/
     SET &CONL = &STR(&CONL &CPPCSLIB) /* ADD HEADER   LI319*/
    END                        /* SETUP COMPLETE       LI319*/
  IF &ATTACH = CICS THEN                           /*KEW0324*/+
   DO                                              /*KEW0324*/
    IF &HOST EQ COBOL AND &CICSCLIB NE NONE THEN   /*KEW0324*/ +
     SET &CONL = &STR(&CONL &CICSCLIB) /* COB CICS   KEW0324*/
    IF &HOST EQ PLI   AND &CICSPLIB NE NONE THEN   /*KEW0324*/ +
     SET &CONL = &STR(&CONL &CICSPLIB) /* PLI CICS   KEW0324*/
   END                                             /*KEW0324*/
  IF &CONL NE      THEN      /* IF ALLOCATION REQUESTED   */ +
    ALLOCATE DDNAME(SYSLIB) DSNAME(&CONL) SHR REUSE
  /**********************************************************/
  /* ALLOCATE SYSPRINT AND SYSTERM IF REQUESTED        LI319*/
  /* FREE SYSPRINT AND SYSTERM                         LI319*/
  /**********************************************************/
  IF &HOST ^= CPP THEN         /* IF HOST NOT C++      LI319*/ +
    DO                         /* PROCESS SYSPRINT     LI319*/
      IF &CONTROL = NONE THEN  /* IF NO MSGS WANTED THEN    */ +
        CONTROL NOMSG          /* AVOID FREE MESSAGES       */
      IF &PRINT NE LEAVE THEN  /* IF ALLOCATION REQUESTED   */ +
        FREE DDNAME(SYSPRINT)  /* FREE THE DDNAME           */
      IF &TERM  NE LEAVE THEN  /* IF ALLOCATION REQUESTED   */ +
        FREE DDNAME(SYSTERM)   /* FREE THE DDNAME           */
      CONTROL MSG              /* ALLOW MESSAGES AGAIN      */
      IF &PRINT NE NONE AND    /* IF ALLOCATION REQUESTED   */ +
         &PRINT NE LEAVE THEN  /* IF ALLOCATION REQUESTED   */ +
        DO                     /* ALLOCATE DATA SET (OLD)   */
          IF &PRINT = TERM THEN  /* IF TERM OUTPUT RQSTD    */ +
            ALLOCATE DDNAME(SYSPRINT) DA(*) /* DO TERM ALLOC*/
          ELSE                 /* ALLOCATE A DATA SET       */ +
            DO                 /* DELETE, THEN ALLOC DATA   */
              /**********************************************/
              /* DSNAME: ALLOCATE SYSPRINT TO TEMP     LI319*/
              /* DATA SET &PRINT..LIST                 LI319*/
              /**********************************************/
              IF &CONTROL = NONE THEN /* IF NO MSGS WANTED  */ +
                CONTROL NOMSG      /* AVOID DELETE MESSAGES */
              DELETE &PRINT..LIST  /* DELETE OUTPUT DATA SET*/
              FREE DDNAME(SYSPRINT)/* BE SURE DDNAME IS FREE*/
              FREE ATTR(DSNHFBA)   /* FREE ATTRIBUTE        */
              CONTROL MSG          /* ALLOW MESSAGES AGAIN  */
              IF &HOST = COB2 OR                /* @BA37636 */ +
                 &HOST = IBMCOB THEN    /* LI319, D12037    */ +
                DO   /* DIF LRECL AND BLKSIZE       @BA37636*/
                  ATTR DSNHFBA RECFM(F B A) LRECL(133) BLKSIZE(3990)
                  ALLOCATE DDNAME(SYSPRINT)                    +
                    DSNAME(&PRINT..LIST) NEW                   +
                    SPACE(&PSPACE &PSECSPAC)                   +
                    &SPACEUN USING(DSNHFBA)                    +
                    &WORKU         /*               @BA04731*/
                  FREE ATTR(DSNHFBA) /* FREE ATTRIBUTE      */
                END            /*                   @BA37636*/
              ELSE             /* TEST FOR IBMCOB      LI319*/ +
                DO             /*                   @BA37636*/
                  ATTR DSNHFBA RECFM(F B A) LRECL(121) BLKSIZE(3630)
                  ALLOCATE DDNAME(SYSPRINT)                    +
                    DSNAME(&PRINT..LIST) NEW                   +
                    SPACE(&PSPACE &PSECSPAC)                   +
                    &SPACEUN   USING(DSNHFBA)                  +
                    &WORKU     /*                   @BA04731*/
                  FREE ATTR(DSNHFBA) /* FREE ATTRIBUTE      */
                END            /* ALLOCATE COMPLERE @BA37636*/
            END                /* DELETE, THEN ALLOC DATA   */
        END                    /* SYSPRINT IS ALLOCATED     */
      IF &PRINT EQ NONE THEN   /* IF NO SYSPRINT            */ +
         ALLOCATE DDNAME(SYSPRINT) DUMMY /* ALLOCATE        */
      /******************************************************/
      /* ALLOCATE SYSTERM IF REQUESTED                      */
      /******************************************************/
      IF &TERM NE NONE AND     /* IF ALLOCATION REQUESTED   */ +
        &TERM NE LEAVE THEN    /* IF ALLOCATION REQUESTED   */ +
        DO                     /* ALLOCATE A DATA SET (OLD) */
          IF &TERM = TERM THEN /* IF TERMINAL OUTPUT REQSTD */ +
            ALLOCATE DDNAME(SYSTERM) DA(*) /* DO TERM ALLOC */
          ELSE                 /* ALLOCATE A DATA SET       */ +
            DO                 /* DELETE, THEN ALLOC DATA   */
              /**********************************************/
              /* DSNAME: ALLOCATE SYSTERM TO TEMPORARY LI319*/
              /* DATA SET &TERM..LIST                  LI319*/
              /**********************************************/
              IF &CONTROL = NONE THEN /* IF NO MSGS WANTED  */ +
                CONTROL NOMSG  /* AVOID DELETE MESSAGES     */
              DELETE &TERM..LIST /* DELETE OUTPUT DATA SET  */
              FREE DDNAME(SYSTERM) /* BE SURE DDNAME FREE   */
              CONTROL MSG      /* ALLOW MESSAGES AGAIN      */
              ALLOCATE DDNAME(SYSTERM) DSNAME(&TERM..LIST)     +
                SPACE(&PSPACE &PSECSPAC) &SPACEUN NEW &WORKU
            END                /* DELETE, THEN ALLOC DATA   */
        END                    /* SYSTERM IS ALLOCATED      */
      IF &TERM  EQ NONE THEN   /* IF NO SYSTERM             */ +
        ALLOCATE DDNAME(SYSTERM) DUMMY /* ALLOCATE          */
    END                        /* SYSPRINT COMPLETE    LI319*/
  /**********************************************************/
  /* ALLOCATE SYSUTN FILES                                  */
  /**********************************************************/
  IF &SYSUTN > 0 THEN          /* NEED WORK FILES ?    LI319*/ +
    DO                         /* ALLOCATE WORK FILES  LI319*/
      SET &WORK = 1            /* INITIALIZE WORK FILE COUNT*/
      DO WHILE &WORK LE &SYSUTN /* DO FOR EACH WORK FILE    */
        ALLOCATE DD(SYSUT&WORK) NEW &WORKU &SPACEUN REUSE      +
                 SPACE(&WSPACE,&WSECSPAC) /* ALLOC FILES    */
        SET &WORK = &WORK + 1  /* INCREMENT WORK FILE COUNT */
      END                      /* ALLOCATE WORK FILES       */
    END                        /* ALLOCATE COMPLETE    LI319*/
  IF &HOST = C THEN            /* HOST IS 'C' COMPILER LI319*/ +
    DO                         /* ADDITIONAL SYSUTNS   LI319*/
      /*----------------------------------------------------*/
      /* ALLOCATE SYSUT14 (C)                          LI319*/
      /*----------------------------------------------------*/
      FREE DDNAME(SYSUT14)     /* BE SURE FREE         LI319*/
      ALLOCATE DD(SYSUT14) NEW &WORKU &SPACEUN REUSE           +
             SPACE(&WSPACE,&WSECSPAC) /* SYSUT14       LI319*/
    END                        /* ALLOCATE COMPLETE    LI319*/
  /* ALLOCATE SYSMDECK (COBOL 5)                         @C5*/
  /**********************************************************/
  IF &HOST = IBMCOB THEN       /* IF HOST IBMCOB         @C5*/ +
    DO                         /* PROCESS SYSMDECK       @C5*/
      ALLOCATE DD(SYSMDECK) NEW &WORKU &SPACEUN REUSE +
             SPACE(&WSPACE,&WSECSPAC) /* SYSMDECK        @C5*/
    END                        /* ALLOCATE COMPLETE      @C5*/
  /**********************************************************/
  /* ALLOCATE SYSLIN OR SYSGO                               */
  /**********************************************************/
  IF &HOST ^= CPP THEN         /* NOT 'C++' COMPILER   LI319*/ +
    DO                         /* PROCESS SYSLIN            */
      /*----------------------------------------------------*/
      /* SYSLIN: &OUTNAME..OBJ                         LI319*/
      /*----------------------------------------------------*/
      IF &CONTROL = NONE THEN  /* IF NO MSGS WANTED THEN    */ +
        CONTROL NOMSG          /* AVOID FREE MESSAGES       */
      DELETE (&OUTNAME..OBJ)   /* DELETE OUTPUT DATA SET    */
      FREE DDNAME(&SYSLIN)     /* AND FREE THE FILE         */
      CONTROL MSG              /* ALLOW MESSAGES AGAIN      */
      IF &HOST = C             /* 'C' COMPILER         LI319*/ +
       OR &HOST = IBMCOB       /* OR IBM COBOL COMPILER  @C5*/ +
       OR &HOST = PLI THEN     /* OR PLI COMPILER        @03*/ +
        DO                     /* ALLOCATE SYSLIN      LI319*/
          ALLOCATE DD(&SYSLIN) NEW &WORKU REUSE                +
                   RECFM(F B) LRECL(80) BLKSIZE(3200)          +
                   &SPACEUN SPACE(&WSPACE,&WSECSPAC)           +
                   DSNAME(&OUTNAME..OBJ)
        END                    /* C/C++ COMPLETE       LI319*/
      ELSE                     /* NOT 'C' LANGUAGE          */ +
        ALLOCATE DD(&SYSLIN) NEW BLKSIZE(3200) &WORKU REUSE    +
                 &SPACEUN SPACE(&WSPACE,&WSECSPAC)             +
                 DSNAME(&OUTNAME..OBJ)
    END                        /* SYSLIN COMPLETE           */
  ELSE                         /* 'C++' COMPILER       LI319*/ +
    DO                         /* PROCESS SYSLIN       LI319*/
      /*----------------------------------------------------*/
      /* SYSLIN: C++ &OUTNAME..&SUFF..OBJ              LI319*/
      /*         BECAUSE C++ GENERATES SYSLIN DSNAME   LI319*/
      /*----------------------------------------------------*/
      IF &CONTROL = NONE THEN  /* IF NO MSGS WANTED    LI319*/ +
        CONTROL NOMSG          /* AVOID FREE MESSAGES  LI319*/
      CONTROL MSG              /* ALLOW MESSAGES AGAIN LI319*/
    END                        /* SYSLIN COMPLETE      LI319*/
  /**********************************************************/
  /* CPARM: COMPLETE COMPILER PARAMETERS                    */
  /**********************************************************/
  IF &STR(&COPTION) NE &STR() THEN /* OPTION NOT BLANK LI319*/ +
   DO                          /* INTERNAL APOSTS      LI319*/
    /*------------------------------------------------------*/
    /* IF COMPILER OPTIONS HAVE IMBEDDED APOSTROPHES        */
    /* THAT ARE NOT ALREADY DOUBLED, DOUBLE THEM     KDB2036*/
    /*------------------------------------------------------*/
    SET &CLEN = &LENGTH(&NRSTR(&COPTION))
    SET &CNT  = 2
    SET &APOSTPOS = 1
    IF &SUBSTR(1:1,&COPTION) NE &STR(') THEN +
     DO WHILE &CNT LT &CLEN AND &APOSTPOS NE 0
      SET &APOSTPOS = &SYSINDEX(&STR('),&STR(&COPTION),&CNT) /*@39*/
      IF &APOSTPOS NE 0 THEN                                    /*@01*/+
        IF &APOSTPOS EQ &CLEN THEN                              /*@01*/+
          DO                                                    /*@01*/
            SET &COPTION = &COPTION&STR(')                      /*@01*/
            SET &CLEN = &CLEN + 1                               /*@01*/
            SET &CNT  = &APOSTPOS + 2                           /*@01*/
          END                                                   /*@01*/
        ELSE IF &APOSTPOS LT &CLEN AND                          /*@01*/+
         &SUBSTR(&APOSTPOS+1,&COPTION) NE &STR(') THEN +
          DO
            SET &COPTION = &SUBSTR(1:&APOSTPOS,+
             &COPTION)&STR(')+
             &SUBSTR(&APOSTPOS+1:&CLEN,&COPTION)
            SET &CLEN = &CLEN + 1
            SET &CNT  = &APOSTPOS + 2
          END
     END                       /* END OF KDB2036            */
   END                         /* END INTERNAL APOSTS  LI319*/
  /**********************************************************/
  /* COPTION: ADD TO COMPILE OPTIONS (CPARM)           LI319*/
  /**********************************************************/
  IF &STR(&COPTION) NE &STR() THEN /* OPIONS NOT BLANK LI319*/ +
   DO                          /* EXTERNAL APOSTS      LI319*/
    /*------------------------------------------------------*/
    /* IF COMPILER OPTIONS ARE ENCLOSED IN EXTERNAL    LI319*/
    /* APOSTROPHES, REMOVE THEM BEFORE ADDING TO CPARM LI319*/
    /*------------------------------------------------------*/
    IF &SUBSTR(1,&COPTION) = &STR(') THEN /* QUOTED?        */ +
      DO                       /* REMOVE THE QUOTES NOW     */
        SET &COPT = &SUBSTR(2:&LENGTH(&COPTION)-1,&COPTION)
        IF &CPARM = &STR() THEN /* NO CURRENT PARMS    LI319*/ +
          SET &CPARM = &STR(&COPT) /* SET PARMS        LI319*/
        ELSE                   /* ADD TO EXISTING      LI319*/ +
          SET &CPARM = &STR(&CPARM,&COPT) /* ADD PARMS LI319*/
      END                      /* REMOVE THE QUOTES NOW     */
    ELSE                                                       +
      SET &CPARM = &STR(&CPARM,&COPTION) /* ADD THEM   LI319*/
   END                         /* END EXTERNAL APOSTS  LI319*/
  /**********************************************************/
  /* INVOKE APPROPRIATE LANGUAGE COMPILER              LI319*/
  /**********************************************************/
  IF &HOST = CPP THEN          /* IF HOST IS C++       LI319*/ +
    DO                         /* INVOKE C++ CXX EXEC  LI319*/
      /******************************************************/
      /*   C++ REQUIRES CXX (REXX EXEC) INVOCATION     LI319*/
      /*      &COMP: &CPPUTIL WHERE CXX RESIDES        LI319*/
      /******************************************************/
      SET &CPARM = &STR((&CPARM)) /* CXX WANTS (PARMS) LI319*/
      SET &CPARM = &STR(&CPPSIN &CPARM) /* SINGLE PARM LI319*/
      EXEC &COMP '&CPARM'      /* INVOKE CXX EXEC      LI319*/
    END                        /* INVOCATION COMPLETE  LI319*/
  ELSE                         /* STANDARD INVOCATION  LI319*/ +
    CALL &COMP '&CPARM'        /* CALL COMPILER PROGRAM     */
  SET &ERROR = &LASTCC         /* SAVE THE RETURN CODE      */
  /**********************************************************/
  /* FREE THE DDNAMES OR FILES USED IN COMPILE         LI319*/
  /* (SYSIN, SYSLIN, SYSPUNCH, SYSLIB)                 LI319*/
  /**********************************************************/
  IF &CONTROL = NONE THEN      /* IF NO MSGS WANTED THEN    */ +
    CONTROL NOMSG              /* AVOID FREE MESSAGES       */
  FREE DDNAME(SYSIN)           /* FREE SYSIN                */
  IF &CONL NE      THEN        /* IF ALLOCATION REQUESTED   */ +
    FREE DDNAME(SYSLIB)        /* FREE FILES (DDNAMES)      */
  IF &HOST ^= CPP THEN         /* NOT 'C++' COMPILER   LI319*/ +
    DO                         /* FREE WORK FILES      LI319*/
      FREE DDNAME(&SYSLIN)     /* AND FREE THE FILE         */
      IF &MACIN NE NONE  THEN  /* MACRO PASS REQUESTED      */ +
        FREE DDNAME(SYSPUNCH)  /* FREE FILES (DDNAMES)      */
    END                        /* FREE COMPLETE        LI319*/
  /**********************************************************/
  /* FREE SYSUTN FILES                                      */
  /**********************************************************/
  IF &SYSUTN > 0 THEN          /* FILES ALLOCATED ?    LI319*/ +
    DO                         /* FREE WORK FILES      LI319*/
      SET &WORK = 1            /* INITIALIZE WORK FILE COUNT*/
      DO WHILE &WORK LE &SYSUTN /* DO FOR EACH WORK FILE    */
        FREE DDNAME(SYSUT&WORK) /* FREE THE WORK FILE       */
        SET &WORK = &WORK + 1  /* INCREMENT WORK FILE COUNT */
      END                      /* FREE     WORK FILES       */
    END                        /* FREE COMPLETE        LI319*/
  /**********************************************************/
  /* FREE SYSPRINT, SYSTERM AND 'C' DATA SETS          LI319*/
  /**********************************************************/
  IF &PRINT NE LEAVE THEN      /* IF ALLOCATION REQUESTED   */ +
    FREE DDNAME(SYSPRINT)      /* FREE THE DDNAME           */
  IF &HOST = C THEN            /* IF C LANGUAGE OR     LI319*/ +
    DO                         /* C DATA SETS               */
      /*----------------------------------------------------*/
      /* FREE SYSCPRT, SYSMSGS, SYSUT10+14             LI319*/
      /*----------------------------------------------------*/
      IF &PRINT NE LEAVE THEN  /* IF ALLOCATION REQD        */ +
        FREE DDNAME(SYSCPRT)   /* FREE THE DDNAME           */
      FREE DDNAME(SYSMSGS)     /* FREE SYSMSGS              */
      FREE DDNAME(SYSUT10)     /* FREE SYSUT10              */
      FREE DDNAME(SYSUT14)     /* FREE SYSUT14         LI319*/
    END
  /**********************************************************/
  /* FREE SYSMDECK                                       @C5*/
  /**********************************************************/
  IF &HOST = IBMCOB THEN       /* IF HOST IBMCOB         @C5*/ +
    DO                         /* PROCESS SYSMDECK       @C5*/
      FREE DDNAME(SYSMDECK)    /* FREE SYSMDECK          @C5*/
    END                        /* ALLOCATE COMPLETE      @C5*/
  IF &TERM  NE LEAVE THEN      /* IF ALLOCATION REQUESTED   */ +
    FREE DDNAME(SYSTERM)       /* FREE THE DDNAME           */
  CONTROL MSG                  /* ALLOW MESSAGES AGAIN      */
  EXIT CODE(&ERROR)            /* RETURN PROVIDING A CODE   */
  END                          /* OF DSNHC CLIST            */
++
//DSNTIV3 EXEC DSNTIVB,CLIST=DSNTINST INSTALL
//DSNTIV4 EXEC DSNTIVB,CLIST=DSNEAC01 DB2I
//DSNTIV5 EXEC DSNTIVB,CLIST=DSNEBC02 DB2I
//DSNTIV6 EXEC DSNTIVB,CLIST=DSNEBC03 DB2I
//DSNTIV7 EXEC DSNTIVB,CLIST=DSNEBC04 DB2I
//DSNTIV8 EXEC DSNTIVB,CLIST=DSNEBC05 DB2I
//DSNTIV9 EXEC DSNTIVB,CLIST=DSNEBC09 DB2I
//DSNTIVA EXEC DSNTIVB,CLIST=DSNEBC11 DB2I
//DSNTIVB EXEC DSNTIVB,CLIST=DSNEBC13 DB2I
//DSNTIVC EXEC DSNTIVB,CLIST=DSNECC01 DB2I
//DSNTIVD EXEC DSNTIVB,CLIST=DSNEDC01 DB2I
//DSNTIVE EXEC DSNTIVB,CLIST=DSNEKC01 DB2I
//DSNTIVF EXEC DSNTIVB,CLIST=DSNEMC01 DB2I
//DSNTIVB.SYSUT1 DD DATA,DLM='++'
 PROC 0
 /** PROLOGUE ********************************************************/
 /*  MODULE-NAME = DSNEMC01                                          */
 /*  DESCRIPTIVE-NAME = DB2I INITIALIZER                             */
 /*  AUTHOR/OWNER = RD DORMAN                                        */
 /*    LICENSED MATERIALS - PROPERTY OF IBM                          */
 /*    5650-DB2                                                      */
 /*    (C) COPYRIGHT 1982, 2016 IBM CORP.  ALL RIGHTS RESERVED.      */
 /*                                                                  */
 /*    STATUS = VERSION 12                                           */
 /*  FUNCTION = INITIALIZE VARIABLES USED BY THE PROGRAM             */
 /*             PREPARATION SYSTEM                                   */
 /*  NOTES                                                           */
 /*   DEPENDENCIES = VARIABLE NAMING IN DB2I, ISPF                   */
 /*   RESTRICTIONS = TRY TO CONCENTRATE THE PARTS OF DB2I THAT GET   */
 /*                  MODIFIED AT INSTALLATION TIME IN THIS CLIST.    */
 /*                  LEAVE PLENTY OF SPACE AT THE END OF THE LINES   */
 /*                  THAT INSTALL MODIFIES IN CASE THE NEW VALUES ARE*/
 /*                  LONGER THAN THE OLD ONES.                       */
 /*   REGISTER-CONVENTIONS = N/A                                     */
 /*   PATCH-LABEL  = NONE                                            */
 /*                                                                  */
 /*  MODULE-TYPE  = CLIST                                            */
 /*   PROCESSOR   = TSO CLIST PROCESSOR                              */
 /*   MODULE-SIZE = APPROXIMATELY 60 LINES                           */
 /*                                                                  */
 /*  ENTRY-POINT = DSNEMC01                                          */
 /*   PURPOSE = SEE FUNCTION                                         */
 /*   LINKAGE = CALLED BY ALL THE DB2I CLISTS IF THEIR               */
 /*             FIRST-TIME-CALLED INDICATORS ARE NOT SET TO "NO".    */
 /*                                                                  */
 /*  INPUT                                                           */
 /*   SYMBOLIC LABEL/NAME = VARIOUS ISPF POOL VARIABLES              */
 /*     DESCRIPTION = THE PANEL VARIABLES ARE STORED IN THE ISPF POOL*/
 /*  OUTPUT                                                          */
 /*   SYMBOLIC LABEL/NAME = N/A                                      */
 /*     DESCRIPTION = INITIALIZED VARIABLES FOR PROGRAM PREPARATION  */
 /*                   AND OTHER PANELS (BIND, DEFAULTS, PRECOMPILER) */
 /*  EXIT-NORMAL                                                     */
 /*   RETURN-CODES = 0                                               */
 /*   REASON-CODES = 0                                               */
 /*                                                                  */
 /*  EXIT-ERROR                                                      */
 /*   RETURN-CODES   = 0                                             */
 /*   ABEND-CODES    = 0                                             */
 /*   ERROR-MESSAGES = 0                                             */
 /*                                                                  */
 /*  EXTERNAL REFERENCES                                             */
 /*   ROUTINES/SERVICES = ISPEXEC, VGET, VPUT                        */
 /*   DATA-AREAS     = NONE                                          */
 /*   CONTROL-BLOCK  = NONE                                          */
 /*                                                                  */
 /*  TABLES          = NONE                                          */
 /*  MACROS          = NONE                                          */
 /*  CHANGE-ACTIVITY = NONE                                          */
 /*  = 03/13/84 - ADD "DSN120.DSNLOAD"                               */
 /*  = 05/03/84 - MAKE "DEFAULT" BE DEFAULT DELIMITER         R2SPIN4*/
 /*  = 07/15/86 - CHANGE DSN120 TO DSN130.                    R3TU113*/
 /*             - REMOVE "DSN120.DSNLOAD"                            */
 /*  = 02/02/87 - CHANGE DSN130 TO DSN210.                    R3TU103*/
 /*  = 10/08/87 - ADD SUPPORT FOR RE-INITIALIZING DSNEPROF   @BA17532*/
 /*               WHEN CHANGING RELEASES                     @BA17532*/
 /*  = 12/28/87 - CHANGE RELEASE LEVEL TO DSN220              KZL0014*/
 /*  = 04/21/89 - CHANGE RELEASE LEVEL TO DSN230              KYS0003*/
 /*  = 04/22/89 - SUPPORT BIND/REBIND PLAN/PACKAGE           TU1890H2*/
 /*  = 07/10/91 - MIA SUPPORT                        KDF0908/TU2590DG*/
 /*  = 05/22/92 - W68 QUALITY LI.                             LI278  */
 /*  = 06/18/92 - CHANGE DSNCLIST (&DSNEMV01) TO DSN310       KDW0092*/
 /*  = 09/01/92 - CHANGE RELEASE LEVEL TO DSN310              KDW0091*/
 /*  = 09/11/92 - CHANGE DSNCLIST TO SDSNCLST                 KDD0041*/
 /*  = 02/24/92 - CHANGE DSN310 TO DSN410                     KEF1011*/
 /*  = 03/31/94 - CHANGE RELEASE LEVEL TO 410                 KEW0160*/
 /*  = 01/24/95 - SUPPORT BOOKMANAGER DCR D8158               KED0120*/
 /*  = 06/27/95 - CHANGE RELEASE LEVEL TO 420                TU3270RC*/
 /*               MOVE &DSNEMV01 INTO MAINLINE PATH                  */
 /*  = 07/15/96 - SUPPORT DB2/GA ONLINE BOOKS                KFW0367 */
 /*  = 10/22/96 - CHANGE RELEASE LEVEL TO 510          D9028/TU35332I*/
 /*  = 03/19/97 - CHANGE RELEASE LEVEL TO 610                LI350TSO*/
 /*  = 07/26/98 - REQ00012302 LET USER CONTROL DEFAULT PANEL   FDG144*/
 /*               INITIALIZATION BY REMOVING 'RELEASE LEVEL CHECK'   */
 /*  = 04/27/01 - CHANGE RELEASE LEVEL TO 810                LI5060  */
 /*  = 10/31/03 - DISALLOW HOST(COBOL) AND HOST(COB2)           DJ218*/
 /*  = 09/16/04 - CHANGE RELEASE LEVEL TO 910                   LI673*/
 /*  = 10/19/04 - ADD SUPPORT FOR TRUSTED CONNECTIONS           LI663*/
 /*  = 06/09/08 - CHANGE RELEASE LEVEL TO 1010                  LI908*/
 /*  = 05/02/11 - dn1554r1                       dn1554_inst_1/DN1554*/
 /*               CHANGE RELEASE LEVEL TO 1110                 DN1554*/
 /*  = 01/16/14 - CHANGE RELEASE LEVEL TO 1210                170430 */
 /*  = 01/30/16 - z/OSMF workflow artifacts generation        s15572 */
 /*                                                                  */
 /*  SERIALIZATION-(LATCHES/LOCKS) = NONE                            */
 /** PSEUDOCODE ******************************************************/
 /*  IF THIS IS THE FIRST TIME DB2I HAS BEEN RUN BY THIS USER THEN   */
 /*    VAR = DEFAULT   (FOR ALL VARS ON DEFAULTS AND SERVICE PANELS  */
 /*    VPUT THE VARIABLE                                             */
 /*  SET DEFAULT BOOKMANAGER DATA SET NAMES AND SAVE          KED0120*/
 /*  END                                                             */
 /**** END PROLOGUE **************************************************/
 SET &DSNEAV05 = &STR()          /* TRACE CONTROL: CLIST             */
 ISPEXEC VGET DSNEAV05 PROFILE   /* ARE WE TRACING?                  */
 IF &DSNEAV05 = &STR() THEN SET &DSNEAV05 = NO    /* INITIALIZATION  */
 IF &DSNEAV05 = NO               /* DECIDE IF AND HOW WE ARE TRACING */-
   THEN CONTROL NOLIST NOCONLIST NOSYMLIST
   ELSE -
     DO
       IF &DSNEAV05 = LIST  THEN CONTROL LIST NOCONLIST NOSYMLIST
         ELSE IF &DSNEAV05 = CONLIST -
                 THEN CONTROL LIST CONLIST NOSYMLIST
                 ELSE CONTROL LIST CONLIST SYMLIST
     END
 /********************************************************************/
 CONTROL PROMPT
 SET &DSNE1M = &STR()            /* FIND OUT IF THIS IS THE FIRST RUN*/
 ISPEXEC VGET (DSNE1M) PROFILE   /* FOR THIS TSO USER                */
 IF &DSNE1M ^= NO THEN           /* TSO USER NEVER EXECUTED BEFORE   */-
   DO                            /* THEN DO IT ONCE, DON'T DO THIS   */
     SET &DSNE1M   = &STR(NO)    /* PART AGAIN FOR THIS TSO USER     */
     /***************************** INITIALIZE TRACE CONTROL VARS    */
     SET &DSNEAV03 = 0           /* TRACE CONTROL: DSN               */
     SET &DSNEAV04 = &STR()      /* TRACE CONTROL: SPUFI LOG         */
     /***************************** NOW SET DEFAULTS PANEL VARIABLES:*/
     SET &DSNEOV01 = &STR(${GRPATTNM})  /* SET DEFAULT SUBSYSTEM ID         */
     SET &DSNEOV02 = &STR(0)     /* SET DEFAULT RETRY COUNT          */
     SET &DSNEOVAU = &STR()      /* SET DEFAULT ASUSER FOR DSN       */
     SET &DSNEPV15 = &STR(8)     /* SET DEFAULT RETURN CODE PROGPREP */
     SET &DSNEOV25 = &STR(G)  /* SET DBCS SYMBOL FOR DCLGEN-TU2590DG */
     /****************************************************************/
     /* NEXT, SET VARIABLES THAT THE INSTALL CLIST MAY MODIFY AS     */
     /* INSTALLATION DEFAULTS. LEAVE LOTS OF SPACE AT THE END OF THE */
     /* LINES BECAUSE THE INSTALL PROCESS MAY MODIFY THEM BY EDITING */
     /****************************************************************/
     SET &DSNEOV03 = &STR(${DEFLANG})            /* LANGUAGE.         */
     SET &DSNEOV06 = &STR(#getDefStr(${DEFSTRNG}))
                                                /* COBOL STRING DELIM*/
     SET &DSNEOV07 = &STR(#getDefStr(${DEFSQSTR}))
                                                /* SQL STRING DELIM. */
     SET &DSNEOV08 = &STR(#getDecPt(${DECPOINT}))
                                                /* DECIMAL POINT.    */
                                                /* CLIST DATA SET:   */
     /****************************************************************/
     SET &DSNEOV04 = &STR(60)    /* SET DEFAULT LINES/LISTING PAGE   */
     SET &DSNEOV05 = &STR(I)     /* SET DEFAULT MESSAGE LEVEL        */
     SET &DSNEOV20 = &STR()      /* SET TYPE FOR JOB CARD LINE 1     */
     SET &DSNEOV21 = &STR()      /* SET TYPE FOR JOB CARD LINE 2     */
     SET &DSNEOV22 = &STR()      /* SET TYPE FOR JOB CARD LINE 3     */
     SET &DSNEOV23 = &STR()      /* SET TYPE FOR JOB CARD LINE 4     */
     /****************************************************************/
     ISPEXEC VPUT (              /* SAVE THE INITIALIZATION          */-
       DSNEOV01, DSNEOV02, DSNEOV03, DSNEOV04,                         -
       DSNEOV05, DSNEOV06, DSNEOV07, DSNEOV08,                         -
       DSNEOV20, DSNEOV21, DSNEOV22, DSNEOV23, DSNEOV25,               -
       DSNEAV03, DSNEAV04, DSNEAV05, DSNE1M  ,                         -
       DSNEREL,  DSNEPV15, DSNEOVAU) PROFILE
   END
 /********************************************************************/
 /* Remove online help code                                          */
 /********************************************************************/
 SET &DSNEMV01 = &NRSTR('${OUTCL}')
 ISPEXEC VPUT (DSNEMV01) PROFILE
 EXIT
END
++
//DSNTIVG EXEC DSNTIVB,CLIST=DSNEOC01 DB2I
//DSNTIVH EXEC DSNTIVB,CLIST=DSNEPC01 DB2I
//DSNTIVI EXEC DSNTIVB,CLIST=DSNERC01 DB2I
//DSNTIVJ EXEC DSNTIVB,CLIST=DSNESC01 DB2I
//DSNTIVK EXEC DSNTIVB,CLIST=DSNETC01 DB2I
//DSNTIVL EXEC DSNTIVB,CLIST=DSNEUC01 DB2I
//DSNTIVM EXEC DSNTIVB,CLIST=DSNU     UTILITY
//DSNTIVB.SYSUT1 DD DATA,DLM='++'
  PROC 0 UTILITY('"PROMPT"') CONTROL(NOLIST) COPYDSN('"PROMPT"') +
         COPYDSN2('"NULL"') RCPYDSN1('"NULL"') RCPYDSN2('"NULL"') +
         EDIT(NO) INDSN('"PROMPT"')  RECDSN('"PROMPT"') +
         DISCDSN('"OMITTED"') PUNCHDSN('"OMITTED"') +
         LISTDSN('"OMITTED"') TEMPDSN('"OMITTED"') +
         RESTART(NO) SYSTEM(${GRPATTNM}) SUBMIT(NO) UID('"NULL"') +
         DB2I(NO) UNIT(#getLib("${TVOLDEVT}","SYSDA")) +
         VOLUME('"OMITTED"') LIB('"NULL"')
  /*                                                              @041*/
  /********************************************************************/
  /*                                                                  */
  /*  CLIST-NAME:  DSNU                                               */
  /*                                                                  */
  /*  DESCRIPTIVE-NAME: ADMF UTILITY CLIST                            */
  /*                                                                  */
  /*   Licensed Materials - Property of IBM                           */
  /*   5650-DB2                                                       */
  /*   (C) COPYRIGHT 1982, 2016 IBM Corp.  All Rights Reserved.       */
  /*                                                                  */
  /*   STATUS = Version 12                                            */
  /*                                                                  */
  /*  FUNCTION = THIS CLIST WILL GENERATE THE NECESSARY JCL TO INVOKE */
  /*             THE ADMF UTILITIES IN THE BATCH ENVIRONMENT.         */
  /*                                                                  */
  /*  NOTES =                                                         */
  /*       DEPENDENCIES = THE JCL PROCEDURE, DSNUPROC, IS INVOKED     */
  /*                      AND MUST RESIDE WITHIN THE IMS/VS DB2 PROC  */
  /*                      LIBRARY.                                    */
  /*       RESTRICTIONS = NONE.                                       */
  /*                                                                  */
  /*  MODULE-TYPE = CLIST                                             */
  /*        PROCESSOR = TSO COMMAND PROCEDURE PROCESSOR               */
  /*                                                                  */
  /*  ENTRY = DSNU                                                    */
  /*        LINKAGE: %DSNU  PARAMETERS    OR CALL FROM CLIST DSNEUC01.*/
  /*                                                                  */
  /*  INPUT=                                                          */
  /*     PARAMETERS=                                                  */
  /*     POSITIONAL PARAMETER(S):                                     */
  /*       UTILITY- THE NAME OF A UTILITY FUNCTION.  VALID FUNCTIONS  */
  /* L108           ARE CHECK, CHECK DATA, COPY, DIAGNOSE, LOAD,      */
  /* L064           MERGECOPY, MODIFY, QUIESCE, RECOVER TABLESPACE,   */
  /* L356           RECOVER OBJECTS,                                  */
  /* @BA09328       RECOVER INDEX, REORG INDEX, REORG TABLESPACE,     */
  /* L064           REPAIR, REPORT, RUNSTATS, OR STOSPACE. EXCEPT FOR */
  /* L108           CHECK, RECOVER, REORG, & REPAIR, THE FIRST THREE  */
  /*                CHARACTERS OF ALL UTILITY NAME WILL BE USED TO    */
  /*                DETERMINE THE UTILITY NAME REQUIRED. FOR ALL      */
  /*                THOSE EXEPTIONAL UTILITIES LISTED ABOVE, THE      */
  /*                FIRST CHARACTER OF THE SECOND WORD OF THESE       */
  /*                UTILITY WILL BE USED TO DETERMINE THE UTILITY     */
  /*                NAME REQUIRED. AN INVALID UTILITY NAME WILL CAUSE */
  /*                THE CLIST TO PROMPT FOR A VALID ONE.              */
  /*     KEYWORD PARAMETER(S):                                        */
  /*       CONTROL- DEFINES THE CLIST PROCESSING OPTIONS THAT MAY BE  */
  /*                USED FOR DEBUGGING.  THIS PARAMETER WILL CONSIST  */
  /*                OF EITHER THE WORD NOLIST (DEFAULT)               */
  /*                OR A LIST OF THE                                  */
  /*                FOLLOWING OPTIONS DELIMITED BY A COLON:           */
  /*                  LIST =    DISPLAY TSO COMMANDS AND SUBCOMMANDS  */
  /*                            AFTER SYMBOLIC SUBSTITUTION BUT       */
  /*                            BEFORE EXECUTION,                     */
  /*                  CONLIST = DISPLAY CLIST COMMANDS AFTER SYMBOLIC */
  /*                            SUBSTITUTION BUT BEFORE EXECUTION,    */
  /*                  SYMLIST = DISPLAY THE EXECUTABLE STATEMENTS     */
  /*                            BEFORE THE SCAN FOR SYMBOLIC SUBSTITU-*/
  /*                            TION (EXECUTABLE STATEMENTS INCLUDE   */
  /*                            TSO COMMANDS, SUBCOMMANDS AND CLIST   */
  /*                            STATEMENTS).                          */
  /*                ONLY THE FIRST LETTER IS NECESSARY TO INDICATE ANY*/
  /*                PARAMETER VALUE.                                  */
  /*       COPYDSN - SPECIFIES THE NAME OF A CATALOGUED DATA SET      */
  /*                 REQUIRED BY THE IMAGE AND MERGE COPY UTILITIES   */
  /*                 AS A TARGET DATA SET.  THE SUPPLIED DATA SET     */
  /*                 WILL BE USED TO GENERATE A SYSCOPY DD STATEMENT. */
  /*                 THE OMISSION OF THE PARAMETER WHEN REQUESTING JCL*/
  /*                 FOR THE IMAGE AND MERGE COPY UTILITIES WILL CAUSE*/
  /*                 THE CLIST TO PROMPT THE USER FOR A DATA SET      */
  /*                 NAME. THIS PARAMETER IS IGNORED WHEN GENERATING  */
  /*                 JCL FOR ALL OTHER UTILITIES.                     */
  /*       COPYDSN2- OPTIONAL FOR COPY OR MERGECOPY.  SPECIFIES       */
  /*       @D6019    A BACKUP OUTPUT DATASET FOR THE                  */
  /*                 LOCAL/CURRENT SITE.  THE SUPPLIED DATA SET WILL  */
  /*                 BE USED TO GENERATE A SYSCOPY2 DD STATEMENT.     */
  /*                 THIS PARAMETER IS IGNORED WHEN GENERATING        */
  /*                 JCL FOR ALL OTHER UTILITIES AND WHEN OMITTED.    */
  /*       RCPYDSN1- OPTIONAL FOR COPY ONLY.  SPECIFIES               */
  /*       @6019     THE PRIMARY OUTPUT DATASET FOR THE               */
  /*                 RECOVERY SITE.  THE SUPPLIED DATA SET WILL       */
  /*                 BE USED TO GENERATE A SYSRCPY1 DD STATEMENT.     */
  /*                 THIS PARAMETER IS IGNORED WHEN GENERATING        */
  /*                 JCL FOR ALL OTHER UTILITIES AND WHEN OMITTED.    */
  /*       RCPYDSN2- OPTIONAL FOR COPY ONLY.  SPECIFIES               */
  /*       @6019     A BACKUP OUTPUT DATASET FOR THE RECOVERY SITE.   */
  /*                 RCPYDSN1 MUST NOT BE NULL. THE SUPPLIED DATA SET */
  /*                 WILL BE USED TO GENERATE A SYSRCPY2 DD           */
  /*                 STATEMENT. THIS PARAMETER IS IGNORED             */
  /*                 WHEN GENERATING JCL FOR ALL OTHER UTILITIES      */
  /*                 AND WHEN OMITTED.                                */
  /*       EDIT   - INDICATES WHETHER THE USER WISHES TO EDIT THE     */
  /*                FILE GENERATED BY THIS CLIST.                     */
  /*                 NO   = THE USER DOES NOT WISH TO EDIT THE        */
  /*                        THE CNTL FILE (DEFAULT).                  */
  /*                 TSO  = THE USER WISHES TO EDIT THE CNTL FILE WITH*/
  /*                        THE TSO EDITOR.                           */
  /*                 SPF  = THE USER WISHES TO EDIT THE CNTL FILE WITH*/
  /*                        THE SPF EDITOR.                           */
  /*       INDSN   - THE NAME OF THE USER'S INPUT FILE CONTAINING     */
  /*                 THE UTILITY CONTROL STATEMENTS. THIS PARAMETER IS*/
  /*                 REQUIRED.  IF A VALUE IS NOT ENTERED, THE CLIST  */
  /*                 WILL PROMPT THE USER.                            */
  /*       RECDSN -  SPECIFIES THE NAME OF A CATALOGUED DATA SET      */
  /*                 REQUIRED BY THE LOAD UTILITY AS AN INPUT         */
  /* @BA09328        DATA SET AND BY THE REORG TABLESPACE UTILITY     */
  /* @BA09328        AS THE UNLOAD DATA SET. THE SUPPLIED DATA SET    */
  /*                 WILL BE USED TO GENERATE A SYSREC DD STATEMENT.  */
  /*                 THE OMISSION OF THE PARAMETER WHEN REQUESTING    */
  /* @BA09328        JCL FOR THE LOAD AND REORG TABLESPACE UTILITIES  */
  /*                 WILL CAUSE THE CLIST TO PROMPT THE USER FOR A    */
  /*                 DATA SET NAME. THIS PARAMETER IS IGNORED WHEN    */
  /*                 GENERATING JCL FOR ALL OTHER UTILITIES.          */
  /*       DISCDSN - SPECIFIES THE NAME OF THE OPTIONAL LOAD OR REORG */
  /*                 DISCARD DATASET.  THE LOAD UTILITY PLACES SOURCE */
  /*                 RECORDS WHICH CAN NOT BE LOADED, INTO THIS       */
  /*                 DATASET. THE REORG UTILITY PLACES DISCARDED      */
  /*                 RECORDS INTO THIS DATASET.  THE SUPPLIED DATA SET*/
  /*                 WILL BE USED TO GENERATE A SYSDISC DD STATEMENT. */
  /*                 THE OMISSION OF THE PARAMETER WHEN REQUESTING JCL*/
  /*                 FOR THE LOAD OR REORG UTILITY WILL CAUSE THE     */
  /*                 SYSDISC DD STATEMENT NOT TO BE BUILT.            */
  /*                 THIS PARAMETER IS IGNORED WHEN GENERATING JCL FOR*/
  /*                 ALL OTHER UTILITIES.                             */
  /*       PUNCHDSN- SPECIFIES THE NAME OF THE OPTIONAL REORG PUNCH   */
  /*                 DISCARD DATASET.  THE REORG UTILITY PLACES       */
  /*                 GENERATED LOAD UTILITY CONTROL STATEMENTS INTO   */
  /*                 THIS DATASET.  WILL BE USED TO GENERATE A        */
  /*                 SYSPUNCH DD STATEMENT. THE OMISSION OF THE       */
  /*                 PARAMETER WHEN REQUESTING JCL FOR THE REORG      */
  /*                 UTILITY WILL CAUSE THE SYSPUNCH DD STATEMENT NOT */
  /*                 TO BE BUILT.                                     */
  /*                 THIS PARAMETER IS IGNORED WHEN GENERATING JCL FOR*/
  /*                 ALL OTHER UTILITIES.                             */
  /*L415   LISTDSN - SPECIFIES THE NAME OF THE OPTIONAL LISTDEF       */
  /*                 DATASET.  THIS DATASET CONTAINS LISTDEF CONTROL  */
  /*                 STATEMENTS WHICH DEFINE LISTS OF OBJECTS TO      */
  /*                 BE PROCESSED BY OTHER UTILITIES.                 */
  /*L415   TEMPDSN - SPECIFIES THE NAME OF THE OPTIONAL TEMPLATE      */
  /*                 DATASET.  THIS DATASET CONTAINS TEMPLATE CONTROL */
  /*                 STATEMENTS WHICH ARE USED TO DYNAMICALLY ALLOCATE*/
  /*                 DATASETS RATHER THAN PROVIDING DD CARDS.         */
  /*                 SPECIFY "TEMPDSN(SYSIN)" IF TEMPLATE STATEMENTS  */
  /*                 WILL BE PROVIDED IN SYSIN.  SPECIFYING A TEMPDSN */
  /*                 MAKES PREVIOUSLY REQUIRED DSNs OPTIONAL.         */
  /*       RESTART-  INDICATES WHETHER TO RESTART THE UTILITY.  VALUES*/
  /*                 ALLOWED ARE:                                     */
  /*                     NO       = DO NOT RESTART THE UTILITY        */
  /*                                (DEFAULT).                        */
  /*                     PHASE    =  RESTART THE UTILITY AT THE BEGIN-*/
  /*                                 NING OF THE LAST SUCCESSFULLY    */
  /*                                 COMPLETED PHASE OR THE BEGINNING */
  /*                                 OF THE JOB.                      */
  /*                     CURRENT  =  RESTART THE UTILITY AT THE LAST  */
  /*                                 COMMIT POINT.                    */
  /*                     PREVIEW  =  RUN IN PREVIEW, NOT RESTART      */
  /*       SYSTEM -  THE ONE TO FOUR CHARACTER NAME OF YOUR SUBSYSTEM */
  /*                 INDICATED ON THE PARMS PARAMETER OF THE EXEC CARD*/
  /*                 TO IDENTIFY THIS JOB TO IMS/VS DB2. THIS PARAMET-*/
  /*                 ER IS REQUIRED.THE DEFAULT SYSTEM NAME           */
  /*                 IS DSN WHICH CAN BE MODIFIED BY THE USER DURING  */
  /*                 THE SYSTEM INSTALLATION PROCESS.                 */
  /*       SUBMIT -  SHOULD THE GENERATED FILE BE AUTOMATICALLY       */
  /*                 SUBMITTED FOR BACKGROUND PROCESSING VIA THE      */
  /*                 TSO SUBMIT COMMAND.                              */
  /*                   YES =    SUBMIT THE GENERATED CNTL FILE,       */
  /*                   NO  =    DO NOT SUBMIT THE GENERATED CNTL      */
  /*                            FILE.                                 */
  /*                   PROMPT = THE CLIST WILL PROMPT THE USER FOR    */
  /*                            AN ANSWER BEFORE SUBMISSION IS DONE.  */
  /*                            (VALID ONLY FOR THE TSO INTERACTIVE   */
  /*                             ENVIRONMENT).                        */
  /*                 SUBMIT(NO) IS THE DEFAULT PARAMETER VALUE.       */
  /*       UID    -  SPECIFIES A ONE TO SIXTEEN CHARACTER UTILITY     */
  /*                 IDENTIFIER TO UNIQUELY IDENTIFY A UTILITY JOB    */
  /*                 WITHIN DB2.  THIS IDENTIFIER IS PASSED TO DB2 VIA*/
  /*                 THE PARM= PARAMETER OF THE EXEC CARD.  IF        */
  /*                 OMITTED, IT IS DEFAULTED TO TSO-USERID.EIGHT-    */
  /*                 CHARACTER-CNTL-FILE-NAME.                        */
  /*       DB2I   -  INDICATES WHERE TO RETRIEVE CONTROL STATEMENTS.  */
  /*                 NO   DEFAULT  CONTROL STATEMENTS PROVIDED BY     */
  /*                               THIS CLIST.                        */
  /*                 YES           CONTROL STATEMENTS RETRIEVED FROM  */
  /*                               DB2I DEFAULT PANEL UNDER JOB       */
  /*                               STATEMENT SECTION.                 */
  /*       UNIT   -  SPECIFIES A UNIT ADDRESS, A GENERIC NAME OF A    */
  /*                 DEVICE TYPE OR A USER-ASSIGNED GROUP NAME THAT   */
  /*                 IDENTIFIES WHERE A TEMPORARY WORK DATA SET OR A  */
  /*                 NEW PERMENANT WORK DATA SET IS TO BE ASSIGNED.   */
  /*                 THE VALUE SPECIFIED WILL BE PLACED AFTER THE     */
  /*                 UNIT= CLAUSE OF THE GENERATED DD STATEMENT.      */
  /*                 THE DEFAULT VALUE FOR THIS PARAMETER IS SYSDA.   */
  /*       VOLUME -  SPECIFIES THE VOLUME SERIAL NUMBER ON WHICH A NEW*/
  /*                 PERMANENT DATA SET WILL RESIDE OR ON WHICH A     */
  /*                 TEMPORARY WORK DATA SET RESIDES OR WILL RESIDE.  */
  /*                 THIS NUMBER WILL BE PLACED AFTER THE VOL=SER     */
  /*                 CLAUSE OF THE GENERATED DD STATEMENT.  IF THIS   */
  /*                 PARAMETER IS NULL, THE  VOL CLAUSE WILL BE OMIT- */
  /*                 TED FROM THE GENERATED DD STATEMENT.             */
  /*       LIB    -  SPECIFIES the optional DATA SET NAME for    @041 */
  /*                 STEPLIB                                     @041 */
  /*                                                                  */
  /*  OUTPUT=                                                         */
  /*     CNTL-FILES= THE FOLLOWING CONTROL FILES MAY BE GENERATED     */
  /*                 DEPENDING UPON THE UTILITY FUNCTION REQUESTED:   */
  /* L334      DSNUCHI  - CONTAINING JCL FOR THE CHECK INDEX UTILITY  */
  /* L334      DSNUCHL  - CONTAINING JCL FOR THE CHECK LOB UTILITY    */
  /* L108      DSNUCHD  - CONTAINING JCL FOR THE CHECK DATA UTILITY   */
  /*           DSNUCOP  - CONTAINING JCL FOR THE COPY UTILITY         */
  /*           DSNUDIA  - CONTAINING JCL FOR THE DIAGNOSE UTILITY     */
  /*           DSNULOA  - CONTAINING JCL FOR THE LOAD UTILITY         */
  /*           DSNUMER  - CONTAINING JCL FOR THE MERGE/COPY UTILITY   */
  /*           DSNUMOD  - CONTAINING JCL FOR THE MODIFY UTILITY       */
  /*           DSNUQUI  - CONTAINING JCL FOR THE QUIESCE  UTILITY     */
  /* L109      DSNURCT  - CONTAINING JCL FOR THE RECOVER TABLESPACE   */
  /* L109      DSNURCI  - CONTAINING JCL FOR THE RECOVER INDEX        */
  /* L356      DSNURCO  - CONTAINING JCL FOR THE RECOVER OBJECTS      */
  /*           DSNUREP  - CONTAINING JCL FOR THE REPAIR UTILITY       */
  /* @BA09328  DSNURGI  - CONTAINING JCL FOR THE REORG INDEX          */
  /* LI334     DSNURGL  - CONTAINING JCL FOR THE REORG LOB            */
  /* @BA09328  DSNURGT  - CONTAINING JCL FOR THE REORG TABLESPACE     */
  /*           DSNURPT  - CONTAINING JCL FOR THE REPORT   UTILITY     */
  /*           DSNURUN  - CONTAINING JCL FOR THE RUNSTATS UTILITY     */
  /*           DSNUSTO  - CONTAINING JCL FOR THE STOSPACE UTILITY     */
  /*                                                                  */
  /*  EXIT-NORMAL = EXIT(0).                                          */
  /*                                                                  */
  /*  EXIT-ERROR =                                                    */
  /*       RETURN-CODE =                                              */
  /*                        4 - A WARNING MESSAGE WAS GENERATED.      */
  /*                        8 - A REQUIRED PARAMETER WAS NOT ENTERED. */
  /*                       12 - A TSO ERROR WAS ENCOUNTERED.  THE TSO */
  /*                            ERROR RETURN CODE WILL BE PRINTED.    */
  /*                       16 - A EDITOR ERROR WAS ENCOUNTERED.  THE  */
  /*                            ERROR RETURN CODE WILL BE PRINTED.    */
  /*                                                                  */
  /*  EXTERNAL-REFERENCES=                                            */
  /*      MODULES CALLED:                                             */
  /*          TSO EDITOR                                              */
  /*                 LINKAGE:  EDIT UTILITY_JCL_OUTPUT_DATA_SET_NAME  */
  /*                                   CNTL NONUM.                    */
  /*          SPF EDITOR                                              */
  /*                 LINKAGE:  ISPEXEC EDIT DATASET (UTILITY_JCL_     */
  /*                                 OUTPUT_DATA_SET_NAME).           */
  /*      TSO COMMANDS:                                               */
  /*               ALLOC   - ALLOCATE THE UTILITY JCL OUTPUT DATA SET */
  /*                           OR THE INDSN DATA SET.                 */
  /*               ATTR    - ALLOCATE THE RECORD ATTRIBUTES FOR THE   */
  /*                           UTILITY JCL OUTPUT DATA SET.           */
  /*               CONTROL - SELECT CLIST TRACING                     */
  /*               DELETE  - DELETE THE PREVIOUS UTILITY JCL DATA SET.*/
  /*               EXEC    - INVOKE THE DSNUREQ CLIST                 */
  /*               FREE    - FREE ANY PREVIOUSLY DEFINED ATTR LISTS   */
  /*                            WITH THE NAME OF DSNUFIX.             */
  /*               SUBMIT  - SUBMIT THE UTILITY JCL DATA SET TO THE   */
  /*                            BACKGROUND.                           */
  /*      CLISTS:                                                     */
  /*               DSNUREQ  - PROMPT FOR REQUIRED PARAMETERS.         */
  /*                  INPUT:                                          */
  /*                       PROMPT - INDICATES TYPE OF PARAMETER TO    */
  /*                                PROMPT THE USER FOR.              */
  /*                   OUTPUT:                                        */
  /*                       DSNUVALU - THE INPUT VALUE.                */
  /*                       &LASTCC  - WILL BE SET TO   8 IF THE CLIST */
  /*                                  IS EXECUTED IN THE TSO BATCH    */
  /*                                  ENVIRONMENT AND THE PARAMETER   */
  /*                                  INDICATED BY THE VALUE OF PROMPT*/
  /*                                  IS A REQUIRED CLIST PARAMETER   */
  /*                                  WITH NO DEFAULTS.               */
  /*                                                                  */
  /*  CHANGE-ACTIVITY                                                 */
  /*                    PP43083 - 05/07/85 - SUBMIT(PROMPT)   @BA43083*/
  /*                    PP00876 - INVALID DSN GENERATED       @BA00876*/
  /*                    7/21/86 - SUPPORT RECOVER INDEX OF RELEASE 3  */
  /*                                                          R3TU188 */
  /*                    PL03342 - ACCEPT GDG DSN FOR COPYDSN  @BA03342*/
  /*                      03/87 - SUPPORT NEW UTILITIES FOR REL. C    */
  /*                    PL09328 - DIFFERENTIATE BETWEEN REORG INDEX   */
  /*                              AND REORG TABLESPACE        @BA09328*/
  /*                    PL10465 - FOR THE LOAD UTILITY CHANGE DISP OF */
  /*                              SYSREC TO OLD               @BA10465*/
  /*                    PL19380 - CHANGE DISP FROM MOD TO NEW FOR NEW */
  /*                              DATA SETS WHEN VOLUME IS SPECIFIED  */
  /*                    PL21058 - CHANGE BLOCKSIZE FROM 4K TO 16K FOR */
  /*                              SPACE PARM ON DD CARDS      @BA21058*/
  /*                    PL22638 - CHANGE &SYSUID TO &SYSPREF  @BA22638*/
  /*                    PL33751 - FIX FOR PL22638             @BA33751*/
  /*                    D6019   - CHANGES FOR LI185           @D6019  */
  /*                              THREE NEW DATA SETS ARE ADDED       */
  /*                              TO THE UTILITY PANEL.  COPY UTILITY */
  /*                              CAN HAVE A MAX OF 4 DATASETS AND    */
  /*                              MERGECOPY UTILITY CAN HAVE A MAX    */
  /*                              OF 2 DATASETS.                      */
  /*                    D9036   - CHANGES FOR LI316 (KFD0059)     @36 */
  /*                    LI372   - ADD PUNCHDSN                 LI372UT*/
  /*                    LI356   - ADD RECOVER OBJECTS           LI356 */
  /*                    D5790   - REMOVE RECO OBJ AND RENAME    D5790 */
  /*                              RECO INDX TO REBUILD                */
  /*                    LI334   - LARGE OBJECT SUPPORT            @334*/
  /*                    LI415   - ADD LIST/TEMPLATE LOGIC         L415*/
  /*                    21280   - 2000/08/06 yt  LI392 UNLOAD     @280*/
  /*                    DK041   - 2005/01/25 BB ADD LIB parm      @041*/
  /*                    s15572  - z/OSMF workflow artifacts           */
  /*                              generation                          */
  /********************************************************************/
  /*                                                                  */
  /*                                                                  */
  /********************************************************************/
  /*  PARAMETERS TO DSNUREQ                                           */
  /********************************************************************/
  /*                                                                  */
       GLOBAL  DSNUVALU            /* CONTAIN PROMPTED VALUE RETURNED*/
                                   /*   FROM DSNUREQ                 */
  /*                                                                  */
  /********************************************************************/
  /*                                                                  */
  /*  SET CONTROL PARAMETER, INITIALIZE GLOBAL VARIABLES AND SET      */
  /*     THE GLOBAL ERROR PROCESSING ROUTINE                          */
  /*                                                                  */
  /********************************************************************/
  /*                                                                  */
   CONTROL NOFLUSH
   SET &INP = &STR(NULL)
   SET &JCL = &STR(NULL)
   SET &RCBADP = 8
   SET &RCTSO = 12
   SET &RCEDIT = 16
   SET &RCWARN = 4
   SET &RCOK = 0
   SET &RCEOF = 400
   SET &RCNEX = 332
   SET &RC = 0
   ERROR DO
         SET &TRC = &LASTCC
         GOTO TSOERROR
         END
   IF &SUBSTR(1,&CONTROL) = NONE THEN +
               CONTROL NOLIST NOCONLIST NOSYMLIST
   ELSE DO
     SET &LEN = &LENGTH(&CONTROL.)
     SET &NEXT = 1
     SET &BEG = 1
     DO WHILE &LEN >= &NEXT
       IF &STR(&SUBSTR(&NEXT,&CONTROL)) = &STR(:) | +
        &LEN = &NEXT THEN DO
          SET &END = &NEXT - 1
          IF &NEXT = &LEN THEN SET &END = &NEXT
          SET &CON = &SUBSTR(&BEG,&CONTROL)
          IF &CON = &STR(L) THEN CONTROL LIST
          IF &CON = &STR(C) THEN CONTROL CONLIST
          IF &CON = &STR(S) THEN CONTROL SYMLIST
          SET &BEG = &NEXT + 1
          END
       SET &NEXT = &NEXT + 1
       END
     END
 /*
 /*********************************************************************/
 /*                                                                   */
 /*  GENERATE THE PROPER CLIST CALL FOR DSNUREQ BASED UPON THE CLIST  */
 /*    LIBRARY NAME SUPPLIED                                          */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */

  SET &QUOTE   =  &STR(')
  SET &DSNUREQ =  &STR(%DSNUREQ )
  SET &PRMTU   =  &STR(&DSNUREQ.+
                     PROMPT(UTILITY) CONTROL(&CONTROL))
  SET &PRMTIN  =  &STR(&DSNUREQ.+
                     PROMPT(INDSN) CONTROL(&CONTROL))
  SET &PRMTREC =  &STR(&DSNUREQ.+
                     PROMPT(RECDSN) CONTROL(&CONTROL))
  SET &PRMTCOPY=  &STR(&DSNUREQ.+
                     PROMPT(COPYDSN) CONTROL(&CONTROL))
  SET &PRMTSYS =  &STR(&DSNUREQ.+
                     PROMPT(SYSTEM) CONTROL(&CONTROL))
  SET &PRMTUID =  &STR(&DSNUREQ.+
                     PROMPT(UID) CONTROL(&CONTROL))
  SET &PRMTRES =  &STR(&DSNUREQ.+
                     PROMPT(RESTART) CONTROL(&CONTROL))
  SET &PRMTEDT =  &STR(&DSNUREQ.+
                     PROMPT(EDIT) CONTROL(&CONTROL))
  SET &PRMTSUB =  &STR(&DSNUREQ.+
                     PROMPT(SUBMIT) CONTROL(&CONTROL))
 /*                                                                   */
 /*********************************************************************/
 /*  INITIALIZE TITLE VARIABLES AND THE ERROR FLAG VARIABLE           */
 /*********************************************************************/
 /*                                                                   */
   SET &TITLE0 = &STR(**MISSING**)
   SET &TITLE1 = &STR(IMAGE COPY)
   SET &TITLE2 = &STR(LOAD)
   SET &TITLE3 = &STR(MERGE/COPY)
   SET &TITLE4 = &STR(RECOVER)
   SET &TITLE5 = &STR(REORG TABLESPACE)                  /* @BA09328 */
   SET &TITLE6 = &STR(REPAIR)
   SET &TITLE7 = &STR(RUNSTATS)
   SET &TITLE8 = &STR(STOSPACE)
   SET &TITLE9 = &STR(CHECK INDEX)                            /* @334*/
   SET &TITLE10 = &STR(MODIFY)
   SET &TITLE11 = &STR(REBUILD)
   SET &TITLE12 = &STR(REPORT)
   SET &TITLE13 = &STR(QUIESCE)                   /*           L064  */
   SET &TITLE14 = &STR(DIAGNOSE)                  /*           L064  */
   SET &TITLE15 = &STR(REORG INDEX)                      /* @BA09328 */
   SET &TITLE16 = &STR(CHECK DATA)                /*           L108  */
   SET &TITLE17 = &STR(CHECK LOB)                             /* @334*/
   SET &TITLE18 = &STR(REORG LOB)                             /* @334*/
   SET &TITLE19 = &STR(UNLOAD)                                /* @280*/
 /*                                                                  */
 /********************************************************************/
 /*  CHECK FOR VALID REQUIRED PARAMETERS                             */
 /********************************************************************/
 /*                                                                  */
 /*                                                                   */
 /*------------------------------------------------------------------*/
 /*  DETERMINE UTILITY FUNCTION SPECIFIED                            */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 CKUTIL: +
  SET &U = 0
  IF &UTILITY = &STR("PROMPT") | &LENGTH(&UTILITY) < 3 THEN
   ELSE DO
      IF &SUBSTR(1:3,&UTILITY) = &STR(COP) THEN SET &U = 1
      IF &SUBSTR(1:3,&UTILITY) = &STR(LOA) THEN SET &U = 2
      IF &SUBSTR(1:3,&UTILITY) = &STR(MER) THEN SET &U = 3
      IF &SUBSTR(1:3,&UTILITY) = &STR(REC) THEN SET &U = 4
      IF &SUBSTR(1:3,&UTILITY) = &STR(RUN) THEN SET &U = 7
      IF &SUBSTR(1:3,&UTILITY) = &STR(STO) THEN SET &U = 8
      IF &SUBSTR(1:3,&UTILITY) = &STR(MOD) THEN SET &U = 10
      IF &SUBSTR(1:3,&UTILITY) = &STR(REB) THEN SET &U = 11
      IF &SUBSTR(1:3,&UTILITY) = &STR(QUI) THEN SET &U = 13 /* L064  */
      IF &SUBSTR(1:3,&UTILITY) = &STR(DIA) THEN SET &U = 14 /* L064  */
      IF &SUBSTR(1:3,&UTILITY) = &STR(UNL) THEN SET &U = 19 /* @280  */
      IF &SUBSTR(1:3,&UTILITY) = &STR(REO) THEN         /* @BA09328 */+
        DO                                              /* @BA09328 */
          IF(&SUBSTR(7,&UTILITY) = &STR(T)) THEN        /* @334*/     +
            DO                                          /* @BA09328 */
              SET &U = 5                                /* @BA09328 */
              SET &UTILITY = &STR(RGTBSP)               /* @BA09328 */
            END                                         /* @BA09328 */
          ELSE                                          /* @334*/     +
            DO                                                /* @334*/
              IF(&SUBSTR(7,&UTILITY) = &STR(I)) THEN    /* @334*/     +
                DO                                            /* @334*/
                  SET &U = 15                                 /* @334*/
                  SET &UTILITY = &STR(RGINDEX)                /* @334*/
                END                                           /* @334*/
              ELSE                                      /* @334*/     +
                DO                                            /* @334*/
                  SET &U = 18                                 /* @334*/
                  SET &UTILITY = &STR(RGLOB)                  /* @334*/
                END                                           /* @334*/
            END                                               /* @334*/
        END                                                   /* @334*/
      IF &SUBSTR(1:3,&UTILITY) = &STR(REP) THEN             /* L064  */+
        DO                                                  /* L064  */
          IF &SUBSTR(4,&UTILITY) = &STR(A) THEN SET &U = 6  /* L064  */
          ELSE                                              /* L064  */+
            DO                                              /* L064  */
              SET &U = 12                                   /* L064  */
              SET &UTILITY = &STR(RPT)              /* REPORT  L064  */
            END                                             /* L064  */
        END                                                 /* L064  */
      IF &SUBSTR(1:3,&UTILITY) = &STR(CHE) THEN             /* L108  */+
        DO                                                  /* L108  */
          IF &SUBSTR(7,&UTILITY) = &STR(D) THEN           /* @334*/   +
            DO                                              /* L108  */
              SET &U = 16                                   /* L108  */
              SET &UTILITY =  &STR(CHD)             /* CHECK DATA    */
            END                                             /* L108  */
          ELSE                                            /* @334*/   +
            DO                                                /* @334*/
              IF &SUBSTR(7,&UTILITY) = &STR(I) THEN          /* @334*/+
                DO                                            /* @334*/
                  SET &U = 9                                  /* @334*/
                  SET &UTILITY = &STR(CHI)                    /* @334*/
                END                                           /* @334*/
              ELSE                                        /* @334*/   +
                DO                                            /* @334*/
                  SET &U = 17
                  SET &UTILITY = &STR(CHL)                    /* @334*/
                END                                           /* @334*/
            END                                               /* @334*/
        END                                                 /* L108  */
      END
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /*  CHECK FOR INVALID UTILITY NAME                                  */
 /*------------------------------------------------------------------*/
 /*                                                                  */
  IF &U = 0 THEN DO
       IF &UTILITY ^= &STR("PROMPT") THEN +
               WRITE >>ERROR:  INVALID UTILITY - &UTILITY
       &PRMTU
       SET &RET = &LASTCC
       IF &RET = 0 THEN DO
            SET &UTILITY = &STR(&DSNUVALU)
            GOTO CKUTIL
            END
       ELSE IF &RC <= &RCBADP THEN &RC = &RCBADP
       END
 /*                                                                   */
 /*-------------------------------------------------------------------*/
 /*  VERIFY THAT REQUIRED INPUT FILE NAME CONTAINING THE ADMF UTILITY */
 /*    STATEMENTS HAS BEEN SUPPLIED                                   */
 /*-------------------------------------------------------------------*/
 /*                                                                   */
   IF &INDSN = &STR("PROMPT") THEN DO
       &PRMTIN
       SET &RET = &LASTCC
       IF &RET ^= 0 THEN DO
            SET &INDSN = &STR(**MISSING**)
            IF &RC <= &RCBADP THEN &RC = &RCBADP
            END
       ELSE +
          SET &INDSN = &STR(&DSNUVALU)
       END
 /*                                                                   */
 /*-------------------------------------------------------------------*/
 /*  IF TEMPLATES ARE BEING USED, SET DD CARDS TO NOT REQUIRED  @L415 */
 /*-------------------------------------------------------------------*/
 /*                                                                   */
   IF &TEMPDSN = SYSIN | -
      ( &TEMPDSN ^= SYSIN && -
        &TEMPDSN ^= &STR("OMITTED") ) THEN -
     DO
       IF &RECDSN = &STR("PROMPT") THEN -
         SET &RECDSN = &STR(**OPTIONAL**)
       IF &COPYDSN = &STR("PROMPT") THEN -
         SET &COPYDSN = &STR(**OPTIONAL**)
       IF &COPYDSN2 = &STR("NULL") THEN -
         SET &COPYDSN2 = &STR(**OPTIONAL**)
       IF &RCPYDSN1 = &STR("NULL") THEN -
         SET &RCPYDSN1 = &STR(**OPTIONAL**)
       IF &RCPYDSN2 = &STR("NULL") THEN -
         SET &RCPYDSN2 = &STR(**OPTIONAL**)
       IF &PUNCHDSN = &STR("OMITTED") THEN -
         SET &PUNCHDSN = &STR(**OPTIONAL**)
     END
 /*                                                                   */
 /*-------------------------------------------------------------------*/
 /*  CHECK IF SYSREC INPUT DATA SET REQUIRED.  (ONLY REQUIRED FOR THE */
 /*    LOAD, REORG TABLESPACE, OR UNLOAD UTILITY)        @BA09328 @280*/
 /*-------------------------------------------------------------------*/
 /*                                                                   */
   IF &U = 2 | &U = 5  | &U = 19 THEN DO       /* RECDSN REQUIRED @280*/
     IF &STR(&RECDSN) = &STR("PROMPT") THEN DO   /* RECDSN MISSING  */
          &PRMTREC
          SET &RET = &LASTCC
          IF &RET ^= 0 THEN DO
               SET &RECDSN = &STR(**MISSING**)
               IF &RC <= &RCBADP THEN &RC = &RCBADP
               END
          ELSE +
             SET &RECDSN = &STR(&DSNUVALU)
        END
     END
 /*                                                                   */
 /*-------------------------------------------------------------------*/
 /*  CHECK IF SYSCOPY DATA SET REQUIRED.  MERGECOPY UTILITY REQUIRES  */
 /*    THIS DATASET.  COPY UTILITY REQUIRES THIS DATA SET IF          */
 /*    RCPYDSN1 WAS NOT SPECIFIED.  COPY UTILITY WILL ACCEPT COPYDSN  */
 /*    OR RCPYDSN1 OR BOTH.  WHEN NEITHER COPYDSN NOR RCPYDSN1 IS     */
 /*    SPECIFIED, COPY UTILITY DEFAULTS TO COPYDSN.  THAT IS,         */
 /*    WHEN NEITHER IS SPECIFIED, COPY UTILITY ASSUMES THAT THE USER  */
 /*    "INTENDED" TO SPECIFY COPYDSN.                      @D6019     */
 /*-------------------------------------------------------------------*/
 /*                                                                   */
   IF (&U = 1 AND &STR(&RCPYDSN1) = &STR("NULL")) | &U = 3 THEN DO
      IF &STR(&COPYDSN) = &STR("PROMPT") THEN DO        /* @BA03342 */
          &PRMTCOPY
          SET &RET = &LASTCC
          IF &RET ^= 0 THEN DO
               SET &COPYDSN = &STR(**MISSING**)
               IF &RC <= &RCBADP THEN &RC = &RCBADP
               END
          ELSE +
             SET &COPYDSN = &STR(&DSNUVALU)
          END
      END
   ELSE DO
      IF ((&U=1|&U=2|&U=5) AND &STR(&COPYDSN) = &STR("PROMPT")) THEN  +
         SET &COPYDSN = &STR(**OPTIONAL**)
      ELSE  +
         IF &U^=1 AND &U^=2 AND &U^=5 THEN                  /* @36 */ +
            SET &COPYDSN = &STR(**NOT REQUIRED**)
   END
 /*********************************************************************/
 /* IF COPY OR MERGECOPY UTILITY, COPYDSN2 IS OPTIONAL.        @D6019 */
 /* COPYDSN2 CAN ONLY BE SPECIFIED IF COPYDSN IS.              @D6019 */
 /*********************************************************************/
   IF &U=1|&U=3|&U=2|&U=5 THEN DO     /* COPY/MERG/LOAD/REORG TBSP @36*/
      IF &STR(&COPYDSN) = &STR(**OPTIONAL**)  |                       +
         &STR(&COPYDSN2) = &STR("NULL") THEN                          +
         SET &COPYDSN2 = &STR(**OPTIONAL**)
   END
   ELSE DO
      SET &COPYDSN2 = &STR(**NOT REQUIRED**)
   END
 /*********************************************************************/
 /* IF COPY, RCPYDSN1 AND  RCPYDSN2 ARE OPTIONAL.              @D6019 */
 /* RCPYDSN2 CAN ONLY BE SPECIFIED IF RCPYDSN1 IS SPECIFIED.   @D6019 */
 /* THEREFORE, IF RCPYDSN1 IS NULL THEN RCPYDSN2 IS ASSUMED    @D6019 */
 /* TO BE NULL ALSO.  IF RCPYDSN1 IS SPECIFIED THEN THE        @D6019 */
 /* VALUE OF RCPYDSN2 CAN BE CHECKED FOR ACCEPTANCE.           @D6019 */
 /*********************************************************************/
   IF &U=1|&U=3|&U=2|&U=5 THEN DO   /* COPY/MERG/LOAD/REORG TBSP   @36*/
      IF &STR(&RCPYDSN1) = &STR("NULL") THEN DO    /* IF NULL, BOTH   */
         SET &RCPYDSN1 = &STR(**OPTIONAL**)        /* ARE ASSUMED     */
         SET &RCPYDSN2 = &STR(**OPTIONAL**)        /* NOT SPECIFIED.  */
      END
      ELSE DO                                    /* IF RCPYDSN1     */
         IF &STR(&RCPYDSN2) = &STR("NULL") THEN  /* IS SPECIFIED    */+
            SET &RCPYDSN2 = &STR(**OPTIONAL**)   /* CHECK RCPYDSN2. */
      END
   END
   ELSE DO
      SET &RCPYDSN1 = &STR(**NOT REQUIRED**)
      SET &RCPYDSN2 = &STR(**NOT REQUIRED**)
   END
 /*                                                                   */
 /*-------------------------------------------------------------------*/
 /*  ESTABLISH DEFAULT UTILITY ID IF REQUIRED.                        */
 /*-------------------------------------------------------------------*/
 /*                                                                   */
  SET &CNTLDSN = &STR(DSNU)&SUBSTR(1:3,&UTILITY)
   IF &UID = &STR("NULL") THEN +
     DO
       IF &SYSPREF = &STR() THEN +
         SET &UID = &STR(&CNTLDSN)
       ELSE +
         SET &UID = &STR(&SYSPREF..&CNTLDSN)
     END
 /*                                                                  */
 /********************************************************************/
 /*  PARAMETERS TO DSNUREQ                                           */
 /********************************************************************/
 /*                                                                  */
  SET &TITLE = &STR(TITLE)
  SET &UTIL = &&TITLE&U
  WRITE >>DSNU EXEC:
  WRITE >>  &UTIL. UTILITY REQUESTED WITH
  WRITE >>    CONTROL=&CONTROL., EDIT=&EDIT., RESTART=&RESTART.,
  WRITE >>    INDSN=&INDSN., RECDSN=&RECDSN., PUNCHDSN=&PUNCHDSN.,
  WRITE >>    DISCDSN=&DISCDSN.,LISTDSN=&LISTDSN., TEMPDSN=&TEMPDSN.,
  WRITE >>    COPYDSN=&COPYDSN., COPYDSN2=&COPYDSN2.,
  WRITE >>    RCPYDSN1=&RCPYDSN1., RCPYDSN2=&RCPYDSN2.,
  WRITE >>    SYSTEM=&SYSTEM., SUBMIT=&SUBMIT., UID=&UID.,
  WRITE >>    UNIT=&UNIT., VOLUME=&VOLUME., DB2I=&DB2I.,
  WRITE >>    LIB=&LIB..                                       /*@041*/
 /*                                                                  */
 /********************************************************************/
 /*  CHECK FOR ANY ERRORS BEFORE PROCESSING                          */
 /********************************************************************/
 /*                                                                  */
  IF &RC ^= 0 THEN GOTO ENDCLIST

 /********************************************************************/
 /*  SET CONTROL FILE DATA SET NAME VARIALBLE                        */
 /********************************************************************/
 /*                                                                  */
  WRITE >>  THE RESULTING JCL WILL BE WRITTEN TO &CNTLDSN..CNTL
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /*  DELETE THE OLD FILE CONTAINING PREVIOUSLY GENERATED CNTL FILE    */
 /*   CONTAINING THE JCL AND SYSIN STATEMENTS                         */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
   CONTROL NOMSG PROMPT            /* MAKE SURE NO MESSAGES ARE PRNTED*/
   ERROR OFF
   DELETE &CNTLDSN..CNTL
   FREE DSN(&CNTLDSN..CNTL)
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /*  ALLOCATE THE NEW FILE FOR GENERATED JCL AND ADMF UTILITY         */
 /*   STATEMENTS                                                      */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
   CONTROL NOPROMPT
   FREE ATTRLIST(DSNUFIX)
   ATTR DSNUFIX LRECL(80) RECFM(F B) BLKSIZE(800)
   ALLOC FILE(OUTJCL) REUS DA(&CNTLDSN..CNTL) NEW TRACKS +
             USING(DSNUFIX) SPACE ( 2,2)
   ERROR DO
         SET &TRC = &LASTCC
         GOTO TSOERROR
         END
   CONTROL PROMPT MSG
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /* BUILD THE JCL DECK:                                               */
 /*                                                                   */
 /*********************************************************************/
 /* >>INITIALIZE THE SUBSYSTEM PARAMETER                              */
 /*********************************************************************/
 /*                                                                   */
 CKSYSM: +
   IF &LENGTH(&SYSTEM) > 4 THEN DO
       WRITE >>ERROR:  SYSTEM &SYSTEM GREATER THAN 4 CHARACTERS
       &PRMTSYS
       SET &RET = &LASTCC
       IF &RET ^= 0 THEN DO
               IF &RC <= &RCBADP THEN &RC = &RCBADP
               GOTO ENDCLIST
               END
       SET &SYSTEM = &STR(&DSNUVALU)
       GOTO CKSYSM
       END
   SET &SUBSYS = &STR(SYSTEM=&SYSTEM)
 /*                                                                   */
 /*********************************************************************/
 /* >>INITIALIZE THE UTILITY ID PARAMETER                             */
 /*********************************************************************/
 /*                                                                   */
 CKUID: +
   IF &LENGTH(&UID) > 16 THEN DO
          WRITE >>ERROR:  UID &UID GREATER THAN 16 CHARACTERS
          &PRMTUID
          SET &RET = &LASTCC
          IF &RET ^= 0 THEN DO
               IF &RC <= &RCBADP THEN &RC = &RCBADP
               GOTO ENDCLIST
               END
          SET &UID = &STR(&DSNUVALU)
          GOTO CKUID
          END
   SET &ID = &STR(UID='&UID')
 /*                                                                   */
 /*********************************************************************/
 /* >>SET THE PROCESS VARIABLE TO THE APPROPRIATE                     */
 /*     START/RESTART DESIRED                                         */
 /*********************************************************************/
 /*                                                                   */
 CKREST: +
   IF &RESTART = &STR(NO) THEN +
           SET &REST= &STR(UTPROC='')
     ELSE IF &RESTART = &STR(PHASE) THEN +
           SET &REST= &STR(UTPROC='RESTART(PHASE)')
       ELSE IF &RESTART = &STR(CURRENT) THEN +
                 SET &REST= &STR(UTPROC=RESTART)
         ELSE IF &RESTART = &STR(PREVIEW) THEN +
                   SET &REST= &STR(UTPROC=PREVIEW)          /*  L415 */
        ELSE DO
          WRITE >>ERROR:  INVALID RESTART VALUE ENTERED
          &PRMTRES
          SET &RET = &LASTCC
          IF &RET ^= 0 THEN DO
               IF &RC <= &RCBADP THEN &RC = &RCBADP
               GOTO ENDCLIST
               END
          SET &RESTART = &STR(&DSNUVALU)
          GOTO CKREST
          END
 /*                                                                  */
 /*********************************************************************/
 /*                                                                   */
 /*   OPEN THE UTILITY CONTROL FILE AND BUILD THE UTILITY JOB         */
 /*     STREAM                                                        */
 /*                                                                   */
 /*                                                                  */
 /*********************************************************************/
 /*                                                                   */
 /*********************************************************************/
 /*   >> OPEN THE OUTPUT JCL FILE                                     */
 /*********************************************************************/
 /*                                                                   */
   SET &JCL = &STR(OPENTRY)
   OPENFILE OUTJCL OUTPUT
   SET &JCL = &STR(OPEN)
   SET &DEFJOB=0
   IF &DB2I=&STR(YES) THEN-
     DO
     ISPEXEC VGET (DSNEOV20,DSNEOV21,DSNEOV22,DSNEOV23) PROFILE
     IF &STR(&DSNEOV20)^=&STR( ) THEN-
       DO
         SET &DEFJOB=1
         SET &OUTJCL=&STR(&DSNEOV20)
         PUTFILE OUTJCL
       END
     IF &STR(&DSNEOV21)^=&STR( ) THEN-
       DO
         SET &DEFJOB=1
         SET &OUTJCL=&STR(&DSNEOV21)
         PUTFILE OUTJCL
       END
     IF &STR(&DSNEOV22)^=&STR( ) THEN-
       DO
         SET &DEFJOB=1
         SET &OUTJCL=&STR(&DSNEOV22)
         PUTFILE OUTJCL
       END
     IF &STR(&DSNEOV23)^=&STR( ) THEN-
       DO
         SET &DEFJOB=1
         SET &OUTJCL=&STR(&DSNEOV23)
         PUTFILE OUTJCL
       END
     END
   IF &DEFJOB = 0 THEN-
     DO
 /*********************************************************************/
 /*   >> MODIFY THE FOLLOWING CODE TO GENERATE A JOB CARD FOR         */
 /*      NON-DB2I DSNU USERS:                                         */
 /*********************************************************************/
     SET &OUTJCL = &STR(//&CNTLDSN. JOB YOUR_JOB_CARD_PARAMETERS,)
        PUTFILE OUTJCL
     SET &OUTJCL = &STR(//  USER=USER_ID,PASSWORD=USER_PASSWORD)
        PUTFILE OUTJCL
     SET &OUTJCL = &STR(/*ROUTE PRINT ROUTING_INFORMATION)
        PUTFILE OUTJCL
     END
 /*********************************************************************/
 /*   >> OUTPUT THE EXEC STATEMENT                                    */
 /*********************************************************************/
   SET &OUTJCL = &STR(//UTIL EXEC DSNUPROC,&SUBSYS)
   SET &OUTJCL = &STR(&OUTJCL.,&ID)
   /* If LIB parameter is NULL, business as usual                @041*/
   IF (&LIB = &STR("NULL")) THEN DO    /* If LIB is not set      @041*/
    IF &LENGTH(&STR(&OUTJCL)) + &LENGTH(&STR(&REST)) + 1 > 71 THEN DO
      SET &OUTJCL = &STR(&OUTJCL.,)
      PUTFILE OUTJCL
      SET &OUTJCL = &STR(//     &REST)
      END
    ELSE +
      SET &OUTJCL = &STR(&OUTJCL.,&REST)
    END
   ELSE DO  /* When user passed LIB value, we need to 1st handle @041*/
    /* the RESTART parameter. If after adding REST parm we       @041*/
    /* exceed max, we need to flush the output buffer first.     @041*/
    IF &LENGTH(&STR(&OUTJCL)) + &LENGTH(&STR(&REST)) + 1 > 71 THEN DO
     SET &OUTJCL = &STR(&OUTJCL.,)
     PUTFILE OUTJCL
     SET &OUTJCL = &STR(//     &REST)
     /* After adding RESTART, do we still have space for LIB ?   @041*/
     /* If not, FLUSH output, then process LIB parameter.        @041*/
     /* Else, Process both at the same line.                     @041*/
     IF &LENGTH(&STR(&OUTJCL)) + &LENGTH(&STR(&LIB)) + 6 > 71 THEN DO
       SET &OUTJCL = &STR(&OUTJCL.,)
       PUTFILE OUTJCL
       SET &OUTJCL = &STR(//     LIB(&LIB.))
       END
     ELSE SET &OUTJCL = &STR(&OUTJCL.,LIB(&LIB.))
     END
    ELSE DO /* Enough space left for REST variable, process REST @041*/
     SET &OUTJCL = &STR(&OUTJCL.,&REST.)
     /* Do we still have enough space for LIB in this line?      @041*/
     /* If No, flush the output before processing LIB.           @041*/
     /* Else, combine LIB in the same line.                      @041*/
     IF &LENGTH(&STR(&OUTJCL)) + &LENGTH(&STR(&LIB)) + 6 > 71 THEN DO
       SET &OUTJCL = &STR(&OUTJCL.,)
       PUTFILE OUTJCL
       SET &OUTJCL = &STR(//     LIB(&LIB.))
       END
     ELSE SET &OUTJCL = &STR(&OUTJCL.,LIB(&LIB))
     END
    END
   PUTFILE OUTJCL
 /*                                                                   */
 /*********************************************************************/
 /*   >> OUTPUT COMMENTS ABOUT THIS JCL DECK FOR LATER REFERENCE      */
 /*********************************************************************/
 /*                                                                   */
   SET &OUTJCL = &STR(//*     )
   PUTFILE OUTJCL
   SET &OUTJCL = &STR(//**********************************************)
   PUTFILE OUTJCL
   SET &OUTJCL = &STR(//*     )
   PUTFILE OUTJCL
   SET &OUTJCL = &STR(//*  GENERATING JCL FOR THE )
   SET &OUTJCL = &STR(&STR(&OUTJCL)&UTIL.&STR( UTILITY))
   PUTFILE OUTJCL
   SET &OUTJCL = &STR(&STR(//*  DATE:  )&SYSDATE.&STR(          ))
   SET &OUTJCL = &STR(&STR(&OUTJCL)&STR(TIME:  )&SYSTIME.)
   PUTFILE OUTJCL
   SET &OUTJCL = &STR(//*     )
   PUTFILE OUTJCL
   SET &OUTJCL = &STR(//**********************************************)
   PUTFILE OUTJCL
   SET &OUTJCL = &STR(//*     )
   PUTFILE OUTJCL
 /*                                                                  */
 /*********************************************************************/
 /* >>BUILD THE SYSCOPY DD STATEMENT                                  */
 /* >>BUILD THE SYSCOPY2 DD STATEMENT                          @D6019 */
 /*                      IF COPYDSN2 IS SPECIFIED.             @D6019 */
 /*********************************************************************/
 /*                                                                  */
   IF ((&U=1|&U=2|&U=5) AND &STR(&COPYDSN) ^= &STR(**OPTIONAL**)) +
       | &U = 3 THEN DO                         /* MERGECOPY OR COPY */
     /*                                                              */
     /*--------------------------------------------------------------*/
     /* ALLOCATE THE DATA SET                                        */
     /*--------------------------------------------------------------*/
     /*                                                              */
     SET &DSNAME = &STR(&COPYDSN.)
     SET &BRANCH = &STR(CPY1GEND)
     SET &DDNAME = &STR(SYSCOPY)
     SET &DTYPE  = &STR(PERM)
     GOTO DDGEN
 CPY1GEND:                            /* CHECK FOR COPYDSN2 @D6019 */ +
     IF &STR(&COPYDSN2) ^= &STR(**OPTIONAL**) THEN DO
        SET &DSNAME = &STR(&COPYDSN2.)
        SET &BRANCH = &STR(CPY2GEND)
        SET &DDNAME = &STR(SYSCOPY2)
        SET &DTYPE  = &STR(PERM)
        GOTO DDGEN
     END
 CPY2GEND: +
     END
 /*********************************************************************/
 /*  >> BUILD THE SYSRCPY1 DD STATEMENT                        @D6019 */
 /*                    IF RCPYDSN1 IS SPECIFIED.               @D6019 */
 /*  >> BUILD THE SYSRCPY2 DD STATEMENT                        @D6019 */
 /*                    IF RCPYDSN1 AND RCPYDSN2 IS SPECIFIED.  @D6019 */
 /*********************************************************************/
   IF &U=1|&U=3|&U=2|&U=5 THEN DO   /* COPY/MERG/LOAD/REORG TBSP   @36*/
     IF &STR(&RCPYDSN1) ^= &STR(**OPTIONAL**) THEN DO
        SET &DSNAME = &STR(&RCPYDSN1.)
        SET &BRANCH = &STR(RCY1GEND)
        SET &DDNAME = &STR(SYSRCPY1)
        SET &DTYPE  = &STR(PERM)
        GOTO DDGEN
 RCY1GEND: +
        IF &STR(&RCPYDSN2) ^= &STR(**OPTIONAL**) THEN DO
           SET &DSNAME = &STR(&RCPYDSN2.)
           SET &BRANCH = &STR(RCY2GEND)
           SET &DDNAME = &STR(SYSRCPY2)
           SET &DTYPE  = &STR(PERM)
           GOTO DDGEN
        END
 RCY2GEND: +
     END
   END
 /*                                                                  */
 /*********************************************************************/
 /*   >>   BUILD THE SORT WORK DD STATEMENTS                          */
 /*        FOR LOAD, REORG TABLESPACE, CHECK, RECOVER INDEX,@BA09328  */
 /*        REORG INDEX OR CHECK DATA               @BA09328     L108  */
 /*********************************************************************/
 /*                                                                  */
   IF &U=2 | &U=5 | &U=9 | &U=11 | &U=15 | &U=16 | &U=17 THEN /*@334*/+
     DO                                                       /* @334*/
     IF &SYSPREF = &STR() THEN +
       SET &DSNAME = &STR(SORTWK01)          /* NO QUALIFIER@BA33751 */
     ELSE +
       SET &DSNAME = &STR(&SYSPREF..SORTWK01) /* USE &SYSPREF@BA33751*/
     SET &BRANCH = &STR(SW1GEND)
     SET &DDNAME = &STR(SORTWK01)
     SET &DTYPE  = &STR(TEMP)
     GOTO DDGEN
 SW1GEND: +
     IF &SYSPREF = &STR() THEN +
       SET &DSNAME = &STR(SORTWK02)          /* NO QUALIFIER@BA33751 */
     ELSE +
       SET &DSNAME = &STR(&SYSPREF..SORTWK02) /* USE &SYSPREF@BA33751*/
     SET &BRANCH = &STR(SW2GEND)
     SET &DDNAME = &STR(SORTWK02)
     GOTO DDGEN
 SW2GEND: +
     IF &SYSPREF = &STR() THEN +
       SET &DSNAME = &STR(SORTWK03)          /* NO QUALIFIER@BA33751 */
     ELSE +
       SET &DSNAME = &STR(&SYSPREF..SORTWK03) /* USE &SYSPREF@BA33751*/
     SET &BRANCH = &STR(SW3GEND)
     SET &DDNAME = &STR(SORTWK03)
     GOTO DDGEN
 SW3GEND: +
     IF &SYSPREF = &STR() THEN +
       SET &DSNAME = &STR(SORTWK04)          /* NO QUALIFIER@BA33751 */
     ELSE +
       SET &DSNAME = &STR(&SYSPREF..SORTWK04) /* USE &SYSPREF@BA33751*/
     SET &BRANCH = &STR(SW4GEND)
     SET &DDNAME = &STR(SORTWK04)
     GOTO DDGEN
 SW4GEND: +
     END
 /*                                                                  */
 /*********************************************************************/
 /*   >> BUILD THE SYSREC  DD STATEMENT FOR LOAD, REORG TABLESPACE    */
 /*      OR UNLOAD UTILITY                                        @280*/
 /*********************************************************************/
 /*                                                                  */
 IF &U = 2 | &U = 5 | &U = 19 THEN DO                         /* @280*/
  IF &STR(&RECDSN) ^= &STR(**OPTIONAL**) THEN DO
   SET &DSNAME = &STR(&RECDSN)
   SET &BRANCH = &STR(RECGEND)
   SET &DDNAME = &STR(SYSREC)
   IF &U = 2 THEN                   /* IF LOAD THEN DISP=OLD@BA10465*/+
     SET &DTYPE = &STR(OLD)                              /* @BA10465*/
   ELSE                                                  /* @BA10465*/+
     SET &DTYPE  = &STR(PERM)
   GOTO DDGEN
 RECGEND: +
   IF &TRC = 12 AND (&U = 5 | &U = 19) THEN SET &TRC = 0      /* @280*/
   IF &TRC > 0 THEN DO
      IF &TRC = 12 THEN +
               WRITE >> ERROR: &RECDSN DOES NOT EXIST.
      ELSE DO
        WRITE >> ERROR:  A TSO ERROR CODE OF &TRC WAS ENCOUNTERED
        WRITE >>           DURING THE ALLOCATION OF &RECDSN..
        END
      IF &RC <= &RCTSO THEN SET &RC = &RCTSO
      GOTO TSOERROR
      END
   END
  END
 /*                                                                  */
 /********************************************************************/
 /*   >> BUILD THE SYSPUNCH DD STATEMENT                        L372 */
 /********************************************************************/
 /*                                                                  */
 IF (&U=5|&U=19) && &STR(&PUNCHDSN)^=&STR("OMITTED") THEN DO  /* @280*/
   SET &DSNAME = &STR(&PUNCHDSN)
   SET &BRANCH = &STR(PUNGEND)
   SET &DDNAME = &STR(SYSPUNCH)
   SET &DTYPE  = &STR(PERM)
   GOTO DDGEN
 PUNGEND: +
   IF &TRC>0 && &TRC^=12 THEN DO
      WRITE >> ERROR:  A TSO ERROR CODE OF &TRC WAS ENCOUNTERED
      WRITE >>           DURING THE ALLOCATION OF &PUNCHDSN..
      IF &RC <= &RCTSO THEN SET &RC = &RCTSO
      GOTO TSOERROR
      END
   END
 /*                                                                   */
 /*********************************************************************/
 /*   >> BUILD THE SYSDISC DD STATEMENT                               */
 /*********************************************************************/
 /*                                                                  */
 IF (&U = 2 | &U = 5)                  /* LOAD OR REORG              */+
  && &STR(&DISCDSN)^=&STR("OMITTED") THEN DO
   SET &DSNAME = &STR(&DISCDSN)
   SET &BRANCH = &STR(DSCGEND)
   SET &DDNAME = &STR(SYSDISC)
   SET &DTYPE  = &STR(PERM)
   GOTO DDGEN
 DSCGEND: +
   IF &TRC>0 && &TRC^=12 THEN DO
      WRITE >> ERROR:  A TSO ERROR CODE OF &TRC WAS ENCOUNTERED
      WRITE >>           DURING THE ALLOCATION OF &DISCDSN..
      IF &RC <= &RCTSO THEN SET &RC = &RCTSO
      GOTO TSOERROR
      END
   END
 /*                                                                  */
 /********************************************************************/
 /*   >> BUILD THE SYSUT1  DD STATEMENT FOR LOAD, REORG TABLESPACE,  */
 /*      CHECK, RECOVER INDEX, REORG INDEX OR CHECK DATA        L108 */
 /*      NOTE: FOR REORG INDEX, THE DISP OF SYSUT1 IS PERM  @BA09328 */
 /********************************************************************/
 /*                                                                  */
   IF (&U=2|&U=5|&U=9|&U=11|&U=15|&U=16|&U=17) THEN DO        /* @334*/
     IF &SYSPREF = &STR() THEN +
       SET &DSNAME = &STR(SYSUT1)            /* NO QUALIFIER@BA33751 */
     ELSE +
       SET &DSNAME = &STR(&SYSPREF..SYSUT1)  /* USE &SYSPREF @BA33751*/
     SET &BRANCH = &STR(UT1GEND)
     SET &DDNAME = &STR(SYSUT1)
     IF &U = 15 THEN                                    /* @BA09328 */+
       SET &DTYPE = &STR(PERM)                          /* @BA09328 */
     ELSE                                               /* @BA09328 */+
       SET &DTYPE  = &STR(TEMP)
     GOTO DDGEN
 UT1GEND: +
     END
 /*                                                                  */
 /********************************************************************/
 /*   >> BUILD THE SORTOUT DD STATEMENT FOR LOAD, REORG TABLESPACE,  */
 /*      REORG INDEX OR CHECK DATA                          @BA09328 */
 /********************************************************************/
 /*                                                                  */
   IF &U = 2 | &U = 5 | &U = 15 | &U = 16 THEN DO   /* @BA09328  L108*/
     IF &SYSPREF = &STR() THEN +
       SET &DSNAME = &STR(SORTOUT)           /* NO QUALIFIER@BA33751 */
     ELSE +
       SET &DSNAME = &STR(&SYSPREF..SORTOUT) /* USE &SYSPREF @BA33751*/
     SET &BRANCH = &STR(OUTGEND)
     SET &DDNAME = &STR(SORTOUT)
     SET &DTYPE  = &STR(TEMP)
     GOTO DDGEN
 OUTGEND: +
     END
 /*                                                                  */
 /********************************************************************/
 /*   >> BUILD THE SYSERR DD STATEMENT FOR LOAD OR CHECK DATA   L108 */
 /********************************************************************/
 /*                                                                  */
   IF &U = 2 | &U = 16 THEN DO               /* LOAD VAL., CHECK DATA*/
     IF &SYSPREF = &STR() THEN +
       SET &DSNAME = &STR(SYSERR)            /* NO QUALIFIER@BA33751 */
     ELSE +
       SET &DSNAME = &STR(&SYSPREF..SYSERR)  /* USE &SYSPREF @BA33751*/
     SET &BRANCH = &STR(ERRGEND)             /*                 L108 */
     SET &DDNAME = &STR(SYSERR)              /*                 L108 */
     SET &DTYPE  = &STR(TEMP)                /*                 L108 */
     GOTO DDGEN                              /*                 L108 */
 ERRGEND: +
   END
 /*                                                                  */
 /********************************************************************/
 /*   >> BUILD THE SYSMAP DD STATEMENT FOR LOAD VALIDATION      L108 */
 /********************************************************************/
 /*                                                                  */
   IF &U = 2  THEN DO                        /* LOAD VALIDATION L108 */
     IF &SYSPREF = &STR() THEN +
       SET &DSNAME = &STR(SYSMAP)            /* NO QUALIFIER@BA33751 */
     ELSE +
       SET &DSNAME = &STR(&SYSPREF..SYSMAP)  /* USE &SYSPREF @BA33751*/
     SET &BRANCH = &STR(MAPGEND)             /*                 L108 */
     SET &DDNAME = &STR(SYSMAP)              /*                 L108 */
     SET &DTYPE  = &STR(TEMP)                /*                 L108 */
     GOTO DDGEN                              /*                 L108 */
 MAPGEND: +
   END
 /*                                                                   */
 /*********************************************************************/
 /*   >> BUILD THE SYSLISTD DD STATEMENT                         L415 */
 /*********************************************************************/
 /*                                                                  */
 IF  &LISTDSN ^= SYSIN && -
     &LISTDSN ^=&STR("OMITTED") THEN DO
   SET &DSNAME = &STR(&LISTDSN)
   SET &BRANCH = &STR(LSTGEND)
   SET &DDNAME = &STR(SYSLISTD)
   SET &DTYPE  = &STR(OLD)
   GOTO DDGEN
 LSTGEND: +
   IF &TRC>0 && &TRC^=12 THEN DO
      WRITE >> ERROR:  A TSO ERROR CODE OF &TRC WAS ENCOUNTERED
      WRITE >>           DURING THE ALLOCATION OF &LISTDSN..
      IF &RC <= &RCTSO THEN SET &RC = &RCTSO
      GOTO TSOERROR
      END
   END
 /*                                                                   */
 /*********************************************************************/
 /*   >> BUILD THE SYSTEMPL DD STATEMENT                         L415 */
 /*********************************************************************/
 /*                                                                  */
 IF  &TEMPDSN ^= SYSIN && -
     &TEMPDSN ^=&STR("OMITTED") THEN DO
   SET &DSNAME = &STR(&TEMPDSN)
   SET &BRANCH = &STR(TMPGEND)
   SET &DDNAME = &STR(SYSTEMPL)
   SET &DTYPE  = &STR(OLD)
   GOTO DDGEN
 TMPGEND: +
   IF &TRC>0 && &TRC^=12 THEN DO
      WRITE >> ERROR:  A TSO ERROR CODE OF &TRC WAS ENCOUNTERED
      WRITE >>           DURING THE ALLOCATION OF &TEMPDSN..
      IF &RC <= &RCTSO THEN SET &RC = &RCTSO
      GOTO TSOERROR
      END
   END
 /*                                                                   */
 /*********************************************************************/
 /*   >> PROCESS THE SUPPLIED UTILITY CONTROL STATEMENT DATA SET      */
 /*********************************************************************/
 /*                                                                   */
   SET &OUTJCL = &STR(//DSNUPROC.SYSIN    DD  *                    )
   PUTFILE OUTJCL
 /*                                                                   */
 /*-------------------------------------------------------------------*/
 /* SETUP OUTPUT FILE                                                 */
 /*-------------------------------------------------------------------*/
 /*                                                                   */
  CONTROL NOPROMPT
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /* ERROR EXIT FOR ALLOCATION, OPEN AND READING OF INPUT FILE        */
 /*------------------------------------------------------------------*/
 /*                                                                  */
  ERROR DO
     SET &TRC = &LASTCC
     IF &TRC = &RCEOF && &PROCESS = &STR(GETFILE) THEN +
          GOTO EOFFND              /* IF E-O-F ENCOUNTERED ON FILE   */
     IF &PROCESS = &STR(ALLOC) THEN DO
          SET &TIME = &TIME + 1
          IF &TIME = 2 THEN +
             WRITE >> ERROR: INPUT FILE &INDSN. DOES NOT EXIST.
          ELSE DO
             IF &SYSPREF = &STR() THEN +
               SET &IND = &STR(&QUOTE.&INDSN.&QUOTE.)
             ELSE +
               SET &IND = &STR(&QUOTE.&SYSPREF..&INDSN.&QUOTE.)
             GOTO ALLOCIND
             END
          END
       ELSE IF &PROCESS = &STR(OPEN) THEN +
          WRITE >> ERROR: OPEN ERROR FOUND FOR INPUT FILE &INDSN..
       ELSE IF &PROCESS = &STR(GETFILE) THEN +
          WRITE >> ERROR: READ ERROR ON INPUT FILE &INDSN..
       ELSE IF &PROCESS = &STR(CLOSE) THEN +
          WRITE >> ERROR: ERROR WHILE CLOSING INPUT FILE &INDSN..
     GOTO TSOERROR
     END
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /* ERROR EXIT FOR ALLOCATION, OPEN AND READING OF INPUT FILE        */
 /*------------------------------------------------------------------*/
 /*                                                                  */
     SET &IND = &STR(&QUOTE.&INDSN.&QUOTE.)
     SET &TIME = 0
     SET &PROCESS = &STR(ALLOC)
     CONTROL NOPROMPT NOMSG
  ALLOCIND: +
     ALLOC FILE(INUTIL) DA(&IND.) SHR REUS
    CONTROL PROMPT MSG
    SET &PROCESS = &STR(OPEN)
    OPENFILE INUTIL INPUT
    SET &INP = &STR(OPEN)
 /*                                                                   */
 /*-------------------------------------------------------------------*/
 /* READ IN THE FILE                                                  */
 /*-------------------------------------------------------------------*/
 /*                                                                   */
  SET &PROCESS = &STR(GETFILE)
  SET &COUNT = 0
  DO WHILE &COUNT = 0              /* DO UNTIL E-O-F SIGNALLED        */
     GETFILE  INUTIL
     SET &OUTJCL = &INUTIL
     PUTFILE OUTJCL
     END
 /*                                                                  */
 /*------------------------------------------------------------------*/
 /* CLOSE THE ADMF UTILITIES CONTROL STATEMENT INPUT FILE            */
 /*------------------------------------------------------------------*/
 /*                                                                  */
 EOFFND: +
  SET &PROCESS = &STR(CLOSE)
  SET &INP = &STR(CLOSE)
  CLOSFILE INUTIL
  SET &PROCESS = &STR(FREE)            /*                      L109  */
  SET &INP = &STR(FREE)
  FREE FILE(INUTIL)
  ERROR OFF                            /* TURN OFF ERROR ROUTINE     */
  ERROR DO
         SET &TRC = &LASTCC
         GOTO TSOERROR
         END
 /*                                                                  */
 /********************************************************************/
 /*      WRITE THE FINAL END-OF JOB TERMINATOR                       */
 /********************************************************************/
 /*                                                                  */
  SET &OUTJCL = &STR(//                   )
  PUTFILE OUTJCL
  SET &JCL = &STR(CLOSE)
  CLOSFILE OUTJCL
  SET &JCL = &STR(FREE)
  FREE FILE(OUTJCL)
  /*                                                                  */
  /********************************************************************/
  /*   >> JCL PROCESSING IS NOW COMPLETE                              */
  /********************************************************************/
  /*                                                                  */
  /*                                                                  */
  /********************************************************************/
  /*                                                                  */
  /*  IF EDIT(YES) THEN INVOKE EDIT COMMAND                           */
  /*                                                                  */
  /********************************************************************/
  /*                                                                  */
  CKEDIT: +
    IF &EDIT = &STR(TSO) THEN DO
     /*--------------------------------------------------------------*/
     /*  INVOKE THE TSO EDITOR.    THE EDIT SESSION IS TERMINATED BY */
     /*    "END SAVE  OR NOSAVE" EDIT PARAMETERS                     */
     /*--------------------------------------------------------------*/
       WRITE >>TSO EDITING OF FILE &CNTLDSN..CNTL
       WRITE >>ENTER DESIRED TSO EDIT SUBCOMMANDS.
       WRITE >>TO TERMINATE:  ENTER 'SAVE' (TO SAVE CHANGES) OR
       WRITE >>                     'NOSAVE' (TO NOT SAVE THE CHANGES).
       EDIT &CNTLDSN CNTL NONUM
 ENDT: TERMIN SAVE,NOSAVE,END
       IF &SYSDLM = 1 THEN  DATA
                  END SAVE
                  ENDDATA
       IF &SYSDLM = 2 THEN DATA
                  END NOSAVE
                  ENDDATA
       IF &SYSDLM = 3 THEN DO
           WRITE  PLEASE ENTER 'SAVE' OR 'NOSAVE'
           GOTO ENDT
           END
       SET &ERC = &LASTCC
       IF &ERC ^= 0 THEN DO
           WRITE >> ERROR: TSO EDITOR RETURN CODE IS &ERC..
           IF &RC <= &RCEDIT THEN &RC = &RCEDIT
           GOTO ENDCLIST
           END
       END
    /*---------------------------------------------------------------*/
    /*  INVOKE THE SPF EDITOR.    THE EDIT SESSION IS TERMINATED BY  */
    /*    PF3                                                        */
    /*---------------------------------------------------------------*/
    ELSE IF &EDIT = &STR(SPF) THEN DO
       WRITE >>SPF EDITING FACILITY INVOKED TO EDIT &CNTLDSN..CNTL
       WRITE >>  WHEN *** APPEAR, PLEASE PRESS ENTER
       WRITE >>  TO TERMINATE SPF:
       WRITE >>     PRESS PF3    - RETURN TO CLIST WITH CHANGES
       WRITE >>     PRESS PF4    - RETURN TO CLIST WITH CHANGES THEN
       WRITE >>                    RETURN TO MAIN MENU
       WRITE >>     ENTER CANCEL - RETURN TO CLIST WITH NO CHANGES
       ERROR DO
         SET &ERC = &LASTCC
         IF &ERC <= 4 THEN GOTO CKSUB /* TEST FOR VALID RC FROM SPF  */
         IF &ERC ^= 0 THEN DO
           WRITE >> ERROR: SPF EDITOR RETURN CODE IS &ERC..
           IF &RC <= &RCEDIT THEN &RC = &RCEDIT
           GOTO ENDCLIST
           END
         END
       ISPEXEC EDIT DATASET(&CNTLDSN..CNTL)
       END
    /*---------------------------------------------------------------*/
    /*  INVALID  EDIT PARAMETER VALUE                                */
    /*---------------------------------------------------------------*/
    ELSE IF &EDIT ^= &STR(NO) THEN DO
          WRITE >>ERROR:  EDIT MUST BE EITHER TSO, SPF OR NO
          &PRMTEDT
          SET &RET = &LASTCC
          IF &RET ^= 0 THEN DO
               IF &RC <= &RCBADP THEN &RC = &RCBADP
               GOTO ENDCLIST
               END
          SET &EDIT = &STR(&DSNUVALU)
          GOTO CKEDIT
          END
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /* PROCESS SUBMIT PARAMETER                                          */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 CKSUB: +
  ERROR OFF
  ERROR DO
         SET &TRC = &LASTCC
         GOTO TSOERROR
         END
  IF &SUBMIT = &STR(YES) THEN DO
    /*----------------------------------------------------------------*/
    /*  SUBMIT THE JCL GENERATED                                      */
    /*----------------------------------------------------------------*/
       SUBMIT (&CNTLDSN..CNTL)
       WRITE >>FILE &CNTLDSN..CNTL TRANSMITTED TO BATCH
       END
    /*----------------------------------------------------------------*/
    /*  SUBMIT VALUE EITHER INVALID OR PROMPT                         */
    /*----------------------------------------------------------------*/
     ELSE IF &SUBMIT ^= &STR(NO) THEN DO
          IF &EDIT =^ &STR(PROMPT) THEN +
            WRITE >>ERROR:  SUBMIT MUST BE EITHER YES, NO OR PROMPT
          &PRMTSUB
          SET &RET = &LASTCC                               /*@BA43083*/
          IF &RET ^= 0 THEN DO
               IF &RC <= &RCBADP THEN &RC = &RCBADP
               GOTO ENDCLIST
               END
          SET &SUBMIT = &STR(&DSNUVALU)
          GOTO CKSUB
          END
    GOTO ENDCLIST
 /*                                                                  */
 /********************************************************************/
 /*                                                                  */
 /*  ERROR EXIT                                                      */
 /*                                                                  */
 /********************************************************************/
 /*                                                                  */
  TSOERROR: +
    ERROR OFF
    IF &TRC = &RCNEX && &JCL = &STR(OPENTRY) THEN +
      WRITE >> ERROR: &CNTLDSN..CNTL IS CATALOGUED BUT DOES NOT EXIST
    WRITE >> ERROR: TSO RETURN CODE IS &TRC..
    IF &RC <= &RCTSO THEN SET &RC = &RCTSO
 /*                                                                  */
 /********************************************************************/
 /*                                                                  */
 /*  END OF THE DSNU CLIST                                           */
 /*                                                                  */
 /********************************************************************/
 /*                                                                  */
  ENDCLIST: +
    CONTROL NOMSG NOPROMPT
    IF &RC > &RCWARN THEN DO
       IF &INP = &STR(OPEN) THEN DO
          SET &INP = &STR(CLOSE)
          CLOSFILE INUTIL
          END
       IF &INP = &STR(CLOSE) THEN DO
          SET &INP = &STR(FREE)
          FREE FILE(INUTIL)
          END
       IF &JCL = &STR(OPEN) THEN DO
          SET &JCL = &STR(CLOSE)
          CLOSFILE OUTJCL
          END
       IF &JCL = &STR(CLOSE) THEN DO
          SET &JCL = &STR(FREE)
          FREE FILE(OUTJCL)
          END
       IF &RC <= &RCTSO THEN SET &RC = &RCTSO
       END
  CONTROL MSG PROMPT
  EXIT CODE(&RC.)
 /*********************************************************************/
 /*   ***                                              ***            */
 /*          DDGEN EXIT:  GENERATE A DD STATEMENT                     */
 /*   ***                                              ***            */
 /*********************************************************************/
 /*                                                                   */
 /*-------------------------------------------------------------------*/
 /*     ESTABLISH A NEW ERROR INTERRUPT ENVIRONMENT                   */
 /*-------------------------------------------------------------------*/
  DDGEN: +
     ERROR DO
       SET &TRC = &LASTCC
       SET &TIME = &TIME + 1
       /*=============================================================*/
       /* IF THIS IS THE SECOND TIME IN THIS EXIT OR THE DATASET IS   */
       /*   GENERATED BY THIS CLIST (A TEMPORARY DS) THEN ASSUME THE  */
       /*   DATA SET IS A NEW ONE                                     */
       /*=============================================================*/
       IF &TIME = 2 | &DTYPE = &STR(TEMP) THEN DO
          SET &DSN = &STR(&DSNAME)
          SET &COM = &STR(,)
          SET &STAT = &STR(NEW)
          GOTO PROCIT
          END
       /*=============================================================*/
       /* CHECK WHETHER A DATASET BY THE NAME OF TSOID.DSNAME CAN BE  */
       /*     FOUND                                                   */
       /*=============================================================*/
       ELSE DO
            IF &SYSPREF = &STR() THEN +
              SET &DSN = &STR(&QUOTE.&DSNAME.&QUOTE.)
            ELSE +
              SET &DSN = &STR(&QUOTE.&SYSPREF..&DSNAME.&QUOTE.)
            GOTO ALLOCIT
            END

       END
 /*********************************************************************/
 /*     INITIALIZE IMPORTANT VARIABLES.  CONSTRUCT A DATA SET NAME    */
 /*        USING THE SPECIFIED NAME.                                  */
 /*********************************************************************/
     SET &STAT = &STR(OLD)
     SET &COM = &STR()
     SET &DSN = &STR(&QUOTE.&DSNAME.&QUOTE.)
     SET &TIME = 0
 /*********************************************************************/
 /*     ALLOCATE THE DATA SET                                         */
 /*********************************************************************/
     CONTROL NOPROMPT NOMSG
  ALLOCIT: +
     ALLOC FILE(&DDNAME.) REUS DA(&DSN.) SHR
     ERROR OFF
     FREE DSN(&DSN.)                                 /* FREE OLD ATTR */
     SET &TRC = 0
     SET &LEN = &LENGTH(&DSN.)-1
     SET &DSN = &SUBSTR(2:&LEN.,&DSN.)               /* REMOVE QUOTES */
 /*********************************************************************/
 /*     RE-ESTABLISH THE ERROR INTERRUPT ENVIRONMENT                  */
 /*********************************************************************/
  PROCIT: +
     ERROR OFF
     ERROR DO
         SET &TRC = &LASTCC
         GOTO TSOERROR
         END
     CONTROL MSG NOPROMPT
 /*********************************************************************/
 /*     GENERATE THE DD STATEMENT                                     */
 /*********************************************************************/
     SET &OUTJCL =&STR(//DSNUPROC.&DDNAME. DD DSN=&DSN.,)
     PUTFILE OUTJCL
     IF &DTYPE = &STR(TEMP) && &STAT = &STR(NEW) &&      /* @BA19380*/+
          &VOLUME ^= &STR("OMITTED") THEN                /* @BA19380*/+
       SET &OUTJCL = &STR(//     DISP=(NEW,DELETE,CATLG)&COM.)
     ELSE                                                /* @BA10465*/+
     IF &DTYPE = &STR(TEMP) THEN +
       SET &OUTJCL = &STR(//     DISP=(MOD,DELETE,CATLG)&COM.)
     ELSE                                                /* @BA10465*/+
       IF &DTYPE = &STR(PERM) && &STAT = &STR(NEW) &&    /* @BA19380*/+
          &VOLUME ^= &STR("OMITTED") THEN                /* @BA19380*/+
         SET &OUTJCL = &STR(//     DISP=(NEW,CATLG)&COM.) /*@BA19380*/
       ELSE                                              /* @BA19380*/+
       IF &DTYPE = &STR(PERM) THEN                       /* @BA10465*/+
         SET &OUTJCL = &STR(//     DISP=(MOD,CATLG)&COM.)
       ELSE                                              /* @BA10465*/+
         SET &OUTJCL = &STR(//     DISP=OLD&COM.)        /* @BA10465*/
     PUTFILE OUTJCL
     IF &STAT = &STR(NEW) THEN DO
         SET &OUTJCL = &STR(//     SPACE=(16384,(20,20),,,ROUND),)
         PUTFILE OUTJCL
         SET &OUTJCL = &STR(//     UNIT=&UNIT.)
         IF &VOLUME ^= &STR("OMITTED") THEN +
                  SET &OUTJCL = &STR(&OUTJCL.,VOL=SER=&VOLUME.)
         PUTFILE OUTJCL
         END
     GOTO &BRANCH
 /*********************************************************************/
 /*     END OF DSNU CLIST                                             */
 /*********************************************************************/
++
//DSNTIVN EXEC DSNTIVB,CLIST=DSNUREQ  UTILITY
//DSNTIVO EXEC DSNTIVB,CLIST=DSNTINS1 INSTALL
//DSNTIVP EXEC DSNTIVB,CLIST=DSNTINS2 INSTALL
//DSNTIVQ EXEC DSNTIVB,CLIST=DSNECPRI DB2I
//DSNTIVT EXEC DSNTIVB,CLIST=DSNTCALC INSTALL
//DSNTIVU EXEC DSNTIVB,CLIST=DSNTEDIT SAMPLE
//DSNTIVV EXEC DSNTIVB,CLIST=DSNEBC06 DB2I
//DSNTIVW EXEC DSNTIVB,CLIST=DSNEBC19 DB2I
//DSNTIVX EXEC DSNTIVB,CLIST=DSNTINS3 INSTALL
//DSNTIVY EXEC DSNTIVB,CLIST=DSNTINSV INSTALL
//*
## Macro to get language environment runtime library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getLerun $lib)
#getLib($lib, "CEE.V!R!M!.SCEERUN")#end
## Macro to get C C++ compiler library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getCcomp $lib)
#getLib($lib, "CBC.SCCNCMP")#end
## Macro to get C C++ compiler name
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getCprog $lib)
#getLib($lib, "CCNDRVR")#end
## Macro to get LE prelink message library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getLeplmsgl $lib)
#getLib($lib, "CEE.V!R!M!.SCEEMSGP")#end
## Macro to get cobol compiler library
## $lib is the library name
## return $lib if it is not blank, return default otherwise
#macro (getIcobcomp $lib)
#getLib($lib, "IGY.V1R2M0.SIGYCOMP")#end
## Macro to get library name
## $lib is the user specified library name
## $dflt is the default library name
## return $lib if it is not blank, return default otherwise
#macro (getLib $lib $dflt)
#if ($lib == "")
$dflt#else$lib#end#end
## Macro to get C C++ compiler information
## $lib1 is the C C++ compiler library
## $lib2 is the C C++ compiler name
## return the concatenation of compiler library and name
#macro (getCcload $lib1 $lib2)
#getCcomp($lib1)(#getCprog($lib2))#end
## Macro to get the prefix of IMS library
## $lib is the IMS library name
## return the prefix if not blank, return IMVSVS otherwise
#macro (getImsPre $lib)
#set ( $end = $lib.lastIndexOf(".") )
#if ($lib == "")
IMSVS#else
#if ($end > 0)
$lib.substring(0, $end)#else
$lib#end#end#end
## Macro to get the default quote string
## $str is the string representation of default quote
## return the default quote string
#macro (getDefStr $str)
#if ($str ==  "QUOTE")
"#else#if ($str == "APOST")
'#else
DEFAULT#end#end#end
## Macro to get the default decpoint string
## $dec is the string representation of default decpoint
## return the default decpoint string
#macro (getDecPt $dec)
#if ($str ==  "COMMA")
,#else.#end#end
## Macro to append suffix for data sets
## $suffix is the data set suffix
## return the suffix with the right period
#macro (libs $suffix)
#if ($suffix !=  "")
.$suffix#else#end#end
